[
  {
    "path": "gateway/__init__.py",
    "doc": "Core package for the Duskmantle knowledge gateway.",
    "imports": [
      "__future__"
    ],
    "functions": [
      {
        "name": "get_version",
        "signature": "get_version()",
        "doc": "Return the current package version."
      }
    ],
    "classes": [],
    "assignments": [
      "__all__",
      "__version__"
    ]
  },
  {
    "path": "gateway/__main__.py",
    "doc": "Console entry point that launches the FastAPI application.",
    "imports": [
      "__future__",
      "uvicorn"
    ],
    "functions": [
      {
        "name": "main",
        "signature": "main()",
        "doc": "Run the gateway API using Uvicorn."
      }
    ],
    "classes": [],
    "assignments": []
  },
  {
    "path": "gateway/api/__init__.py",
    "doc": "API layer for the knowledge gateway.",
    "imports": [],
    "functions": [],
    "classes": [],
    "assignments": []
  },
  {
    "path": "gateway/api/app.py",
    "doc": "Primary FastAPI application wiring for the knowledge gateway.",
    "imports": [
      "__future__",
      "apscheduler.schedulers.base",
      "collections.abc",
      "contextlib",
      "fastapi",
      "fastapi.responses",
      "fastapi.staticfiles",
      "gateway",
      "gateway.api.dependencies",
      "gateway.api.routes",
      "gateway.config.settings",
      "gateway.graph",
      "gateway.graph.migrations",
      "gateway.observability",
      "gateway.scheduler",
      "gateway.search.feedback",
      "gateway.search.trainer",
      "gateway.ui",
      "json",
      "logging",
      "neo4j",
      "neo4j.exceptions",
      "qdrant_client",
      "slowapi",
      "slowapi.errors",
      "slowapi.middleware",
      "slowapi.util",
      "time",
      "typing",
      "uuid"
    ],
    "functions": [
      {
        "name": "_validate_auth_settings",
        "signature": "_validate_auth_settings(settings)",
        "doc": null
      },
      {
        "name": "_log_startup_configuration",
        "signature": "_log_startup_configuration(settings)",
        "doc": null
      },
      {
        "name": "_build_lifespan",
        "signature": "_build_lifespan(settings)",
        "doc": null
      },
      {
        "name": "_configure_rate_limits",
        "signature": "_configure_rate_limits(app, settings)",
        "doc": null
      },
      {
        "name": "_init_feedback_store",
        "signature": "_init_feedback_store(settings)",
        "doc": null
      },
      {
        "name": "_load_search_model",
        "signature": "_load_search_model(settings)",
        "doc": null
      },
      {
        "name": "_init_graph_driver",
        "signature": "_init_graph_driver(settings)",
        "doc": null
      },
      {
        "name": "_init_qdrant_client",
        "signature": "_init_qdrant_client(settings)",
        "doc": null
      },
      {
        "name": "_create_graph_driver",
        "signature": "_create_graph_driver(settings)",
        "doc": null
      },
      {
        "name": "_verify_graph_database",
        "signature": "_verify_graph_database(driver, database)",
        "doc": null
      },
      {
        "name": "_run_graph_auto_migration",
        "signature": "_run_graph_auto_migration(driver, database)",
        "doc": null
      },
      {
        "name": "_fetch_pending_migrations",
        "signature": "_fetch_pending_migrations(runner)",
        "doc": null
      },
      {
        "name": "_log_migration_plan",
        "signature": "_log_migration_plan(pending)",
        "doc": null
      },
      {
        "name": "_log_migration_completion",
        "signature": "_log_migration_completion(pending)",
        "doc": null
      },
      {
        "name": "_set_migration_metrics",
        "signature": "_set_migration_metrics(status)",
        "doc": null
      },
      {
        "name": "create_app",
        "signature": "create_app()",
        "doc": "Create the FastAPI application instance."
      },
      {
        "name": "_rate_limit_handler",
        "signature": "_rate_limit_handler(_request, exc)",
        "doc": null
      }
    ],
    "classes": [],
    "assignments": [
      "logger"
    ]
  },
  {
    "path": "gateway/api/auth.py",
    "doc": "Authentication dependencies used across the FastAPI surface.",
    "imports": [
      "__future__",
      "collections.abc",
      "fastapi",
      "fastapi.security",
      "gateway.config.settings"
    ],
    "functions": [
      {
        "name": "require_scope",
        "signature": "require_scope(scope)",
        "doc": "Return a dependency enforcing the given scope."
      },
      {
        "name": "_allowed_tokens_for_scope",
        "signature": "_allowed_tokens_for_scope(settings, scope)",
        "doc": null
      }
    ],
    "classes": [],
    "assignments": [
      "_security",
      "require_reader",
      "require_maintainer"
    ]
  },
  {
    "path": "gateway/api/dependencies.py",
    "doc": "FastAPI dependency helpers for the gateway application.",
    "imports": [
      "__future__",
      "fastapi",
      "gateway.config.settings",
      "gateway.graph",
      "gateway.ingest.embedding",
      "gateway.search",
      "gateway.search.feedback",
      "gateway.search.trainer",
      "logging",
      "slowapi"
    ],
    "functions": [
      {
        "name": "get_app_settings",
        "signature": "get_app_settings(request)",
        "doc": "Return the application settings attached to the FastAPI app."
      },
      {
        "name": "get_limiter",
        "signature": "get_limiter(request)",
        "doc": "Return the rate limiter configured on the FastAPI app."
      },
      {
        "name": "get_search_model",
        "signature": "get_search_model(request)",
        "doc": "Return the cached search ranking model from application state."
      },
      {
        "name": "get_graph_service_dependency",
        "signature": "get_graph_service_dependency(request)",
        "doc": "Return a memoised graph service bound to the current FastAPI app."
      },
      {
        "name": "get_search_service_dependency",
        "signature": "get_search_service_dependency(request)",
        "doc": "Construct (and cache) the hybrid search service for the application."
      },
      {
        "name": "get_feedback_store",
        "signature": "get_feedback_store(request)",
        "doc": "Return the configured search feedback store, if any."
      }
    ],
    "classes": [],
    "assignments": [
      "logger",
      "__all__"
    ]
  },
  {
    "path": "gateway/api/routes/__init__.py",
    "doc": "FastAPI route modules for the gateway application.",
    "imports": [
      ""
    ],
    "functions": [],
    "classes": [],
    "assignments": [
      "__all__"
    ]
  },
  {
    "path": "gateway/api/routes/graph.py",
    "doc": "Graph API routes.",
    "imports": [
      "__future__",
      "fastapi",
      "fastapi.responses",
      "gateway.api.auth",
      "gateway.api.dependencies",
      "gateway.graph",
      "slowapi",
      "typing"
    ],
    "functions": [
      {
        "name": "create_router",
        "signature": "create_router(limiter, metrics_limit)",
        "doc": "Create an API router exposing graph endpoints with shared rate limits."
      }
    ],
    "classes": [],
    "assignments": [
      "__all__"
    ]
  },
  {
    "path": "gateway/api/routes/health.py",
    "doc": "Health and observability endpoints.",
    "imports": [
      "__future__",
      "contextlib",
      "fastapi",
      "gateway.api.dependencies",
      "gateway.config.settings",
      "json",
      "prometheus_client",
      "slowapi",
      "sqlite3",
      "time",
      "typing"
    ],
    "functions": [
      {
        "name": "create_router",
        "signature": "create_router(limiter, metrics_limit)",
        "doc": "Wire up health, readiness, and metrics endpoints."
      },
      {
        "name": "build_health_report",
        "signature": "build_health_report(app, settings)",
        "doc": "Assemble the health payload consumed by `/healthz`."
      },
      {
        "name": "_coverage_health",
        "signature": "_coverage_health(settings)",
        "doc": null
      },
      {
        "name": "_audit_health",
        "signature": "_audit_health(settings)",
        "doc": null
      },
      {
        "name": "_scheduler_health",
        "signature": "_scheduler_health(app, settings)",
        "doc": null
      }
    ],
    "classes": [],
    "assignments": [
      "__all__"
    ]
  },
  {
    "path": "gateway/api/routes/reporting.py",
    "doc": "Observability and reporting routes.",
    "imports": [
      "__future__",
      "fastapi",
      "fastapi.responses",
      "gateway.api.auth",
      "gateway.api.dependencies",
      "gateway.config.settings",
      "gateway.ingest.audit",
      "gateway.ingest.lifecycle",
      "json",
      "pathlib",
      "slowapi",
      "typing"
    ],
    "functions": [
      {
        "name": "create_router",
        "signature": "create_router(limiter)",
        "doc": "Expose reporting and audit endpoints protected by maintainer auth."
      }
    ],
    "classes": [],
    "assignments": [
      "__all__"
    ]
  },
  {
    "path": "gateway/api/routes/search.py",
    "doc": "Search API routes.",
    "imports": [
      "__future__",
      "collections.abc",
      "datetime",
      "fastapi",
      "fastapi.responses",
      "gateway.api.auth",
      "gateway.api.dependencies",
      "gateway.config.settings",
      "gateway.graph",
      "gateway.observability",
      "gateway.search",
      "gateway.search.feedback",
      "logging",
      "qdrant_client.http.exceptions",
      "slowapi",
      "typing",
      "uuid"
    ],
    "functions": [
      {
        "name": "create_router",
        "signature": "create_router(limiter, metrics_limit)",
        "doc": "Return an API router for the search endpoints with shared rate limits."
      },
      {
        "name": "_parse_iso8601_to_utc",
        "signature": "_parse_iso8601_to_utc(value)",
        "doc": null
      },
      {
        "name": "_has_vote",
        "signature": "_has_vote(mapping)",
        "doc": null
      }
    ],
    "classes": [],
    "assignments": [
      "logger",
      "__all__"
    ]
  },
  {
    "path": "gateway/config/__init__.py",
    "doc": "Configuration helpers for the knowledge gateway.",
    "imports": [
      "__future__",
      "settings"
    ],
    "functions": [],
    "classes": [],
    "assignments": [
      "__all__"
    ]
  },
  {
    "path": "gateway/config/settings.py",
    "doc": "Pydantic-based configuration for the knowledge gateway.",
    "imports": [
      "__future__",
      "functools",
      "pathlib",
      "pydantic",
      "pydantic_settings",
      "typing"
    ],
    "functions": [
      {
        "name": "get_settings",
        "signature": "get_settings()",
        "doc": "Load settings from environment (cached)."
      }
    ],
    "classes": [
      {
        "name": "AppSettings",
        "bases": [
          "BaseSettings"
        ],
        "doc": "Runtime configuration for the knowledge gateway.",
        "methods": [
          {
            "name": "_clamp_tracing_ratio",
            "signature": "_clamp_tracing_ratio(cls, value)",
            "doc": "Ensure the tracing sampling ratio stays within [0, 1]."
          },
          {
            "name": "_clamp_search_weights",
            "signature": "_clamp_search_weights(cls, value)",
            "doc": "Clamp search weights to [0, 1] for stability."
          },
          {
            "name": "_sanitize_hnsw_ef",
            "signature": "_sanitize_hnsw_ef(cls, value)",
            "doc": null
          },
          {
            "name": "_sanitize_graph_cache_ttl",
            "signature": "_sanitize_graph_cache_ttl(cls, value)",
            "doc": null
          },
          {
            "name": "_sanitize_graph_cache_max",
            "signature": "_sanitize_graph_cache_max(cls, value)",
            "doc": null
          },
          {
            "name": "resolved_search_weights",
            "signature": "resolved_search_weights(self)",
            "doc": "Return the active search weight profile name and resolved weights."
          },
          {
            "name": "scheduler_trigger_config",
            "signature": "scheduler_trigger_config(self)",
            "doc": "Return trigger configuration for the ingestion scheduler."
          },
          {
            "name": "_validate_history_limit",
            "signature": "_validate_history_limit(cls, value)",
            "doc": null
          },
          {
            "name": "_validate_lifecycle_stale",
            "signature": "_validate_lifecycle_stale(cls, value)",
            "doc": null
          },
          {
            "name": "_ensure_positive_parallelism",
            "signature": "_ensure_positive_parallelism(cls, value)",
            "doc": null
          }
        ],
        "fields": []
      }
    ],
    "assignments": []
  },
  {
    "path": "gateway/graph/__init__.py",
    "doc": "Graph query utilities and service layer.",
    "imports": [
      "service"
    ],
    "functions": [],
    "classes": [],
    "assignments": [
      "__all__"
    ]
  },
  {
    "path": "gateway/graph/cli.py",
    "doc": "Command-line utilities for managing the Neo4j graph schema.",
    "imports": [
      "__future__",
      "argparse",
      "gateway.config.settings",
      "gateway.graph.migrations",
      "logging",
      "neo4j"
    ],
    "functions": [
      {
        "name": "build_parser",
        "signature": "build_parser()",
        "doc": "Return the CLI argument parser for graph administration commands."
      },
      {
        "name": "run_migrations",
        "signature": "run_migrations()",
        "doc": "Execute graph schema migrations, optionally printing the pending set."
      },
      {
        "name": "main",
        "signature": "main(argv)",
        "doc": "Entrypoint for the `gateway-graph` command-line interface."
      }
    ],
    "classes": [],
    "assignments": [
      "logger"
    ]
  },
  {
    "path": "gateway/graph/migrations/__init__.py",
    "doc": "Graph schema migrations.",
    "imports": [
      "runner"
    ],
    "functions": [],
    "classes": [],
    "assignments": [
      "__all__"
    ]
  },
  {
    "path": "gateway/graph/migrations/runner.py",
    "doc": "Helpers for applying and tracking Neo4j schema migrations.",
    "imports": [
      "__future__",
      "collections.abc",
      "dataclasses",
      "logging",
      "neo4j"
    ],
    "functions": [],
    "classes": [
      {
        "name": "Migration",
        "bases": [],
        "doc": "Describe a single migration and the Cypher statements it executes.",
        "methods": [],
        "fields": []
      },
      {
        "name": "MigrationRunner",
        "bases": [],
        "doc": "Apply ordered graph migrations using a shared Neo4j driver.",
        "methods": [
          {
            "name": "pending_ids",
            "signature": "pending_ids(self)",
            "doc": "Return the identifiers of migrations that have not yet been applied."
          },
          {
            "name": "run",
            "signature": "run(self)",
            "doc": "Apply all pending migrations to the configured Neo4j database."
          },
          {
            "name": "_is_applied",
            "signature": "_is_applied(self, migration_id)",
            "doc": "Return whether the given migration has already been recorded."
          },
          {
            "name": "_apply",
            "signature": "_apply(self, migration)",
            "doc": "Execute migration statements and record completion."
          }
        ],
        "fields": []
      }
    ],
    "assignments": [
      "logger"
    ]
  },
  {
    "path": "gateway/graph/service.py",
    "doc": "Read-only graph service utilities backed by Neo4j.",
    "imports": [
      "__future__",
      "base64",
      "collections",
      "collections.abc",
      "dataclasses",
      "neo4j",
      "neo4j.graph",
      "threading",
      "time",
      "typing"
    ],
    "functions": [
      {
        "name": "get_graph_service",
        "signature": "get_graph_service(driver, database)",
        "doc": "Factory helper that constructs a `GraphService` with optional caching."
      },
      {
        "name": "_extract_path_components",
        "signature": "_extract_path_components(record)",
        "doc": null
      },
      {
        "name": "_record_path_edges",
        "signature": "_record_path_edges(path_nodes, relationships, nodes_by_id, edges_by_key)",
        "doc": null
      },
      {
        "name": "_ensure_serialized_node",
        "signature": "_ensure_serialized_node(node, nodes_by_id)",
        "doc": null
      },
      {
        "name": "_relationship_direction",
        "signature": "_relationship_direction(relationship, source_node)",
        "doc": null
      },
      {
        "name": "_build_related_entry",
        "signature": "_build_related_entry(target_serialized, relationships, path_edges)",
        "doc": null
      },
      {
        "name": "_append_related_entry",
        "signature": "_append_related_entry(entry, target_id, related_entries, related_order)",
        "doc": null
      },
      {
        "name": "_fetch_subsystem_node",
        "signature": "_fetch_subsystem_node(name)",
        "doc": null
      },
      {
        "name": "_fetch_subsystem_paths",
        "signature": "_fetch_subsystem_paths(name, depth)",
        "doc": null
      },
      {
        "name": "_fetch_artifacts_for_subsystem",
        "signature": "_fetch_artifacts_for_subsystem(name)",
        "doc": null
      },
      {
        "name": "_fetch_orphan_nodes",
        "signature": "_fetch_orphan_nodes(label, skip, limit)",
        "doc": null
      },
      {
        "name": "_fetch_node_by_id",
        "signature": "_fetch_node_by_id(label, key, value)",
        "doc": null
      },
      {
        "name": "_fetch_node_relationships",
        "signature": "_fetch_node_relationships(label, key, value, direction, limit)",
        "doc": null
      },
      {
        "name": "_search_entities",
        "signature": "_search_entities(term, limit)",
        "doc": null
      },
      {
        "name": "_serialize_related",
        "signature": "_serialize_related(record, subsystem_node)",
        "doc": null
      },
      {
        "name": "_serialize_node",
        "signature": "_serialize_node(node)",
        "doc": null
      },
      {
        "name": "_serialize_relationship",
        "signature": "_serialize_relationship(record)",
        "doc": null
      },
      {
        "name": "_serialize_value",
        "signature": "_serialize_value(value)",
        "doc": null
      },
      {
        "name": "_ensure_node",
        "signature": "_ensure_node(value)",
        "doc": null
      },
      {
        "name": "_node_element_id",
        "signature": "_node_element_id(node)",
        "doc": null
      },
      {
        "name": "_canonical_node_id",
        "signature": "_canonical_node_id(node)",
        "doc": null
      },
      {
        "name": "_parse_node_id",
        "signature": "_parse_node_id(node_id)",
        "doc": null
      },
      {
        "name": "_encode_cursor",
        "signature": "_encode_cursor(offset)",
        "doc": null
      },
      {
        "name": "_decode_cursor",
        "signature": "_decode_cursor(cursor)",
        "doc": null
      },
      {
        "name": "_validate_cypher",
        "signature": "_validate_cypher(query)",
        "doc": null
      }
    ],
    "classes": [
      {
        "name": "GraphServiceError",
        "bases": [
          "RuntimeError"
        ],
        "doc": "Base class for graph-related errors.",
        "methods": [],
        "fields": []
      },
      {
        "name": "GraphNotFoundError",
        "bases": [
          "GraphServiceError"
        ],
        "doc": "Raised when a requested node cannot be found.",
        "methods": [],
        "fields": []
      },
      {
        "name": "GraphQueryError",
        "bases": [
          "GraphServiceError"
        ],
        "doc": "Raised when a supplied query is invalid or unsafe.",
        "methods": [],
        "fields": []
      },
      {
        "name": "SubsystemGraphSnapshot",
        "bases": [],
        "doc": "Snapshot of a subsystem node and its related graph context.",
        "methods": [],
        "fields": []
      },
      {
        "name": "SubsystemGraphCache",
        "bases": [],
        "doc": "Simple TTL cache for subsystem graph snapshots.",
        "methods": [
          {
            "name": "__init__",
            "signature": "__init__(self, ttl_seconds, max_entries)",
            "doc": "Create a cache with an expiry window and bounded size."
          },
          {
            "name": "get",
            "signature": "get(self, key)",
            "doc": "Return a cached snapshot if it exists and has not expired."
          },
          {
            "name": "set",
            "signature": "set(self, key, snapshot)",
            "doc": "Cache a snapshot for the given key, evicting oldest entries if needed."
          },
          {
            "name": "clear",
            "signature": "clear(self)",
            "doc": "Remove all cached subsystem snapshots."
          }
        ],
        "fields": []
      },
      {
        "name": "GraphService",
        "bases": [],
        "doc": "Service layer for read-only graph queries.",
        "methods": [
          {
            "name": "get_subsystem",
            "signature": "get_subsystem(self, name)",
            "doc": "Return a windowed view of related nodes for the requested subsystem."
          },
          {
            "name": "get_subsystem_graph",
            "signature": "get_subsystem_graph(self, name)",
            "doc": "Return the full node/edge snapshot for a subsystem."
          },
          {
            "name": "list_orphan_nodes",
            "signature": "list_orphan_nodes(self)",
            "doc": "List nodes that have no relationships of the allowed labels."
          },
          {
            "name": "clear_cache",
            "signature": "clear_cache(self)",
            "doc": "Wipe the subsystem snapshot cache if caching is enabled."
          },
          {
            "name": "_load_subsystem_snapshot",
            "signature": "_load_subsystem_snapshot(self, name, depth)",
            "doc": null
          },
          {
            "name": "_build_subsystem_snapshot",
            "signature": "_build_subsystem_snapshot(self, name, depth)",
            "doc": null
          },
          {
            "name": "get_node",
            "signature": "get_node(self, node_id)",
            "doc": "Return a node and a limited set of relationships using Cypher lookups."
          },
          {
            "name": "search",
            "signature": "search(self, term)",
            "doc": "Search the graph for nodes matching the provided term."
          },
          {
            "name": "shortest_path_depth",
            "signature": "shortest_path_depth(self, node_id)",
            "doc": "Return the length of the shortest path from the node to any subsystem.\n\nThe search is bounded by ``max_depth`` hops across the knowledge graph\nrelationship types used by ingestion. ``None`` is returned when no\nsubsystem can be reached within the given depth limit."
          },
          {
            "name": "run_cypher",
            "signature": "run_cypher(self, query, parameters)",
            "doc": "Execute an arbitrary Cypher query and serialize the response."
          }
        ],
        "fields": []
      }
    ],
    "assignments": []
  },
  {
    "path": "gateway/ingest/__init__.py",
    "doc": "Ingestion pipeline components for the knowledge gateway.",
    "imports": [
      "gateway.ingest.pipeline"
    ],
    "functions": [],
    "classes": [],
    "assignments": [
      "__all__"
    ]
  },
  {
    "path": "gateway/ingest/artifacts.py",
    "doc": "Domain models representing artifacts produced during ingestion.",
    "imports": [
      "__future__",
      "dataclasses",
      "pathlib",
      "typing"
    ],
    "functions": [],
    "classes": [
      {
        "name": "Artifact",
        "bases": [],
        "doc": "Represents a repository artifact prior to chunking.",
        "methods": [],
        "fields": []
      },
      {
        "name": "Chunk",
        "bases": [],
        "doc": "Represents a chunk ready for embedding and indexing.",
        "methods": [],
        "fields": []
      },
      {
        "name": "ChunkEmbedding",
        "bases": [],
        "doc": "Chunk plus embedding vector.",
        "methods": [],
        "fields": []
      }
    ],
    "assignments": []
  },
  {
    "path": "gateway/ingest/audit.py",
    "doc": "SQLite-backed audit log utilities for ingestion runs.",
    "imports": [
      "__future__",
      "gateway.ingest.pipeline",
      "pathlib",
      "sqlite3",
      "time",
      "typing"
    ],
    "functions": [],
    "classes": [
      {
        "name": "AuditLogger",
        "bases": [],
        "doc": "Persist and retrieve ingestion run metadata in SQLite.",
        "methods": [
          {
            "name": "__init__",
            "signature": "__init__(self, db_path)",
            "doc": "Initialise the audit database and ensure the schema exists."
          },
          {
            "name": "record",
            "signature": "record(self, result)",
            "doc": "Insert a new ingestion run entry."
          },
          {
            "name": "recent",
            "signature": "recent(self, limit)",
            "doc": "Return the most recent ingestion runs up to ``limit`` entries."
          }
        ],
        "fields": []
      }
    ],
    "assignments": [
      "_SCHEMA",
      "_SELECT_RECENT",
      "_INSERT_RUN"
    ]
  },
  {
    "path": "gateway/ingest/chunking.py",
    "doc": "Chunk source artifacts into overlapping windows for indexing.",
    "imports": [
      "__future__",
      "collections.abc",
      "gateway.ingest.artifacts",
      "hashlib",
      "math",
      "pathlib",
      "typing"
    ],
    "functions": [
      {
        "name": "_derive_namespace",
        "signature": "_derive_namespace(path)",
        "doc": "Infer a namespace from a file path for tagging chunks."
      },
      {
        "name": "_build_tags",
        "signature": "_build_tags(extra_metadata)",
        "doc": "Collect tag-like signals from artifact metadata."
      }
    ],
    "classes": [
      {
        "name": "Chunker",
        "bases": [],
        "doc": "Split artifacts into overlapping textual chunks.",
        "methods": [
          {
            "name": "__init__",
            "signature": "__init__(self, window, overlap)",
            "doc": "Configure chunk sizes and overlap."
          },
          {
            "name": "split",
            "signature": "split(self, artifact)",
            "doc": "Split the artifact content into `Chunk` instances."
          },
          {
            "name": "estimate_chunk_count",
            "signature": "estimate_chunk_count(path, text)",
            "doc": "Estimate how many chunks a text would produce with the configured window."
          }
        ],
        "fields": []
      }
    ],
    "assignments": [
      "DEFAULT_WINDOW",
      "DEFAULT_OVERLAP"
    ]
  },
  {
    "path": "gateway/ingest/cli.py",
    "doc": "Command-line helpers for triggering and inspecting ingestion runs.",
    "imports": [
      "__future__",
      "argparse",
      "collections.abc",
      "datetime",
      "gateway.config.settings",
      "gateway.ingest.audit",
      "gateway.ingest.service",
      "gateway.observability",
      "logging",
      "pathlib",
      "rich.console",
      "rich.table"
    ],
    "functions": [
      {
        "name": "_ensure_maintainer_scope",
        "signature": "_ensure_maintainer_scope(settings)",
        "doc": "Abort execution if maintainer credentials are missing during auth."
      },
      {
        "name": "build_parser",
        "signature": "build_parser()",
        "doc": "Create an argument parser for the ingestion CLI."
      },
      {
        "name": "rebuild",
        "signature": "rebuild()",
        "doc": "Execute a full ingestion pass."
      },
      {
        "name": "audit_history",
        "signature": "audit_history()",
        "doc": "Display recent ingestion runs from the audit ledger."
      },
      {
        "name": "_render_audit_table",
        "signature": "_render_audit_table(entries)",
        "doc": "Render recent audit entries as a Rich table."
      },
      {
        "name": "_format_timestamp",
        "signature": "_format_timestamp(raw)",
        "doc": "Format timestamps from the audit ledger for display."
      },
      {
        "name": "_coerce_int",
        "signature": "_coerce_int(value)",
        "doc": "Attempt to interpret the value as an integer."
      },
      {
        "name": "_coerce_float",
        "signature": "_coerce_float(value)",
        "doc": "Attempt to interpret the value as a floating point number."
      },
      {
        "name": "main",
        "signature": "main(argv)",
        "doc": "Entry point for the CLI."
      }
    ],
    "classes": [],
    "assignments": [
      "logger",
      "console"
    ]
  },
  {
    "path": "gateway/ingest/coverage.py",
    "doc": "Utilities for writing ingestion coverage reports.",
    "imports": [
      "__future__",
      "contextlib",
      "datetime",
      "gateway.ingest.pipeline",
      "gateway.observability.metrics",
      "json",
      "pathlib",
      "time"
    ],
    "functions": [
      {
        "name": "write_coverage_report",
        "signature": "write_coverage_report(result, config)",
        "doc": "Persist coverage metrics derived from an ingestion result."
      },
      {
        "name": "_write_history_snapshot",
        "signature": "_write_history_snapshot(payload, reports_dir, history_limit)",
        "doc": "Write coverage history snapshots and prune old entries."
      }
    ],
    "classes": [],
    "assignments": []
  },
  {
    "path": "gateway/ingest/discovery.py",
    "doc": "Repository discovery helpers for ingestion pipeline.",
    "imports": [
      "__future__",
      "collections.abc",
      "dataclasses",
      "fnmatch",
      "gateway.ingest.artifacts",
      "json",
      "logging",
      "pathlib",
      "re",
      "subprocess",
      "tomli",
      "tomllib",
      "typing"
    ],
    "functions": [
      {
        "name": "discover",
        "signature": "discover(config)",
        "doc": "Yield textual artifacts from the repository."
      },
      {
        "name": "_should_include",
        "signature": "_should_include(path, repo_root, include_patterns)",
        "doc": null
      },
      {
        "name": "_is_textual",
        "signature": "_is_textual(path)",
        "doc": null
      },
      {
        "name": "_infer_artifact_type",
        "signature": "_infer_artifact_type(path, repo_root)",
        "doc": null
      },
      {
        "name": "_lookup_git_metadata",
        "signature": "_lookup_git_metadata(path, repo_root)",
        "doc": null
      },
      {
        "name": "_load_subsystem_catalog",
        "signature": "_load_subsystem_catalog(repo_root)",
        "doc": null
      },
      {
        "name": "_detect_source_prefixes",
        "signature": "_detect_source_prefixes(repo_root)",
        "doc": "Infer source package prefixes (e.g. ``(\"src\", \"gateway\")``)."
      },
      {
        "name": "_collect_pyproject_prefixes",
        "signature": "_collect_pyproject_prefixes(root, prefixes)",
        "doc": null
      },
      {
        "name": "_load_pyproject",
        "signature": "_load_pyproject(path)",
        "doc": null
      },
      {
        "name": "_collect_poetry_prefixes",
        "signature": "_collect_poetry_prefixes(tool_cfg, prefixes)",
        "doc": null
      },
      {
        "name": "_collect_project_prefixes",
        "signature": "_collect_project_prefixes(project_cfg, prefixes)",
        "doc": null
      },
      {
        "name": "_collect_setuptools_prefixes",
        "signature": "_collect_setuptools_prefixes(tool_cfg, prefixes)",
        "doc": null
      },
      {
        "name": "_collect_src_directory_prefixes",
        "signature": "_collect_src_directory_prefixes(root, prefixes)",
        "doc": null
      },
      {
        "name": "_add_prefix",
        "signature": "_add_prefix(prefixes, include, base)",
        "doc": null
      },
      {
        "name": "_ensure_str_list",
        "signature": "_ensure_str_list(value)",
        "doc": null
      },
      {
        "name": "_infer_subsystem",
        "signature": "_infer_subsystem(path, repo_root, source_prefixes)",
        "doc": null
      },
      {
        "name": "_normalize_subsystem_name",
        "signature": "_normalize_subsystem_name(value)",
        "doc": null
      },
      {
        "name": "_match_catalog_entry",
        "signature": "_match_catalog_entry(path, repo_root, catalog)",
        "doc": null
      },
      {
        "name": "_iter_metadata_patterns",
        "signature": "_iter_metadata_patterns(metadata)",
        "doc": null
      },
      {
        "name": "_pattern_matches",
        "signature": "_pattern_matches(target, pattern)",
        "doc": null
      },
      {
        "name": "dump_artifacts",
        "signature": "dump_artifacts(artifacts)",
        "doc": "Serialize artifacts for debugging or dry-run output."
      }
    ],
    "classes": [
      {
        "name": "DiscoveryConfig",
        "bases": [],
        "doc": "Runtime knobs influencing which artifacts are discovered.",
        "methods": [],
        "fields": []
      }
    ],
    "assignments": [
      "logger",
      "_TEXTUAL_SUFFIXES",
      "_MESSAGE_PATTERN",
      "_TELEMETRY_PATTERN"
    ]
  },
  {
    "path": "gateway/ingest/embedding.py",
    "doc": "Embedding helpers used during ingestion.",
    "imports": [
      "__future__",
      "collections.abc",
      "functools",
      "logging",
      "sentence_transformers"
    ],
    "functions": [],
    "classes": [
      {
        "name": "Embedder",
        "bases": [],
        "doc": "Wrapper around sentence-transformers for configurable embeddings.",
        "methods": [
          {
            "name": "__init__",
            "signature": "__init__(self, model_name)",
            "doc": "Load the requested sentence-transformer model."
          },
          {
            "name": "dimension",
            "signature": "dimension(self)",
            "doc": "Return the embedding dimensionality for the underlying model."
          },
          {
            "name": "encode",
            "signature": "encode(self, texts)",
            "doc": "Embed an iterable of texts using the configured transformer."
          },
          {
            "name": "_load_model",
            "signature": "_load_model(model_name)",
            "doc": "Load and cache the requested sentence transformer model."
          }
        ],
        "fields": []
      },
      {
        "name": "DummyEmbedder",
        "bases": [
          "Embedder"
        ],
        "doc": "Deterministic embedder for dry-runs and tests.",
        "methods": [
          {
            "name": "__init__",
            "signature": "__init__(self)",
            "doc": "Initialise the deterministic embedder for testing."
          },
          {
            "name": "dimension",
            "signature": "dimension(self)",
            "doc": "Return the fixed dimension used by the dummy embedder."
          },
          {
            "name": "encode",
            "signature": "encode(self, texts)",
            "doc": "Produce deterministic vectors for the provided texts."
          }
        ],
        "fields": []
      }
    ],
    "assignments": [
      "logger"
    ]
  },
  {
    "path": "gateway/ingest/lifecycle.py",
    "doc": "Lifecycle reporting helpers for ingestion outputs.",
    "imports": [
      "__future__",
      "collections",
      "collections.abc",
      "contextlib",
      "dataclasses",
      "datetime",
      "gateway.graph",
      "gateway.ingest.pipeline",
      "gateway.observability.metrics",
      "json",
      "neo4j",
      "pathlib",
      "time",
      "typing"
    ],
    "functions": [
      {
        "name": "write_lifecycle_report",
        "signature": "write_lifecycle_report(result)",
        "doc": "Persist lifecycle insights derived from the most recent ingest run."
      },
      {
        "name": "build_graph_service",
        "signature": "build_graph_service()",
        "doc": "Construct a graph service with sensible defaults for lifecycle usage."
      },
      {
        "name": "summarize_lifecycle",
        "signature": "summarize_lifecycle(payload)",
        "doc": "Produce a summarized view of lifecycle data for reporting."
      },
      {
        "name": "_fetch_isolated_nodes",
        "signature": "_fetch_isolated_nodes(graph_service)",
        "doc": "Collect isolated graph nodes grouped by label."
      },
      {
        "name": "_find_stale_docs",
        "signature": "_find_stale_docs(artifacts, stale_days, now)",
        "doc": "Identify design documents that are older than the stale threshold."
      },
      {
        "name": "_find_missing_tests",
        "signature": "_find_missing_tests(artifacts)",
        "doc": "Determine subsystems lacking corresponding tests."
      },
      {
        "name": "_write_history_snapshot",
        "signature": "_write_history_snapshot(payload, reports_dir, history_limit)",
        "doc": "Write lifecycle history to disk while enforcing retention."
      },
      {
        "name": "_coerce_float",
        "signature": "_coerce_float(value)",
        "doc": "Coerce numeric-like values to float when possible."
      },
      {
        "name": "_lifecycle_counts",
        "signature": "_lifecycle_counts()",
        "doc": "Aggregate lifecycle metrics into counters."
      }
    ],
    "classes": [
      {
        "name": "LifecycleConfig",
        "bases": [],
        "doc": "Configuration values that influence lifecycle report generation.",
        "methods": [],
        "fields": []
      }
    ],
    "assignments": [
      "SECONDS_PER_DAY"
    ]
  },
  {
    "path": "gateway/ingest/neo4j_writer.py",
    "doc": "Write ingestion artifacts and chunks into Neo4j.",
    "imports": [
      "__future__",
      "collections.abc",
      "gateway.ingest.artifacts",
      "logging",
      "neo4j"
    ],
    "functions": [
      {
        "name": "_artifact_label",
        "signature": "_artifact_label(artifact)",
        "doc": "Map artifact types to Neo4j labels."
      },
      {
        "name": "_label_for_type",
        "signature": "_label_for_type(artifact_type)",
        "doc": "Return the default label for the given artifact type."
      },
      {
        "name": "_relationship_for_label",
        "signature": "_relationship_for_label(label)",
        "doc": "Return the relationship used to link artifacts to subsystems."
      },
      {
        "name": "_clean_string_list",
        "signature": "_clean_string_list(values)",
        "doc": null
      },
      {
        "name": "_normalize_subsystem_name",
        "signature": "_normalize_subsystem_name(value)",
        "doc": null
      },
      {
        "name": "_extract_dependencies",
        "signature": "_extract_dependencies(metadata)",
        "doc": null
      },
      {
        "name": "_subsystem_properties",
        "signature": "_subsystem_properties(metadata)",
        "doc": null
      }
    ],
    "classes": [
      {
        "name": "Neo4jWriter",
        "bases": [],
        "doc": "Persist artifacts and derived data into a Neo4j database.",
        "methods": [
          {
            "name": "__init__",
            "signature": "__init__(self, driver, database)",
            "doc": "Initialise the writer with a driver and target database."
          },
          {
            "name": "ensure_constraints",
            "signature": "ensure_constraints(self)",
            "doc": "Create required uniqueness constraints if they do not exist."
          },
          {
            "name": "sync_artifact",
            "signature": "sync_artifact(self, artifact)",
            "doc": "Upsert the artifact node and related subsystem relationships."
          },
          {
            "name": "sync_chunks",
            "signature": "sync_chunks(self, chunk_embeddings)",
            "doc": "Upsert chunk nodes and connect them to their owning artifacts."
          },
          {
            "name": "delete_artifact",
            "signature": "delete_artifact(self, path)",
            "doc": "Remove an artifact node and its chunks."
          }
        ],
        "fields": []
      }
    ],
    "assignments": [
      "logger"
    ]
  },
  {
    "path": "gateway/ingest/pipeline.py",
    "doc": "Pipeline orchestrations for ingestion, chunking, and persistence.",
    "imports": [
      "__future__",
      "collections",
      "collections.abc",
      "concurrent.futures",
      "dataclasses",
      "gateway.ingest.artifacts",
      "gateway.ingest.chunking",
      "gateway.ingest.discovery",
      "gateway.ingest.embedding",
      "gateway.ingest.neo4j_writer",
      "gateway.ingest.qdrant_writer",
      "gateway.observability.metrics",
      "hashlib",
      "json",
      "logging",
      "opentelemetry",
      "opentelemetry.trace",
      "pathlib",
      "subprocess",
      "time",
      "uuid"
    ],
    "functions": [
      {
        "name": "_current_repo_head",
        "signature": "_current_repo_head(repo_root)",
        "doc": null
      },
      {
        "name": "_coerce_int",
        "signature": "_coerce_int(value)",
        "doc": null
      },
      {
        "name": "_coerce_float",
        "signature": "_coerce_float(value)",
        "doc": null
      }
    ],
    "classes": [
      {
        "name": "IngestionConfig",
        "bases": [],
        "doc": "Configuration options controlling ingestion behaviour.",
        "methods": [],
        "fields": []
      },
      {
        "name": "IngestionResult",
        "bases": [],
        "doc": "Summary of outputs emitted by an ingestion run.",
        "methods": [],
        "fields": []
      },
      {
        "name": "IngestionPipeline",
        "bases": [],
        "doc": "Execute the ingestion workflow end-to-end.",
        "methods": [
          {
            "name": "__init__",
            "signature": "__init__(self, qdrant_writer, neo4j_writer, config)",
            "doc": "Initialise the pipeline with writer backends and configuration."
          },
          {
            "name": "run",
            "signature": "run(self)",
            "doc": "Execute discovery, chunking, embedding, and persistence for a repo."
          },
          {
            "name": "_build_embedder",
            "signature": "_build_embedder(self)",
            "doc": null
          },
          {
            "name": "_encode_batch",
            "signature": "_encode_batch(self, embedder, chunks)",
            "doc": null
          },
          {
            "name": "_build_embeddings",
            "signature": "_build_embeddings(self, chunks, vectors)",
            "doc": null
          },
          {
            "name": "_persist_embeddings",
            "signature": "_persist_embeddings(self, embeddings)",
            "doc": null
          },
          {
            "name": "_handle_stale_artifacts",
            "signature": "_handle_stale_artifacts(self, previous, current, profile)",
            "doc": null
          },
          {
            "name": "_delete_artifact_from_backends",
            "signature": "_delete_artifact_from_backends(self, path)",
            "doc": null
          },
          {
            "name": "_load_artifact_ledger",
            "signature": "_load_artifact_ledger(self)",
            "doc": null
          },
          {
            "name": "_write_artifact_ledger",
            "signature": "_write_artifact_ledger(self, entries)",
            "doc": null
          }
        ],
        "fields": []
      }
    ],
    "assignments": [
      "logger"
    ]
  },
  {
    "path": "gateway/ingest/qdrant_writer.py",
    "doc": "Helpers for writing chunk embeddings into Qdrant collections.",
    "imports": [
      "__future__",
      "collections.abc",
      "gateway.ingest.artifacts",
      "logging",
      "qdrant_client",
      "qdrant_client.http",
      "qdrant_client.http.exceptions",
      "uuid"
    ],
    "functions": [],
    "classes": [
      {
        "name": "QdrantWriter",
        "bases": [],
        "doc": "Lightweight adapter around the Qdrant client.",
        "methods": [
          {
            "name": "__init__",
            "signature": "__init__(self, client, collection_name)",
            "doc": "Initialise the writer with a target collection."
          },
          {
            "name": "ensure_collection",
            "signature": "ensure_collection(self, vector_size)",
            "doc": "Ensure the collection exists with the desired vector dimensionality."
          },
          {
            "name": "upsert_chunks",
            "signature": "upsert_chunks(self, chunks)",
            "doc": "Upsert chunk embeddings into the configured collection."
          },
          {
            "name": "delete_artifact",
            "signature": "delete_artifact(self, artifact_path)",
            "doc": "Delete all points belonging to an artifact path."
          }
        ],
        "fields": []
      }
    ],
    "assignments": [
      "logger"
    ]
  },
  {
    "path": "gateway/ingest/service.py",
    "doc": "High-level orchestration routines for running ingestion.",
    "imports": [
      "__future__",
      "gateway.config.settings",
      "gateway.ingest.audit",
      "gateway.ingest.coverage",
      "gateway.ingest.lifecycle",
      "gateway.ingest.neo4j_writer",
      "gateway.ingest.pipeline",
      "gateway.ingest.qdrant_writer",
      "logging",
      "neo4j",
      "pathlib",
      "qdrant_client"
    ],
    "functions": [
      {
        "name": "execute_ingestion",
        "signature": "execute_ingestion()",
        "doc": "Run ingestion using shared settings and return result."
      }
    ],
    "classes": [],
    "assignments": [
      "logger"
    ]
  },
  {
    "path": "gateway/lifecycle/__init__.py",
    "doc": "Lifecycle reporting package.",
    "imports": [],
    "functions": [],
    "classes": [],
    "assignments": [
      "__all__"
    ]
  },
  {
    "path": "gateway/lifecycle/cli.py",
    "doc": "Command-line utilities for inspecting lifecycle health reports.",
    "imports": [
      "__future__",
      "argparse",
      "collections.abc",
      "datetime",
      "gateway.config.settings",
      "gateway.observability",
      "json",
      "pathlib",
      "rich.console",
      "rich.table"
    ],
    "functions": [
      {
        "name": "build_parser",
        "signature": "build_parser()",
        "doc": "Create the CLI argument parser shared across entrypoints."
      },
      {
        "name": "render_table",
        "signature": "render_table(payload)",
        "doc": "Pretty-print the lifecycle report payload using Rich tables."
      },
      {
        "name": "_render_isolated_nodes",
        "signature": "_render_isolated_nodes(value)",
        "doc": "Render the isolated node section when data is present."
      },
      {
        "name": "_render_stale_docs",
        "signature": "_render_stale_docs(value)",
        "doc": "Render the stale documentation summary rows."
      },
      {
        "name": "_render_missing_tests",
        "signature": "_render_missing_tests(value)",
        "doc": "Render subsystems missing tests in a tabular format."
      },
      {
        "name": "_format_timestamp",
        "signature": "_format_timestamp(value)",
        "doc": "Convert a timestamp-like input into an ISO formatted string."
      },
      {
        "name": "main",
        "signature": "main(argv)",
        "doc": "CLI entry point for lifecycle reporting."
      }
    ],
    "classes": [],
    "assignments": [
      "console"
    ]
  },
  {
    "path": "gateway/mcp/__init__.py",
    "doc": "Model Context Protocol server integration for the knowledge gateway.",
    "imports": [
      "config",
      "server"
    ],
    "functions": [],
    "classes": [],
    "assignments": [
      "__all__"
    ]
  },
  {
    "path": "gateway/mcp/backup.py",
    "doc": "Backup helpers for the MCP server.",
    "imports": [
      "__future__",
      "asyncio",
      "config",
      "exceptions",
      "os",
      "pathlib",
      "re",
      "typing"
    ],
    "functions": [
      {
        "name": "_parse_archive_path",
        "signature": "_parse_archive_path(output)",
        "doc": null
      },
      {
        "name": "_default_backup_script",
        "signature": "_default_backup_script()",
        "doc": null
      }
    ],
    "classes": [],
    "assignments": [
      "_BACKUP_DONE_PATTERN",
      "__all__"
    ]
  },
  {
    "path": "gateway/mcp/cli.py",
    "doc": "Command-line entry point for the MCP server.",
    "imports": [
      "__future__",
      "argparse",
      "collections.abc",
      "config",
      "gateway",
      "logging",
      "server",
      "sys"
    ],
    "functions": [
      {
        "name": "build_parser",
        "signature": "build_parser()",
        "doc": "Return the CLI parser for launching the MCP server."
      },
      {
        "name": "main",
        "signature": "main(argv)",
        "doc": "Entry point for the MCP server management CLI."
      }
    ],
    "classes": [],
    "assignments": [
      "_TRANSPORT_CHOICES"
    ]
  },
  {
    "path": "gateway/mcp/client.py",
    "doc": "HTTP client for interacting with the gateway API.",
    "imports": [
      "__future__",
      "collections.abc",
      "config",
      "exceptions",
      "httpx",
      "json",
      "logging",
      "types",
      "typing",
      "urllib.parse"
    ],
    "functions": [
      {
        "name": "_extract_error_detail",
        "signature": "_extract_error_detail(response)",
        "doc": "Extract a human-readable error detail from an HTTP response."
      },
      {
        "name": "_safe_json",
        "signature": "_safe_json(response)",
        "doc": "Safely decode a JSON response, returning ``None`` on failure."
      },
      {
        "name": "_quote_segment",
        "signature": "_quote_segment(value)",
        "doc": null
      },
      {
        "name": "_expect_dict",
        "signature": "_expect_dict(data, operation)",
        "doc": null
      }
    ],
    "classes": [
      {
        "name": "GatewayClient",
        "bases": [],
        "doc": "Thin async wrapper over the gateway REST API.",
        "methods": [
          {
            "name": "__init__",
            "signature": "__init__(self, settings)",
            "doc": null
          },
          {
            "name": "settings",
            "signature": "settings(self)",
            "doc": "Return the settings used to configure the client."
          }
        ],
        "fields": []
      }
    ],
    "assignments": [
      "logger",
      "_ParamValue",
      "__all__"
    ]
  },
  {
    "path": "gateway/mcp/config.py",
    "doc": "Configuration for the MCP adapter.",
    "imports": [
      "__future__",
      "pathlib",
      "pydantic",
      "pydantic_settings",
      "typing"
    ],
    "functions": [],
    "classes": [
      {
        "name": "MCPSettings",
        "bases": [
          "BaseSettings"
        ],
        "doc": "Settings controlling the MCP server runtime.",
        "methods": [],
        "fields": []
      }
    ],
    "assignments": [
      "__all__"
    ]
  },
  {
    "path": "gateway/mcp/exceptions.py",
    "doc": "Custom exceptions for the MCP adapter.",
    "imports": [
      "__future__"
    ],
    "functions": [],
    "classes": [
      {
        "name": "MCPAdapterError",
        "bases": [
          "Exception"
        ],
        "doc": "Base error raised by the MCP bridge.",
        "methods": [],
        "fields": []
      },
      {
        "name": "GatewayRequestError",
        "bases": [
          "MCPAdapterError"
        ],
        "doc": "Raised when the gateway API returns an error response.",
        "methods": [
          {
            "name": "__init__",
            "signature": "__init__(self)",
            "doc": null
          }
        ],
        "fields": []
      },
      {
        "name": "MissingTokenError",
        "bases": [
          "MCPAdapterError"
        ],
        "doc": "Raised when a privileged operation lacks an authentication token.",
        "methods": [
          {
            "name": "__init__",
            "signature": "__init__(self, scope)",
            "doc": null
          }
        ],
        "fields": []
      },
      {
        "name": "BackupExecutionError",
        "bases": [
          "MCPAdapterError"
        ],
        "doc": "Raised when the backup helper fails to produce an archive.",
        "methods": [],
        "fields": []
      }
    ],
    "assignments": [
      "__all__"
    ]
  },
  {
    "path": "gateway/mcp/feedback.py",
    "doc": "Feedback logging utilities used by MCP tools.",
    "imports": [
      "__future__",
      "asyncio",
      "collections.abc",
      "config",
      "datetime",
      "json",
      "pathlib",
      "typing"
    ],
    "functions": [
      {
        "name": "_append_line",
        "signature": "_append_line(path, line)",
        "doc": null
      }
    ],
    "classes": [],
    "assignments": [
      "__all__"
    ]
  },
  {
    "path": "gateway/mcp/ingest.py",
    "doc": "Helpers for managing ingestion workflows via MCP.",
    "imports": [
      "__future__",
      "asyncio",
      "config",
      "dataclasses",
      "gateway.config.settings",
      "gateway.ingest.service",
      "typing"
    ],
    "functions": [],
    "classes": [],
    "assignments": [
      "__all__"
    ]
  },
  {
    "path": "gateway/mcp/server.py",
    "doc": "FastMCP server exposing the knowledge gateway.",
    "imports": [
      "__future__",
      "backup",
      "client",
      "collections.abc",
      "config",
      "contextlib",
      "datetime",
      "exceptions",
      "fastmcp",
      "feedback",
      "functools",
      "gateway",
      "gateway.observability.metrics",
      "ingest",
      "json",
      "pathlib",
      "storetext",
      "textwrap",
      "time",
      "typing",
      "upload"
    ],
    "functions": [
      {
        "name": "build_server",
        "signature": "build_server(settings)",
        "doc": "Create a FastMCP server wired to the gateway API."
      },
      {
        "name": "_record_success",
        "signature": "_record_success(tool, start)",
        "doc": null
      },
      {
        "name": "_record_failure",
        "signature": "_record_failure(tool, exc, start)",
        "doc": null
      },
      {
        "name": "_clamp",
        "signature": "_clamp(value)",
        "doc": null
      },
      {
        "name": "_normalise_filters",
        "signature": "_normalise_filters(payload)",
        "doc": null
      },
      {
        "name": "_resolve_usage",
        "signature": "_resolve_usage(tool)",
        "doc": null
      },
      {
        "name": "_ensure_maintainer_scope",
        "signature": "_ensure_maintainer_scope(settings)",
        "doc": null
      },
      {
        "name": "_append_audit_entry",
        "signature": "_append_audit_entry(settings)",
        "doc": null
      },
      {
        "name": "_load_help_document",
        "signature": "_load_help_document()",
        "doc": null
      },
      {
        "name": "_initialise_metric_labels",
        "signature": "_initialise_metric_labels()",
        "doc": null
      }
    ],
    "classes": [
      {
        "name": "MCPServerState",
        "bases": [],
        "doc": "Holds shared state for the MCP server lifespan.",
        "methods": [
          {
            "name": "__init__",
            "signature": "__init__(self, settings)",
            "doc": null
          },
          {
            "name": "require_client",
            "signature": "require_client(self)",
            "doc": null
          },
          {
            "name": "lifespan",
            "signature": "lifespan(self)",
            "doc": null
          }
        ],
        "fields": []
      }
    ],
    "assignments": [
      "TOOL_USAGE",
      "HELP_DOC_PATH",
      "LifespanCallable",
      "__all__"
    ]
  },
  {
    "path": "gateway/mcp/storetext.py",
    "doc": "Handlers for storing text via MCP.",
    "imports": [
      "__future__",
      "datetime",
      "gateway.mcp.config",
      "gateway.mcp.utils.files",
      "ingest",
      "pathlib",
      "typing"
    ],
    "functions": [
      {
        "name": "_build_filename",
        "signature": "_build_filename(title)",
        "doc": null
      },
      {
        "name": "_normalise_destination",
        "signature": "_normalise_destination(destination, default_dir, filename)",
        "doc": null
      },
      {
        "name": "_compose_content",
        "signature": "_compose_content()",
        "doc": null
      }
    ],
    "classes": [],
    "assignments": [
      "__all__"
    ]
  },
  {
    "path": "gateway/mcp/upload.py",
    "doc": "Handlers for MCP file uploads.",
    "imports": [
      "__future__",
      "gateway.mcp.config",
      "gateway.mcp.utils.files",
      "ingest",
      "pathlib",
      "typing"
    ],
    "functions": [
      {
        "name": "_resolve_destination",
        "signature": "_resolve_destination(destination, default_dir, filename)",
        "doc": null
      }
    ],
    "classes": [],
    "assignments": [
      "__all__"
    ]
  },
  {
    "path": "gateway/mcp/utils/__init__.py",
    "doc": null,
    "imports": [],
    "functions": [],
    "classes": [],
    "assignments": []
  },
  {
    "path": "gateway/mcp/utils/files.py",
    "doc": "Shared helpers for MCP content management.",
    "imports": [
      "__future__",
      "collections.abc",
      "dataclasses",
      "os",
      "pathlib",
      "re",
      "shutil",
      "unicodedata"
    ],
    "functions": [
      {
        "name": "slugify",
        "signature": "slugify(value)",
        "doc": "Create a filesystem-friendly slug."
      },
      {
        "name": "is_supported_document",
        "signature": "is_supported_document(path)",
        "doc": "Return ``True`` if the path has a supported document extension."
      },
      {
        "name": "_assert_within_root",
        "signature": "_assert_within_root(root, candidate)",
        "doc": "Ensure ``candidate`` is within ``root`` to prevent path traversal."
      },
      {
        "name": "sweep_documents",
        "signature": "sweep_documents(root, target)",
        "doc": "Copy supported documents under ``root`` into ``target``."
      },
      {
        "name": "copy_into_root",
        "signature": "copy_into_root(source, root, destination)",
        "doc": "Copy ``source`` into ``root``."
      },
      {
        "name": "write_text_document",
        "signature": "write_text_document(content, root, relative_path)",
        "doc": "Write ``content`` to ``root / relative_path`` ensuring safety."
      }
    ],
    "classes": [
      {
        "name": "DocumentCopyResult",
        "bases": [],
        "doc": "Result of an attempted document copy.",
        "methods": [],
        "fields": []
      },
      {
        "name": "DocumentCopyError",
        "bases": [
          "Exception"
        ],
        "doc": "Raised when a copy operation fails fatally.",
        "methods": [],
        "fields": []
      }
    ],
    "assignments": [
      "SUPPORTED_EXTENSIONS",
      "_SLUG_REGEX"
    ]
  },
  {
    "path": "gateway/observability/__init__.py",
    "doc": "Observability utilities (metrics, logging, tracing).",
    "imports": [
      "logging",
      "metrics",
      "tracing"
    ],
    "functions": [],
    "classes": [],
    "assignments": [
      "__all__"
    ]
  },
  {
    "path": "gateway/observability/logging.py",
    "doc": "Structured logging configuration for the gateway.",
    "imports": [
      "__future__",
      "logging",
      "pythonjsonlogger",
      "sys",
      "typing"
    ],
    "functions": [
      {
        "name": "configure_logging",
        "signature": "configure_logging()",
        "doc": "Configure root logging with a JSON formatter once per process."
      }
    ],
    "classes": [
      {
        "name": "IngestAwareFormatter",
        "bases": [
          "json.JsonFormatter"
        ],
        "doc": "JSON formatter that enforces consistent keys.",
        "methods": [
          {
            "name": "add_fields",
            "signature": "add_fields(self, log_record, record, message_dict)",
            "doc": null
          }
        ],
        "fields": []
      }
    ],
    "assignments": [
      "_LOG_CONFIGURED"
    ]
  },
  {
    "path": "gateway/observability/metrics.py",
    "doc": "Prometheus metric definitions for the knowledge gateway.",
    "imports": [
      "__future__",
      "prometheus_client"
    ],
    "functions": [],
    "classes": [],
    "assignments": [
      "INGEST_DURATION_SECONDS",
      "INGEST_ARTIFACTS_TOTAL",
      "INGEST_CHUNKS_TOTAL",
      "INGEST_LAST_RUN_STATUS",
      "INGEST_LAST_RUN_TIMESTAMP",
      "COVERAGE_LAST_RUN_STATUS",
      "COVERAGE_LAST_RUN_TIMESTAMP",
      "COVERAGE_MISSING_ARTIFACTS",
      "COVERAGE_STALE_ARTIFACTS",
      "INGEST_STALE_RESOLVED_TOTAL",
      "INGEST_SKIPS_TOTAL",
      "SEARCH_REQUESTS_TOTAL",
      "SEARCH_GRAPH_CACHE_EVENTS",
      "SEARCH_GRAPH_LOOKUP_SECONDS",
      "SEARCH_SCORE_DELTA",
      "GRAPH_MIGRATION_LAST_STATUS",
      "GRAPH_MIGRATION_LAST_TIMESTAMP",
      "SCHEDULER_RUNS_TOTAL",
      "SCHEDULER_LAST_SUCCESS_TIMESTAMP",
      "COVERAGE_HISTORY_SNAPSHOTS",
      "WATCH_RUNS_TOTAL",
      "LIFECYCLE_LAST_RUN_STATUS",
      "LIFECYCLE_LAST_RUN_TIMESTAMP",
      "LIFECYCLE_STALE_DOCS_TOTAL",
      "LIFECYCLE_ISOLATED_NODES_TOTAL",
      "LIFECYCLE_MISSING_TEST_SUBSYSTEMS_TOTAL",
      "LIFECYCLE_REMOVED_ARTIFACTS_TOTAL",
      "LIFECYCLE_HISTORY_SNAPSHOTS",
      "MCP_REQUESTS_TOTAL",
      "MCP_REQUEST_SECONDS",
      "MCP_FAILURES_TOTAL",
      "MCP_UPLOAD_TOTAL",
      "MCP_STORETEXT_TOTAL",
      "UI_REQUESTS_TOTAL",
      "UI_EVENTS_TOTAL"
    ]
  },
  {
    "path": "gateway/observability/tracing.py",
    "doc": "Tracing helpers for wiring OpenTelemetry exporters.",
    "imports": [
      "__future__",
      "fastapi",
      "gateway.config.settings",
      "opentelemetry",
      "opentelemetry.exporter.otlp.proto.http.trace_exporter",
      "opentelemetry.instrumentation.fastapi",
      "opentelemetry.instrumentation.requests",
      "opentelemetry.sdk.resources",
      "opentelemetry.sdk.trace",
      "opentelemetry.sdk.trace.export",
      "opentelemetry.sdk.trace.sampling"
    ],
    "functions": [
      {
        "name": "configure_tracing",
        "signature": "configure_tracing(app, settings)",
        "doc": "Configure OpenTelemetry tracing based on runtime settings."
      },
      {
        "name": "_select_exporter",
        "signature": "_select_exporter(settings)",
        "doc": "Choose the span exporter based on settings."
      },
      {
        "name": "_parse_headers",
        "signature": "_parse_headers(header_string)",
        "doc": "Parse comma-separated OTLP header strings into a dict."
      },
      {
        "name": "reset_tracing_for_tests",
        "signature": "reset_tracing_for_tests()",
        "doc": "Reset module-level state so tests can reconfigure tracing cleanly."
      }
    ],
    "classes": [],
    "assignments": [
      "_TRACING_CONFIGURED"
    ]
  },
  {
    "path": "gateway/plugins/__init__.py",
    "doc": "Plugin namespace for future ingestion extensions.",
    "imports": [],
    "functions": [],
    "classes": [],
    "assignments": []
  },
  {
    "path": "gateway/recipes/__init__.py",
    "doc": "Utilities for running knowledge recipes.",
    "imports": [
      "executor",
      "models"
    ],
    "functions": [],
    "classes": [],
    "assignments": [
      "__all__"
    ]
  },
  {
    "path": "gateway/recipes/cli.py",
    "doc": "Command-line utilities for inspecting and running MCP recipes.",
    "imports": [
      "__future__",
      "argparse",
      "asyncio",
      "collections.abc",
      "executor",
      "gateway.mcp.config",
      "json",
      "logging",
      "models",
      "pathlib",
      "pydantic",
      "rich.console",
      "rich.table",
      "typing"
    ],
    "functions": [
      {
        "name": "build_parser",
        "signature": "build_parser()",
        "doc": "Construct the top-level argument parser for the CLI."
      },
      {
        "name": "load_recipe_by_name",
        "signature": "load_recipe_by_name(recipes_dir, name)",
        "doc": "Load a recipe by stem name from the given directory."
      },
      {
        "name": "parse_variables",
        "signature": "parse_variables(pairs)",
        "doc": "Parse ``key=value`` overrides supplied on the command line."
      },
      {
        "name": "command_list",
        "signature": "command_list(args)",
        "doc": "List recipes available in the configured directory."
      },
      {
        "name": "command_show",
        "signature": "command_show(args)",
        "doc": "Print a single recipe definition in JSON form."
      },
      {
        "name": "command_validate",
        "signature": "command_validate(args)",
        "doc": "Validate one or all recipes and report the outcome."
      },
      {
        "name": "recipe_executor_factory",
        "signature": "recipe_executor_factory(settings)",
        "doc": "Create a factory that instantiates a gateway-backed tool executor."
      },
      {
        "name": "command_run",
        "signature": "command_run(args, settings)",
        "doc": "Execute a recipe and render the results."
      },
      {
        "name": "_render_run_result",
        "signature": "_render_run_result(result)",
        "doc": "Pretty-print a recipe execution result in tabular form."
      },
      {
        "name": "main",
        "signature": "main(argv)",
        "doc": "Entry point for the recipes CLI."
      }
    ],
    "classes": [],
    "assignments": [
      "logger",
      "console",
      "DEFAULT_RECIPES_DIR"
    ]
  },
  {
    "path": "gateway/recipes/executor.py",
    "doc": "Recipe execution layer for automating MCP-driven workflows.",
    "imports": [
      "__future__",
      "asyncio",
      "collections.abc",
      "contextlib",
      "dataclasses",
      "gateway.mcp.backup",
      "gateway.mcp.client",
      "gateway.mcp.config",
      "gateway.mcp.exceptions",
      "gateway.mcp.ingest",
      "json",
      "logging",
      "models",
      "pathlib",
      "re",
      "time",
      "types",
      "yaml"
    ],
    "functions": [
      {
        "name": "_resolve_template",
        "signature": "_resolve_template(value, context)",
        "doc": null
      },
      {
        "name": "_lookup_expression",
        "signature": "_lookup_expression(expr, context)",
        "doc": null
      },
      {
        "name": "_descend",
        "signature": "_descend(current, part)",
        "doc": null
      },
      {
        "name": "_evaluate_condition",
        "signature": "_evaluate_condition(result, condition)",
        "doc": null
      },
      {
        "name": "_compute_capture",
        "signature": "_compute_capture(result, capture)",
        "doc": null
      },
      {
        "name": "load_recipe",
        "signature": "load_recipe(path)",
        "doc": "Load a recipe file from disk and validate the schema."
      },
      {
        "name": "_ensure_object_map",
        "signature": "_ensure_object_map(value, label)",
        "doc": "Ensure template resolution returned a mapping, raising otherwise."
      },
      {
        "name": "_require_str",
        "signature": "_require_str(params, key)",
        "doc": "Fetch a required string parameter from a mapping of arguments."
      },
      {
        "name": "_coerce_optional_str",
        "signature": "_coerce_optional_str(value)",
        "doc": "Convert optional string-like values to trimmed strings."
      },
      {
        "name": "_coerce_positive_int",
        "signature": "_coerce_positive_int(value)",
        "doc": "Convert inputs to a positive integer, falling back to the default."
      },
      {
        "name": "_coerce_int",
        "signature": "_coerce_int(value)",
        "doc": "Coerce common primitive values to an integer when possible."
      },
      {
        "name": "_coerce_bool",
        "signature": "_coerce_bool(value)",
        "doc": "Interpret truthy/falsey string values and return a boolean."
      },
      {
        "name": "list_recipes",
        "signature": "list_recipes(recipes_dir)",
        "doc": "Return all recipe definition files within the directory."
      }
    ],
    "classes": [
      {
        "name": "RecipeExecutionError",
        "bases": [
          "RuntimeError"
        ],
        "doc": "Raised when a recipe step fails.",
        "methods": [],
        "fields": []
      },
      {
        "name": "StepResult",
        "bases": [],
        "doc": "Lightweight representation of a single recipe step outcome.",
        "methods": [],
        "fields": []
      },
      {
        "name": "RecipeRunResult",
        "bases": [],
        "doc": "Aggregate outcome for a recipe execution, including captured outputs.",
        "methods": [
          {
            "name": "to_dict",
            "signature": "to_dict(self)",
            "doc": "Serialise the run result to a JSON-friendly mapping."
          }
        ],
        "fields": []
      },
      {
        "name": "ToolExecutor",
        "bases": [],
        "doc": "Abstract tool executor interface.",
        "methods": [],
        "fields": []
      },
      {
        "name": "GatewayToolExecutor",
        "bases": [
          "ToolExecutor"
        ],
        "doc": "Execute tools by reusing gateway HTTP/MCP helpers.",
        "methods": [
          {
            "name": "__init__",
            "signature": "__init__(self, settings)",
            "doc": null
          }
        ],
        "fields": []
      },
      {
        "name": "RecipeRunner",
        "bases": [],
        "doc": "Run recipes using the configured MCP settings.",
        "methods": [
          {
            "name": "__init__",
            "signature": "__init__(self, settings, executor_factory, audit_path)",
            "doc": null
          },
          {
            "name": "make_executor",
            "signature": "make_executor(self)",
            "doc": "Instantiate a tool executor using the configured factory."
          },
          {
            "name": "_append_audit",
            "signature": "_append_audit(self, result, context)",
            "doc": "Append the recipe outcome to the on-disk audit log."
          }
        ],
        "fields": []
      }
    ],
    "assignments": [
      "logger",
      "__all__"
    ]
  },
  {
    "path": "gateway/recipes/models.py",
    "doc": "Pydantic models describing MCP recipe configuration.",
    "imports": [
      "__future__",
      "pydantic",
      "typing"
    ],
    "functions": [],
    "classes": [
      {
        "name": "Condition",
        "bases": [
          "BaseModel"
        ],
        "doc": "Assertion condition evaluated against a step result.",
        "methods": [],
        "fields": []
      },
      {
        "name": "Capture",
        "bases": [
          "BaseModel"
        ],
        "doc": "Capture part of a step result into the execution context.",
        "methods": [],
        "fields": []
      },
      {
        "name": "WaitConfig",
        "bases": [
          "BaseModel"
        ],
        "doc": "Poll a tool until a condition is satisfied.",
        "methods": [],
        "fields": []
      },
      {
        "name": "RecipeStep",
        "bases": [
          "BaseModel"
        ],
        "doc": "Single step inside a recipe.",
        "methods": [
          {
            "name": "validate_mode",
            "signature": "validate_mode(self)",
            "doc": "Ensure mutually exclusive tool/wait configuration is respected."
          }
        ],
        "fields": []
      },
      {
        "name": "Recipe",
        "bases": [
          "BaseModel"
        ],
        "doc": "Top level recipe definition.",
        "methods": [
          {
            "name": "ensure_unique_step_ids",
            "signature": "ensure_unique_step_ids(self)",
            "doc": "Verify step identifiers are unique within the recipe."
          }
        ],
        "fields": []
      }
    ],
    "assignments": [
      "RecipeDict"
    ]
  },
  {
    "path": "gateway/scheduler.py",
    "doc": "Background scheduler that drives periodic ingestion runs.",
    "imports": [
      "__future__",
      "apscheduler.schedulers.background",
      "apscheduler.schedulers.base",
      "apscheduler.triggers.cron",
      "apscheduler.triggers.interval",
      "collections.abc",
      "contextlib",
      "filelock",
      "gateway.config.settings",
      "gateway.ingest.service",
      "gateway.observability.metrics",
      "logging",
      "pathlib",
      "subprocess",
      "time"
    ],
    "functions": [
      {
        "name": "_current_repo_head",
        "signature": "_current_repo_head(repo_root)",
        "doc": "Return the git HEAD sha for the repo, or ``None`` when unavailable."
      },
      {
        "name": "_build_trigger",
        "signature": "_build_trigger(config)",
        "doc": "Construct the APScheduler trigger based on user configuration."
      },
      {
        "name": "_describe_trigger",
        "signature": "_describe_trigger(config)",
        "doc": "Provide a human readable summary of the configured trigger."
      },
      {
        "name": "_coerce_positive_int",
        "signature": "_coerce_positive_int(value)",
        "doc": "Best-effort conversion to a positive integer with sane defaults."
      }
    ],
    "classes": [
      {
        "name": "IngestionScheduler",
        "bases": [],
        "doc": "APScheduler wrapper that coordinates repo-aware ingestion jobs.",
        "methods": [
          {
            "name": "__init__",
            "signature": "__init__(self, settings)",
            "doc": "Initialise scheduler state and ensure the scratch directory exists."
          },
          {
            "name": "start",
            "signature": "start(self)",
            "doc": "Register the ingestion job and begin scheduling if enabled."
          },
          {
            "name": "shutdown",
            "signature": "shutdown(self)",
            "doc": "Stop the scheduler and release APScheduler resources."
          },
          {
            "name": "_run_ingestion",
            "signature": "_run_ingestion(self)",
            "doc": "Execute a single ingestion cycle, guarding with a file lock."
          },
          {
            "name": "_read_last_head",
            "signature": "_read_last_head(self)",
            "doc": null
          },
          {
            "name": "_write_last_head",
            "signature": "_write_last_head(self, head)",
            "doc": null
          }
        ],
        "fields": []
      }
    ],
    "assignments": [
      "logger"
    ]
  },
  {
    "path": "gateway/search/__init__.py",
    "doc": "Search service exposing vector search with graph context.",
    "imports": [
      "dataset",
      "evaluation",
      "exporter",
      "feedback",
      "maintenance",
      "service"
    ],
    "functions": [],
    "classes": [],
    "assignments": [
      "__all__"
    ]
  },
  {
    "path": "gateway/search/cli.py",
    "doc": "Command-line helpers for search training, exports, and maintenance.",
    "imports": [
      "__future__",
      "argparse",
      "datetime",
      "gateway.config.settings",
      "gateway.observability",
      "gateway.search.evaluation",
      "gateway.search.exporter",
      "gateway.search.maintenance",
      "gateway.search.trainer",
      "logging",
      "pathlib",
      "rich.console"
    ],
    "functions": [
      {
        "name": "build_parser",
        "signature": "build_parser()",
        "doc": "Return an argument parser covering all search CLI commands."
      },
      {
        "name": "export_training_data",
        "signature": "export_training_data()",
        "doc": "Materialise feedback events into a training dataset file."
      },
      {
        "name": "train_model",
        "signature": "train_model()",
        "doc": "Train a ranking model from a prepared dataset and save the artifact."
      },
      {
        "name": "show_weights",
        "signature": "show_weights()",
        "doc": "Print the active search weight profile to the console."
      },
      {
        "name": "prune_feedback",
        "signature": "prune_feedback()",
        "doc": "Trim feedback logs by age/request count and optionally archive removals."
      },
      {
        "name": "redact_training_dataset",
        "signature": "redact_training_dataset()",
        "doc": "Strip sensitive fields and emit a sanitized dataset."
      },
      {
        "name": "evaluate_trained_model",
        "signature": "evaluate_trained_model()",
        "doc": "Run offline evaluation of a trained model against a labelled dataset."
      },
      {
        "name": "main",
        "signature": "main(argv)",
        "doc": "Entry point for the `gateway-search` command-line interface."
      }
    ],
    "classes": [],
    "assignments": [
      "logger",
      "console"
    ]
  },
  {
    "path": "gateway/search/dataset.py",
    "doc": "Utilities for reading and preparing search training datasets.",
    "imports": [
      "__future__",
      "collections.abc",
      "csv",
      "gateway.search.exporter",
      "json",
      "pathlib"
    ],
    "functions": [
      {
        "name": "load_dataset_records",
        "signature": "load_dataset_records(path)",
        "doc": "Load dataset rows from disk, raising when the file is missing."
      },
      {
        "name": "build_feature_matrix",
        "signature": "build_feature_matrix(records, feature_names)",
        "doc": "Convert dataset rows into numeric feature vectors and targets."
      },
      {
        "name": "_parse_float",
        "signature": "_parse_float(value)",
        "doc": null
      }
    ],
    "classes": [
      {
        "name": "DatasetLoadError",
        "bases": [
          "RuntimeError"
        ],
        "doc": "Raised when a dataset cannot be parsed.",
        "methods": [],
        "fields": []
      }
    ],
    "assignments": [
      "TARGET_FIELD",
      "__all__"
    ]
  },
  {
    "path": "gateway/search/evaluation.py",
    "doc": "Model evaluation utilities for the search ranking pipeline.",
    "imports": [
      "__future__",
      "collections.abc",
      "dataclasses",
      "gateway.search.dataset",
      "gateway.search.trainer",
      "math",
      "numpy",
      "numpy.typing",
      "pathlib",
      "statistics",
      "typing"
    ],
    "functions": [
      {
        "name": "evaluate_model",
        "signature": "evaluate_model(dataset_path, model_path)",
        "doc": "Load a dataset and model artifact, returning evaluation metrics."
      },
      {
        "name": "_mean_ndcg",
        "signature": "_mean_ndcg(request_ids, relevance, scores)",
        "doc": "Compute mean NDCG@k for groups identified by request ids."
      },
      {
        "name": "_dcg",
        "signature": "_dcg(relevances, k)",
        "doc": "Compute discounted cumulative gain at rank ``k``."
      },
      {
        "name": "_spearman_correlation",
        "signature": "_spearman_correlation(y_true, y_pred)",
        "doc": "Return Spearman rank correlation between true and predicted values."
      }
    ],
    "classes": [
      {
        "name": "EvaluationMetrics",
        "bases": [],
        "doc": "Aggregate metrics produced after evaluating a ranking model.",
        "methods": [],
        "fields": []
      }
    ],
    "assignments": [
      "__all__",
      "FloatArray"
    ]
  },
  {
    "path": "gateway/search/exporter.py",
    "doc": "Utilities for exporting feedback logs into training datasets.",
    "imports": [
      "__future__",
      "collections.abc",
      "csv",
      "dataclasses",
      "json",
      "logging",
      "pathlib",
      "typing"
    ],
    "functions": [
      {
        "name": "export_training_dataset",
        "signature": "export_training_dataset(events_path)",
        "doc": "Write feedback events into the requested dataset format."
      },
      {
        "name": "iter_feedback_events",
        "signature": "iter_feedback_events(path)",
        "doc": "Yield feedback events from a JSON lines log file."
      },
      {
        "name": "_write_csv",
        "signature": "_write_csv(events, options)",
        "doc": "Write feedback events into a CSV file."
      },
      {
        "name": "_write_jsonl",
        "signature": "_write_jsonl(events, options)",
        "doc": "Write feedback events into a JSONL file."
      },
      {
        "name": "_flatten_event",
        "signature": "_flatten_event(event)",
        "doc": "Flatten nested event data into scalar fields."
      }
    ],
    "classes": [
      {
        "name": "ExportOptions",
        "bases": [],
        "doc": "User-configurable options controlling dataset export.",
        "methods": [],
        "fields": []
      },
      {
        "name": "ExportStats",
        "bases": [],
        "doc": "Basic statistics about the export process.",
        "methods": [],
        "fields": []
      }
    ],
    "assignments": [
      "logger",
      "FeedbackFormat",
      "__all__"
    ]
  },
  {
    "path": "gateway/search/feedback.py",
    "doc": "Persistent storage helpers for search feedback events.",
    "imports": [
      "__future__",
      "collections.abc",
      "datetime",
      "gateway.search.service",
      "json",
      "pathlib",
      "threading",
      "uuid"
    ],
    "functions": [
      {
        "name": "_serialize_results",
        "signature": "_serialize_results()",
        "doc": null
      }
    ],
    "classes": [
      {
        "name": "SearchFeedbackStore",
        "bases": [],
        "doc": "Append-only store for search telemetry and feedback.",
        "methods": [
          {
            "name": "__init__",
            "signature": "__init__(self, root)",
            "doc": "Initialise the feedback store beneath the given directory."
          },
          {
            "name": "record",
            "signature": "record(self)",
            "doc": "Persist a feedback event for the supplied search response."
          },
          {
            "name": "_append",
            "signature": "_append(self, rows)",
            "doc": null
          }
        ],
        "fields": []
      }
    ],
    "assignments": [
      "__all__"
    ]
  },
  {
    "path": "gateway/search/maintenance.py",
    "doc": "Maintenance routines for pruning feedback logs and redacting datasets.",
    "imports": [
      "__future__",
      "collections.abc",
      "csv",
      "dataclasses",
      "datetime",
      "gateway.search.exporter",
      "json",
      "logging",
      "pathlib",
      "shutil"
    ],
    "functions": [
      {
        "name": "prune_feedback_log",
        "signature": "prune_feedback_log(events_path)",
        "doc": "Prune feedback requests based on age and count thresholds."
      },
      {
        "name": "redact_dataset",
        "signature": "redact_dataset(dataset_path)",
        "doc": "Redact sensitive fields from datasets stored as CSV or JSON Lines."
      },
      {
        "name": "_parse_timestamp",
        "signature": "_parse_timestamp(value)",
        "doc": "Parse timestamps stored as numbers or ISO 8601 strings."
      },
      {
        "name": "_collect_events",
        "signature": "_collect_events(events_path)",
        "doc": null
      },
      {
        "name": "_build_timestamps",
        "signature": "_build_timestamps(events_by_request)",
        "doc": null
      },
      {
        "name": "_apply_prune_filters",
        "signature": "_apply_prune_filters(request_order, timestamps, options, now)",
        "doc": null
      },
      {
        "name": "_preserve_original_order",
        "signature": "_preserve_original_order(order, selected_ids)",
        "doc": null
      },
      {
        "name": "_write_retained_events",
        "signature": "_write_retained_events(destination, retained_order, events_by_request)",
        "doc": null
      },
      {
        "name": "_redact_csv",
        "signature": "_redact_csv(source, destination, options)",
        "doc": "Redact sensitive columns from a CSV dataset."
      },
      {
        "name": "_redact_csv_row",
        "signature": "_redact_csv_row(row, options)",
        "doc": null
      },
      {
        "name": "_clear_field",
        "signature": "_clear_field(row, field, replacement)",
        "doc": null
      },
      {
        "name": "_redact_jsonl",
        "signature": "_redact_jsonl(source, destination, options)",
        "doc": "Redact sensitive fields from JSON lines datasets."
      },
      {
        "name": "_redact_json_record",
        "signature": "_redact_json_record(record, options)",
        "doc": null
      },
      {
        "name": "_null_field",
        "signature": "_null_field(record, field)",
        "doc": null
      }
    ],
    "classes": [
      {
        "name": "PruneOptions",
        "bases": [],
        "doc": "Configures retention rules for the feedback log pruning routine.",
        "methods": [],
        "fields": []
      },
      {
        "name": "PruneStats",
        "bases": [],
        "doc": "Summary of how many feedback requests were kept versus removed.",
        "methods": [],
        "fields": []
      },
      {
        "name": "RedactOptions",
        "bases": [],
        "doc": "Toggles that control which sensitive fields should be redacted.",
        "methods": [],
        "fields": []
      },
      {
        "name": "RedactStats",
        "bases": [],
        "doc": "Summary of how many dataset rows required redaction.",
        "methods": [],
        "fields": []
      }
    ],
    "assignments": [
      "logger",
      "_FALLBACK_TIMESTAMP",
      "__all__"
    ]
  },
  {
    "path": "gateway/search/service.py",
    "doc": "Hybrid search orchestration for Duskmantle's knowledge gateway.",
    "imports": [
      "__future__",
      "collections.abc",
      "dataclasses",
      "datetime",
      "gateway.graph.service",
      "gateway.ingest.embedding",
      "gateway.observability",
      "gateway.search.trainer",
      "logging",
      "neo4j.exceptions",
      "qdrant_client",
      "qdrant_client.http.models",
      "re",
      "time",
      "typing"
    ],
    "functions": [
      {
        "name": "_label_for_artifact",
        "signature": "_label_for_artifact(artifact_type)",
        "doc": null
      },
      {
        "name": "_summarize_graph_context",
        "signature": "_summarize_graph_context(data)",
        "doc": null
      },
      {
        "name": "_subsystems_from_context",
        "signature": "_subsystems_from_context(graph_context)",
        "doc": null
      },
      {
        "name": "_detect_query_subsystems",
        "signature": "_detect_query_subsystems(query)",
        "doc": null
      },
      {
        "name": "_normalise_hybrid_weights",
        "signature": "_normalise_hybrid_weights(vector_weight, lexical_weight)",
        "doc": null
      },
      {
        "name": "_prepare_filter_state",
        "signature": "_prepare_filter_state(filters)",
        "doc": null
      },
      {
        "name": "_passes_payload_filters",
        "signature": "_passes_payload_filters(payload, state)",
        "doc": null
      },
      {
        "name": "_normalise_payload_tags",
        "signature": "_normalise_payload_tags(raw_tags)",
        "doc": null
      },
      {
        "name": "_build_chunk",
        "signature": "_build_chunk(payload, score)",
        "doc": null
      },
      {
        "name": "_calculate_subsystem_affinity",
        "signature": "_calculate_subsystem_affinity(subsystem, query_tokens)",
        "doc": null
      },
      {
        "name": "_calculate_supporting_bonus",
        "signature": "_calculate_supporting_bonus(related_artifacts)",
        "doc": null
      },
      {
        "name": "_calculate_coverage_info",
        "signature": "_calculate_coverage_info(chunk, weight_coverage_penalty)",
        "doc": null
      },
      {
        "name": "_coerce_ratio_value",
        "signature": "_coerce_ratio_value(value)",
        "doc": null
      },
      {
        "name": "_calculate_criticality_score",
        "signature": "_calculate_criticality_score(chunk, graph_context)",
        "doc": null
      },
      {
        "name": "_update_path_depth_signal",
        "signature": "_update_path_depth_signal(signals, path_depth, graph_context)",
        "doc": null
      },
      {
        "name": "_ensure_criticality_signal",
        "signature": "_ensure_criticality_signal(signals, chunk, graph_context)",
        "doc": null
      },
      {
        "name": "_ensure_freshness_signal",
        "signature": "_ensure_freshness_signal(signals, chunk, graph_context, freshness_days)",
        "doc": null
      },
      {
        "name": "_ensure_coverage_ratio_signal",
        "signature": "_ensure_coverage_ratio_signal(signals, chunk)",
        "doc": null
      },
      {
        "name": "_lexical_score",
        "signature": "_lexical_score(query, chunk)",
        "doc": null
      },
      {
        "name": "_base_scoring",
        "signature": "_base_scoring(vector_score, lexical_score, vector_weight, lexical_weight)",
        "doc": null
      },
      {
        "name": "_compute_scoring",
        "signature": "_compute_scoring()",
        "doc": null
      },
      {
        "name": "_populate_additional_signals",
        "signature": "_populate_additional_signals()",
        "doc": null
      },
      {
        "name": "_estimate_path_depth",
        "signature": "_estimate_path_depth(graph_context)",
        "doc": null
      },
      {
        "name": "_extract_subsystem_criticality",
        "signature": "_extract_subsystem_criticality(graph_context)",
        "doc": null
      },
      {
        "name": "_normalise_criticality",
        "signature": "_normalise_criticality(value)",
        "doc": null
      },
      {
        "name": "_compute_freshness_days",
        "signature": "_compute_freshness_days(chunk, graph_context)",
        "doc": null
      },
      {
        "name": "_resolve_chunk_datetime",
        "signature": "_resolve_chunk_datetime(chunk, graph_context)",
        "doc": null
      },
      {
        "name": "_parse_iso_datetime",
        "signature": "_parse_iso_datetime(value)",
        "doc": null
      }
    ],
    "classes": [
      {
        "name": "SearchResult",
        "bases": [],
        "doc": "Single ranked chunk returned from the search pipeline.",
        "methods": [],
        "fields": []
      },
      {
        "name": "SearchResponse",
        "bases": [],
        "doc": "API-friendly container for search results and metadata.",
        "methods": [],
        "fields": []
      },
      {
        "name": "SearchOptions",
        "bases": [],
        "doc": "Runtime options controlling the search service behaviour.",
        "methods": [],
        "fields": []
      },
      {
        "name": "SearchWeights",
        "bases": [],
        "doc": "Weighting configuration for hybrid scoring.",
        "methods": [],
        "fields": []
      },
      {
        "name": "FilterState",
        "bases": [],
        "doc": "Preprocessed filter collections derived from request parameters.",
        "methods": [],
        "fields": []
      },
      {
        "name": "CoverageInfo",
        "bases": [],
        "doc": "Coverage characteristics used during scoring.",
        "methods": [],
        "fields": []
      },
      {
        "name": "SearchService",
        "bases": [],
        "doc": "Execute hybrid vector/graph search with heuristic or ML scoring.",
        "methods": [
          {
            "name": "__init__",
            "signature": "__init__(self, qdrant_client, collection_name, embedder)",
            "doc": "Initialise the search service with vector and scoring options."
          },
          {
            "name": "search",
            "signature": "search(self)",
            "doc": "Execute a hybrid search request and return ranked results."
          },
          {
            "name": "_resolve_graph_context",
            "signature": "_resolve_graph_context(self)",
            "doc": "Fetch and cache graph context for a search result chunk."
          },
          {
            "name": "_build_model_features",
            "signature": "_build_model_features(self)",
            "doc": null
          },
          {
            "name": "_apply_model",
            "signature": "_apply_model(self, features)",
            "doc": null
          }
        ],
        "fields": []
      }
    ],
    "assignments": [
      "logger",
      "_TOKEN_PATTERN"
    ]
  },
  {
    "path": "gateway/search/trainer.py",
    "doc": "Training utilities for search ranking models.",
    "imports": [
      "__future__",
      "collections.abc",
      "dataclasses",
      "datetime",
      "gateway.search.dataset",
      "json",
      "math",
      "numpy",
      "pathlib"
    ],
    "functions": [
      {
        "name": "train_from_dataset",
        "signature": "train_from_dataset(path)",
        "doc": "Train a logistic regression model from the labelled dataset."
      },
      {
        "name": "save_artifact",
        "signature": "save_artifact(artifact, path)",
        "doc": "Write the model artifact to disk as JSON."
      },
      {
        "name": "load_artifact",
        "signature": "load_artifact(path)",
        "doc": "Load a saved model artifact from disk."
      },
      {
        "name": "_linear_regression",
        "signature": "_linear_regression(X, y)",
        "doc": null
      }
    ],
    "classes": [
      {
        "name": "TrainingResult",
        "bases": [],
        "doc": "Capture optimiser output for debug or inspection.",
        "methods": [],
        "fields": []
      },
      {
        "name": "ModelArtifact",
        "bases": [],
        "doc": "Persisted search model metadata and coefficients.",
        "methods": [],
        "fields": []
      }
    ],
    "assignments": [
      "__all__"
    ]
  },
  {
    "path": "gateway/ui/__init__.py",
    "doc": "UI utilities and routers.",
    "imports": [
      "routes"
    ],
    "functions": [],
    "classes": [],
    "assignments": [
      "__all__"
    ]
  },
  {
    "path": "gateway/ui/routes.py",
    "doc": "UI router exposing static assets and HTML entry points.",
    "imports": [
      "__future__",
      "fastapi",
      "fastapi.responses",
      "fastapi.templating",
      "gateway.config.settings",
      "gateway.observability",
      "json",
      "logging",
      "pathlib"
    ],
    "functions": [
      {
        "name": "get_static_path",
        "signature": "get_static_path()",
        "doc": "Return the absolute path to UI static assets."
      }
    ],
    "classes": [],
    "assignments": [
      "STATIC_DIR",
      "TEMPLATES_DIR",
      "_templates",
      "router",
      "logger"
    ]
  },
  {
    "path": "scripts/generate-changelog.py",
    "doc": "Generate changelog entries from Conventional Commits.",
    "imports": [
      "__future__",
      "argparse",
      "collections",
      "datetime",
      "pathlib",
      "subprocess",
      "sys"
    ],
    "functions": [
      {
        "name": "_run_git",
        "signature": "_run_git(args)",
        "doc": null
      },
      {
        "name": "discover_commits",
        "signature": "discover_commits(since)",
        "doc": null
      },
      {
        "name": "categorize",
        "signature": "categorize(commits)",
        "doc": null
      },
      {
        "name": "update_changelog",
        "signature": "update_changelog(version, released, entries)",
        "doc": null
      },
      {
        "name": "main",
        "signature": "main()",
        "doc": null
      }
    ],
    "classes": [],
    "assignments": [
      "ROOT",
      "CHANGELOG",
      "CATEGORY_MAP"
    ]
  },
  {
    "path": "tests/__init__.py",
    "doc": "Test package for the knowledge gateway.",
    "imports": [],
    "functions": [],
    "classes": [],
    "assignments": []
  },
  {
    "path": "tests/conftest.py",
    "doc": null,
    "imports": [
      "__future__",
      "collections.abc",
      "neo4j",
      "os",
      "pytest",
      "sentence_transformers",
      "shutil",
      "subprocess",
      "sys",
      "time",
      "types",
      "typing",
      "uuid",
      "warnings"
    ],
    "functions": [
      {
        "name": "disable_real_graph_driver",
        "signature": "disable_real_graph_driver(monkeypatch, request)",
        "doc": null
      },
      {
        "name": "neo4j_test_environment",
        "signature": "neo4j_test_environment()",
        "doc": null
      },
      {
        "name": "pytest_collection_modifyitems",
        "signature": "pytest_collection_modifyitems(config, items)",
        "doc": null
      }
    ],
    "classes": [
      {
        "name": "_NullSession",
        "bases": [],
        "doc": null,
        "methods": [
          {
            "name": "__enter__",
            "signature": "__enter__(self)",
            "doc": null
          },
          {
            "name": "__exit__",
            "signature": "__exit__(self, exc_type, exc, tb)",
            "doc": null
          },
          {
            "name": "execute_read",
            "signature": "execute_read(self, func)",
            "doc": null
          },
          {
            "name": "run",
            "signature": "run(self)",
            "doc": null
          }
        ],
        "fields": []
      },
      {
        "name": "_NullDriver",
        "bases": [],
        "doc": null,
        "methods": [
          {
            "name": "session",
            "signature": "session(self)",
            "doc": null
          },
          {
            "name": "close",
            "signature": "close(self)",
            "doc": null
          }
        ],
        "fields": []
      }
    ],
    "assignments": []
  },
  {
    "path": "tests/mcp/test_server_tools.py",
    "doc": "Integration tests for MCP server tools and metrics wiring.",
    "imports": [
      "__future__",
      "asyncio",
      "collections.abc",
      "gateway.mcp",
      "gateway.mcp.config",
      "gateway.mcp.exceptions",
      "gateway.mcp.server",
      "gateway.observability.metrics",
      "pathlib",
      "prometheus_client",
      "pytest",
      "typing"
    ],
    "functions": [
      {
        "name": "_reset_mcp_metrics",
        "signature": "_reset_mcp_metrics()",
        "doc": null
      },
      {
        "name": "mcp_server",
        "signature": "mcp_server()",
        "doc": null
      },
      {
        "name": "_counter_value",
        "signature": "_counter_value(counter)",
        "doc": null
      },
      {
        "name": "_histogram_sum",
        "signature": "_histogram_sum(histogram)",
        "doc": null
      },
      {
        "name": "_upload_counter",
        "signature": "_upload_counter(result)",
        "doc": null
      },
      {
        "name": "_storetext_counter",
        "signature": "_storetext_counter(result)",
        "doc": null
      },
      {
        "name": "_tool_fn",
        "signature": "_tool_fn(tool)",
        "doc": null
      }
    ],
    "classes": [],
    "assignments": [
      "ServerFixture",
      "ToolCallable"
    ]
  },
  {
    "path": "tests/mcp/test_utils_files.py",
    "doc": null,
    "imports": [
      "__future__",
      "gateway.mcp.utils",
      "pathlib",
      "pytest"
    ],
    "functions": [
      {
        "name": "test_sweep_documents_copies_supported_files",
        "signature": "test_sweep_documents_copies_supported_files(tmp_path)",
        "doc": null
      },
      {
        "name": "test_sweep_documents_dry_run_reports_actions",
        "signature": "test_sweep_documents_dry_run_reports_actions(tmp_path)",
        "doc": null
      },
      {
        "name": "test_copy_into_root_prevents_traversal",
        "signature": "test_copy_into_root_prevents_traversal(tmp_path)",
        "doc": null
      },
      {
        "name": "test_write_text_document_requires_content",
        "signature": "test_write_text_document_requires_content(tmp_path)",
        "doc": null
      },
      {
        "name": "test_slugify_generates_fallback_when_empty",
        "signature": "test_slugify_generates_fallback_when_empty()",
        "doc": null
      }
    ],
    "classes": [],
    "assignments": []
  },
  {
    "path": "tests/playwright_server.py",
    "doc": null,
    "imports": [
      "__future__",
      "datetime",
      "gateway.api.app",
      "json",
      "os",
      "pathlib",
      "shutil",
      "signal",
      "uvicorn"
    ],
    "functions": [
      {
        "name": "_write_json",
        "signature": "_write_json(path, payload)",
        "doc": null
      },
      {
        "name": "_prepare_state",
        "signature": "_prepare_state(state_path)",
        "doc": null
      },
      {
        "name": "_configure_environment",
        "signature": "_configure_environment(state_path)",
        "doc": null
      },
      {
        "name": "main",
        "signature": "main()",
        "doc": null
      }
    ],
    "classes": [],
    "assignments": []
  },
  {
    "path": "tests/test_api_security.py",
    "doc": null,
    "imports": [
      "__future__",
      "fastapi.testclient",
      "gateway",
      "gateway.api.app",
      "gateway.config.settings",
      "gateway.graph.service",
      "gateway.search.service",
      "json",
      "logging",
      "pathlib",
      "pytest",
      "typing"
    ],
    "functions": [
      {
        "name": "reset_settings_cache",
        "signature": "reset_settings_cache()",
        "doc": null
      },
      {
        "name": "test_audit_requires_token",
        "signature": "test_audit_requires_token(tmp_path, monkeypatch)",
        "doc": null
      },
      {
        "name": "test_coverage_endpoint",
        "signature": "test_coverage_endpoint(tmp_path, monkeypatch)",
        "doc": null
      },
      {
        "name": "test_coverage_missing_report",
        "signature": "test_coverage_missing_report(tmp_path, monkeypatch)",
        "doc": null
      },
      {
        "name": "test_rate_limiting",
        "signature": "test_rate_limiting(monkeypatch)",
        "doc": null
      },
      {
        "name": "test_startup_logs_configuration",
        "signature": "test_startup_logs_configuration(monkeypatch, tmp_path, caplog)",
        "doc": null
      },
      {
        "name": "test_secure_mode_without_admin_token_fails",
        "signature": "test_secure_mode_without_admin_token_fails(tmp_path, monkeypatch)",
        "doc": null
      },
      {
        "name": "test_secure_mode_requires_custom_neo4j_password",
        "signature": "test_secure_mode_requires_custom_neo4j_password(tmp_path, monkeypatch)",
        "doc": null
      },
      {
        "name": "test_rate_limiting_search",
        "signature": "test_rate_limiting_search(monkeypatch, tmp_path)",
        "doc": null
      }
    ],
    "classes": [],
    "assignments": []
  },
  {
    "path": "tests/test_app_smoke.py",
    "doc": null,
    "imports": [
      "__future__",
      "fastapi.testclient",
      "gateway.api.app",
      "gateway.config.settings",
      "gateway.ingest.audit",
      "json",
      "logging",
      "pathlib",
      "pytest",
      "time",
      "unittest"
    ],
    "functions": [
      {
        "name": "reset_settings_cache",
        "signature": "reset_settings_cache()",
        "doc": null
      },
      {
        "name": "test_health_endpoint_reports_diagnostics",
        "signature": "test_health_endpoint_reports_diagnostics(tmp_path, monkeypatch)",
        "doc": null
      },
      {
        "name": "test_health_endpoint_ok_when_artifacts_present",
        "signature": "test_health_endpoint_ok_when_artifacts_present(tmp_path, monkeypatch)",
        "doc": null
      },
      {
        "name": "test_ready_endpoint_returns_ready",
        "signature": "test_ready_endpoint_returns_ready()",
        "doc": null
      },
      {
        "name": "test_lifecycle_history_endpoint",
        "signature": "test_lifecycle_history_endpoint(tmp_path, monkeypatch)",
        "doc": null
      },
      {
        "name": "test_requires_non_default_neo4j_password_when_auth_enabled",
        "signature": "test_requires_non_default_neo4j_password_when_auth_enabled(monkeypatch, tmp_path)",
        "doc": null
      },
      {
        "name": "test_requires_non_empty_neo4j_password_when_auth_enabled",
        "signature": "test_requires_non_empty_neo4j_password_when_auth_enabled(monkeypatch, tmp_path)",
        "doc": null
      },
      {
        "name": "test_logs_warning_when_neo4j_auth_disabled",
        "signature": "test_logs_warning_when_neo4j_auth_disabled(monkeypatch, tmp_path, caplog)",
        "doc": null
      }
    ],
    "classes": [],
    "assignments": []
  },
  {
    "path": "tests/test_coverage_report.py",
    "doc": null,
    "imports": [
      "__future__",
      "collections.abc",
      "fastapi.testclient",
      "gateway.api.app",
      "gateway.config.settings",
      "gateway.ingest.coverage",
      "gateway.ingest.pipeline",
      "gateway.observability.metrics",
      "json",
      "pathlib",
      "prometheus_client",
      "pytest"
    ],
    "functions": [
      {
        "name": "test_write_coverage_report",
        "signature": "test_write_coverage_report(tmp_path)",
        "doc": null
      },
      {
        "name": "test_coverage_endpoint_after_report_generation",
        "signature": "test_coverage_endpoint_after_report_generation(tmp_path, monkeypatch)",
        "doc": null
      },
      {
        "name": "test_coverage_history_rotation",
        "signature": "test_coverage_history_rotation(tmp_path)",
        "doc": null
      }
    ],
    "classes": [
      {
        "name": "StubQdrantWriter",
        "bases": [],
        "doc": null,
        "methods": [
          {
            "name": "ensure_collection",
            "signature": "ensure_collection(self, vector_size)",
            "doc": null
          },
          {
            "name": "upsert_chunks",
            "signature": "upsert_chunks(self, chunks)",
            "doc": null
          }
        ],
        "fields": []
      },
      {
        "name": "StubNeo4jWriter",
        "bases": [],
        "doc": null,
        "methods": [
          {
            "name": "ensure_constraints",
            "signature": "ensure_constraints(self)",
            "doc": null
          },
          {
            "name": "sync_artifact",
            "signature": "sync_artifact(self, artifact)",
            "doc": null
          },
          {
            "name": "sync_chunks",
            "signature": "sync_chunks(self, chunk_embeddings)",
            "doc": null
          }
        ],
        "fields": []
      }
    ],
    "assignments": []
  },
  {
    "path": "tests/test_graph_api.py",
    "doc": null,
    "imports": [
      "__future__",
      "fastapi",
      "fastapi.testclient",
      "gateway.api.app",
      "gateway.config.settings",
      "gateway.graph",
      "gateway.graph.migrations.runner",
      "gateway.ingest.neo4j_writer",
      "gateway.ingest.pipeline",
      "neo4j",
      "os",
      "pathlib",
      "pytest",
      "typing"
    ],
    "functions": [
      {
        "name": "app",
        "signature": "app(monkeypatch)",
        "doc": null
      },
      {
        "name": "test_graph_subsystem_returns_payload",
        "signature": "test_graph_subsystem_returns_payload(app)",
        "doc": null
      },
      {
        "name": "test_graph_subsystem_not_found",
        "signature": "test_graph_subsystem_not_found(app)",
        "doc": null
      },
      {
        "name": "test_graph_subsystem_graph_endpoint",
        "signature": "test_graph_subsystem_graph_endpoint(app)",
        "doc": null
      },
      {
        "name": "test_graph_orphans_endpoint",
        "signature": "test_graph_orphans_endpoint(app)",
        "doc": null
      },
      {
        "name": "test_graph_node_endpoint",
        "signature": "test_graph_node_endpoint(app)",
        "doc": null
      },
      {
        "name": "test_graph_node_accepts_slash_encoded_ids",
        "signature": "test_graph_node_accepts_slash_encoded_ids(app)",
        "doc": null
      },
      {
        "name": "test_graph_node_endpoint_live",
        "signature": "test_graph_node_endpoint_live(monkeypatch, tmp_path)",
        "doc": null
      },
      {
        "name": "test_graph_search_endpoint_live",
        "signature": "test_graph_search_endpoint_live(monkeypatch, tmp_path)",
        "doc": null
      },
      {
        "name": "test_graph_search_endpoint",
        "signature": "test_graph_search_endpoint(app)",
        "doc": null
      },
      {
        "name": "test_graph_cypher_requires_maintainer_token",
        "signature": "test_graph_cypher_requires_maintainer_token(monkeypatch)",
        "doc": null
      },
      {
        "name": "test_graph_reader_scope",
        "signature": "test_graph_reader_scope(monkeypatch)",
        "doc": null
      }
    ],
    "classes": [
      {
        "name": "DummyGraphService",
        "bases": [],
        "doc": null,
        "methods": [
          {
            "name": "__init__",
            "signature": "__init__(self, responses)",
            "doc": null
          },
          {
            "name": "get_subsystem",
            "signature": "get_subsystem(self, name)",
            "doc": null
          },
          {
            "name": "get_node",
            "signature": "get_node(self, node_id)",
            "doc": null
          },
          {
            "name": "search",
            "signature": "search(self, term)",
            "doc": null
          },
          {
            "name": "get_subsystem_graph",
            "signature": "get_subsystem_graph(self, name)",
            "doc": null
          },
          {
            "name": "list_orphan_nodes",
            "signature": "list_orphan_nodes(self)",
            "doc": null
          },
          {
            "name": "run_cypher",
            "signature": "run_cypher(self, query, parameters)",
            "doc": null
          }
        ],
        "fields": []
      }
    ],
    "assignments": []
  },
  {
    "path": "tests/test_graph_auto_migrate.py",
    "doc": null,
    "imports": [
      "__future__",
      "gateway.api.app",
      "gateway.config.settings",
      "gateway.observability.metrics",
      "prometheus_client",
      "pytest",
      "unittest"
    ],
    "functions": [
      {
        "name": "reset_settings_cache",
        "signature": "reset_settings_cache()",
        "doc": null
      },
      {
        "name": "reset_migration_metrics",
        "signature": "reset_migration_metrics()",
        "doc": null
      },
      {
        "name": "_metric",
        "signature": "_metric(name)",
        "doc": null
      },
      {
        "name": "test_auto_migrate_runs_when_enabled",
        "signature": "test_auto_migrate_runs_when_enabled(monkeypatch)",
        "doc": null
      },
      {
        "name": "test_auto_migrate_skipped_when_disabled",
        "signature": "test_auto_migrate_skipped_when_disabled(monkeypatch)",
        "doc": null
      },
      {
        "name": "test_auto_migrate_records_failure",
        "signature": "test_auto_migrate_records_failure(monkeypatch)",
        "doc": null
      },
      {
        "name": "test_missing_database_disables_graph_driver",
        "signature": "test_missing_database_disables_graph_driver(monkeypatch)",
        "doc": null
      }
    ],
    "classes": [],
    "assignments": []
  },
  {
    "path": "tests/test_graph_cli.py",
    "doc": null,
    "imports": [
      "__future__",
      "gateway.graph",
      "pytest",
      "unittest"
    ],
    "functions": [
      {
        "name": "test_graph_cli_migrate_runs_runner",
        "signature": "test_graph_cli_migrate_runs_runner(monkeypatch)",
        "doc": null
      },
      {
        "name": "test_graph_cli_dry_run_prints_pending",
        "signature": "test_graph_cli_dry_run_prints_pending(monkeypatch, capsys)",
        "doc": null
      }
    ],
    "classes": [
      {
        "name": "DummySettings",
        "bases": [],
        "doc": null,
        "methods": [],
        "fields": []
      }
    ],
    "assignments": []
  },
  {
    "path": "tests/test_graph_database_validation.py",
    "doc": null,
    "imports": [
      "__future__",
      "gateway.api",
      "neo4j.exceptions",
      "unittest"
    ],
    "functions": [
      {
        "name": "test_verify_graph_database_returns_false_when_database_missing",
        "signature": "test_verify_graph_database_returns_false_when_database_missing()",
        "doc": null
      },
      {
        "name": "test_verify_graph_database_returns_true_on_success",
        "signature": "test_verify_graph_database_returns_true_on_success()",
        "doc": null
      }
    ],
    "classes": [],
    "assignments": []
  },
  {
    "path": "tests/test_graph_migrations.py",
    "doc": null,
    "imports": [
      "__future__",
      "collections",
      "gateway.graph.migrations.runner",
      "types"
    ],
    "functions": [
      {
        "name": "test_migration_runner_applies_pending_migrations",
        "signature": "test_migration_runner_applies_pending_migrations()",
        "doc": null
      }
    ],
    "classes": [
      {
        "name": "FakeResult",
        "bases": [],
        "doc": null,
        "methods": [
          {
            "name": "__init__",
            "signature": "__init__(self, record)",
            "doc": null
          },
          {
            "name": "single",
            "signature": "single(self)",
            "doc": null
          }
        ],
        "fields": []
      },
      {
        "name": "FakeTransaction",
        "bases": [],
        "doc": null,
        "methods": [
          {
            "name": "__init__",
            "signature": "__init__(self, applied_ids, results)",
            "doc": null
          },
          {
            "name": "run",
            "signature": "run(self, query)",
            "doc": null
          },
          {
            "name": "commit",
            "signature": "commit(self)",
            "doc": null
          },
          {
            "name": "rollback",
            "signature": "rollback(self)",
            "doc": null
          },
          {
            "name": "__enter__",
            "signature": "__enter__(self)",
            "doc": null
          },
          {
            "name": "__exit__",
            "signature": "__exit__(self, exc_type, exc_val, exc_tb)",
            "doc": null
          }
        ],
        "fields": []
      },
      {
        "name": "FakeSession",
        "bases": [],
        "doc": null,
        "methods": [
          {
            "name": "__init__",
            "signature": "__init__(self, applied_ids, records)",
            "doc": null
          },
          {
            "name": "run",
            "signature": "run(self, query)",
            "doc": null
          },
          {
            "name": "begin_transaction",
            "signature": "begin_transaction(self)",
            "doc": null
          },
          {
            "name": "close",
            "signature": "close(self)",
            "doc": null
          },
          {
            "name": "__enter__",
            "signature": "__enter__(self)",
            "doc": null
          },
          {
            "name": "__exit__",
            "signature": "__exit__(self, exc_type, exc_val, exc_tb)",
            "doc": null
          }
        ],
        "fields": []
      },
      {
        "name": "FakeDriver",
        "bases": [],
        "doc": null,
        "methods": [
          {
            "name": "__init__",
            "signature": "__init__(self)",
            "doc": null
          },
          {
            "name": "session",
            "signature": "session(self, database)",
            "doc": null
          },
          {
            "name": "close",
            "signature": "close(self)",
            "doc": null
          }
        ],
        "fields": []
      }
    ],
    "assignments": []
  },
  {
    "path": "tests/test_graph_service_startup.py",
    "doc": null,
    "imports": [
      "__future__",
      "fastapi",
      "gateway.api.app",
      "gateway.config.settings",
      "pytest",
      "starlette.requests",
      "unittest"
    ],
    "functions": [
      {
        "name": "reset_settings_cache",
        "signature": "reset_settings_cache()",
        "doc": null
      },
      {
        "name": "set_state_path",
        "signature": "set_state_path(tmp_path_factory, monkeypatch)",
        "doc": null
      },
      {
        "name": "_make_request",
        "signature": "_make_request(app)",
        "doc": null
      },
      {
        "name": "test_graph_dependency_returns_503_when_database_missing",
        "signature": "test_graph_dependency_returns_503_when_database_missing(monkeypatch)",
        "doc": null
      },
      {
        "name": "test_graph_dependency_returns_service_when_available",
        "signature": "test_graph_dependency_returns_service_when_available(monkeypatch)",
        "doc": null
      }
    ],
    "classes": [],
    "assignments": []
  },
  {
    "path": "tests/test_graph_service_unit.py",
    "doc": null,
    "imports": [
      "__future__",
      "collections.abc",
      "gateway.graph",
      "gateway.graph.service",
      "pytest",
      "types",
      "unittest"
    ],
    "functions": [
      {
        "name": "patch_graph_types",
        "signature": "patch_graph_types(monkeypatch)",
        "doc": null
      },
      {
        "name": "dummy_driver",
        "signature": "dummy_driver()",
        "doc": null
      },
      {
        "name": "test_get_subsystem_paginates_and_includes_artifacts",
        "signature": "test_get_subsystem_paginates_and_includes_artifacts(monkeypatch, dummy_driver)",
        "doc": null
      },
      {
        "name": "test_get_subsystem_missing_raises",
        "signature": "test_get_subsystem_missing_raises(monkeypatch, dummy_driver)",
        "doc": null
      },
      {
        "name": "test_get_subsystem_graph_returns_nodes_and_edges",
        "signature": "test_get_subsystem_graph_returns_nodes_and_edges(monkeypatch, dummy_driver)",
        "doc": null
      },
      {
        "name": "test_fetch_subsystem_paths_inlines_depth_literal",
        "signature": "test_fetch_subsystem_paths_inlines_depth_literal(monkeypatch)",
        "doc": null
      },
      {
        "name": "test_get_node_with_relationships",
        "signature": "test_get_node_with_relationships(monkeypatch, dummy_driver)",
        "doc": null
      },
      {
        "name": "test_list_orphan_nodes_rejects_unknown_label",
        "signature": "test_list_orphan_nodes_rejects_unknown_label(dummy_driver)",
        "doc": null
      },
      {
        "name": "test_list_orphan_nodes_serializes_results",
        "signature": "test_list_orphan_nodes_serializes_results(monkeypatch, dummy_driver)",
        "doc": null
      },
      {
        "name": "test_get_node_missing_raises",
        "signature": "test_get_node_missing_raises(monkeypatch, dummy_driver)",
        "doc": null
      },
      {
        "name": "test_search_serializes_results",
        "signature": "test_search_serializes_results(monkeypatch, dummy_driver)",
        "doc": null
      },
      {
        "name": "test_shortest_path_depth",
        "signature": "test_shortest_path_depth(monkeypatch, dummy_driver)",
        "doc": null
      },
      {
        "name": "test_shortest_path_depth_none",
        "signature": "test_shortest_path_depth_none(monkeypatch, dummy_driver)",
        "doc": null
      },
      {
        "name": "test_run_cypher_serializes_records",
        "signature": "test_run_cypher_serializes_records(monkeypatch, dummy_driver)",
        "doc": null
      },
      {
        "name": "test_run_cypher_rejects_non_read_queries",
        "signature": "test_run_cypher_rejects_non_read_queries(dummy_driver)",
        "doc": null
      }
    ],
    "classes": [
      {
        "name": "DummyNode",
        "bases": [
          "dict[str, object]"
        ],
        "doc": null,
        "methods": [
          {
            "name": "__init__",
            "signature": "__init__(self, labels, element_id)",
            "doc": null
          }
        ],
        "fields": []
      },
      {
        "name": "DummyRelationship",
        "bases": [
          "dict[str, object]"
        ],
        "doc": null,
        "methods": [
          {
            "name": "__init__",
            "signature": "__init__(self, start_node, end_node, rel_type)",
            "doc": null
          }
        ],
        "fields": []
      },
      {
        "name": "DummySession",
        "bases": [],
        "doc": null,
        "methods": [
          {
            "name": "__init__",
            "signature": "__init__(self)",
            "doc": null
          },
          {
            "name": "__enter__",
            "signature": "__enter__(self)",
            "doc": null
          },
          {
            "name": "__exit__",
            "signature": "__exit__(self, exc_type, exc, tb)",
            "doc": null
          },
          {
            "name": "execute_read",
            "signature": "execute_read(self, func)",
            "doc": null
          },
          {
            "name": "run",
            "signature": "run(self, query)",
            "doc": null
          }
        ],
        "fields": []
      },
      {
        "name": "DummyDriver",
        "bases": [],
        "doc": null,
        "methods": [
          {
            "name": "__init__",
            "signature": "__init__(self, session)",
            "doc": null
          },
          {
            "name": "session",
            "signature": "session(self)",
            "doc": null
          },
          {
            "name": "execute_query",
            "signature": "execute_query(self, query, parameters, database_)",
            "doc": null
          }
        ],
        "fields": []
      }
    ],
    "assignments": [
      "DriverFixture"
    ]
  },
  {
    "path": "tests/test_graph_validation.py",
    "doc": "End-to-end validation of ingestion and graph-backed search.",
    "imports": [
      "__future__",
      "collections.abc",
      "gateway.graph.migrations.runner",
      "gateway.graph.service",
      "gateway.ingest.embedding",
      "gateway.ingest.neo4j_writer",
      "gateway.ingest.pipeline",
      "gateway.search",
      "neo4j",
      "os",
      "pathlib",
      "pytest",
      "qdrant_client",
      "typing"
    ],
    "functions": [
      {
        "name": "test_ingestion_populates_graph",
        "signature": "test_ingestion_populates_graph(tmp_path)",
        "doc": "Run ingestion and verify graph nodes, edges, and metadata."
      },
      {
        "name": "test_search_replay_against_real_graph",
        "signature": "test_search_replay_against_real_graph(tmp_path)",
        "doc": "Replay saved search results against the populated knowledge graph."
      }
    ],
    "classes": [
      {
        "name": "_DummyEmbedder",
        "bases": [
          "Embedder"
        ],
        "doc": "Minimal embedder returning deterministic vectors for tests.",
        "methods": [
          {
            "name": "__init__",
            "signature": "__init__(self)",
            "doc": null
          },
          {
            "name": "dimension",
            "signature": "dimension(self)",
            "doc": null
          },
          {
            "name": "encode",
            "signature": "encode(self, texts)",
            "doc": null
          }
        ],
        "fields": []
      },
      {
        "name": "_FakePoint",
        "bases": [],
        "doc": null,
        "methods": [
          {
            "name": "__init__",
            "signature": "__init__(self, payload, score)",
            "doc": null
          }
        ],
        "fields": []
      },
      {
        "name": "_DummyQdrantClient",
        "bases": [],
        "doc": "Stub Qdrant client that returns pre-seeded points.",
        "methods": [
          {
            "name": "__init__",
            "signature": "__init__(self, points)",
            "doc": null
          },
          {
            "name": "search",
            "signature": "search(self)",
            "doc": null
          }
        ],
        "fields": []
      }
    ],
    "assignments": []
  },
  {
    "path": "tests/test_ingest_cli.py",
    "doc": null,
    "imports": [
      "__future__",
      "gateway.config.settings",
      "gateway.ingest",
      "gateway.ingest.audit",
      "gateway.ingest.pipeline",
      "pathlib",
      "pytest",
      "time",
      "unittest"
    ],
    "functions": [
      {
        "name": "reset_settings_cache",
        "signature": "reset_settings_cache()",
        "doc": null
      },
      {
        "name": "sample_repo",
        "signature": "sample_repo(tmp_path)",
        "doc": null
      },
      {
        "name": "test_cli_rebuild_dry_run",
        "signature": "test_cli_rebuild_dry_run(sample_repo, monkeypatch)",
        "doc": null
      },
      {
        "name": "test_cli_rebuild_requires_maintainer_token",
        "signature": "test_cli_rebuild_requires_maintainer_token(sample_repo, monkeypatch)",
        "doc": null
      },
      {
        "name": "test_cli_rebuild_with_maintainer_token",
        "signature": "test_cli_rebuild_with_maintainer_token(sample_repo, monkeypatch)",
        "doc": null
      },
      {
        "name": "test_cli_rebuild_full_rebuild_flag",
        "signature": "test_cli_rebuild_full_rebuild_flag(sample_repo, monkeypatch)",
        "doc": null
      },
      {
        "name": "test_cli_rebuild_incremental_flag",
        "signature": "test_cli_rebuild_incremental_flag(sample_repo, monkeypatch)",
        "doc": null
      },
      {
        "name": "test_cli_audit_history_json",
        "signature": "test_cli_audit_history_json(tmp_path, monkeypatch, capsys)",
        "doc": null
      },
      {
        "name": "test_cli_audit_history_no_entries",
        "signature": "test_cli_audit_history_no_entries(tmp_path, monkeypatch, capsys)",
        "doc": null
      }
    ],
    "classes": [],
    "assignments": []
  },
  {
    "path": "tests/test_ingest_pipeline.py",
    "doc": null,
    "imports": [
      "__future__",
      "collections.abc",
      "gateway.ingest.pipeline",
      "pathlib",
      "prometheus_client",
      "pytest"
    ],
    "functions": [
      {
        "name": "_metric_value",
        "signature": "_metric_value(name, labels)",
        "doc": null
      },
      {
        "name": "sample_repo",
        "signature": "sample_repo(tmp_path)",
        "doc": null
      },
      {
        "name": "test_pipeline_generates_chunks",
        "signature": "test_pipeline_generates_chunks(sample_repo)",
        "doc": null
      },
      {
        "name": "test_pipeline_removes_stale_artifacts",
        "signature": "test_pipeline_removes_stale_artifacts(tmp_path)",
        "doc": null
      },
      {
        "name": "test_pipeline_skips_unchanged_artifacts",
        "signature": "test_pipeline_skips_unchanged_artifacts(tmp_path)",
        "doc": null
      }
    ],
    "classes": [
      {
        "name": "StubQdrantWriter",
        "bases": [],
        "doc": null,
        "methods": [
          {
            "name": "__init__",
            "signature": "__init__(self)",
            "doc": null
          },
          {
            "name": "ensure_collection",
            "signature": "ensure_collection(self, vector_size)",
            "doc": null
          },
          {
            "name": "upsert_chunks",
            "signature": "upsert_chunks(self, chunks)",
            "doc": null
          },
          {
            "name": "delete_artifact",
            "signature": "delete_artifact(self, artifact_path)",
            "doc": null
          }
        ],
        "fields": []
      },
      {
        "name": "StubNeo4jWriter",
        "bases": [],
        "doc": null,
        "methods": [
          {
            "name": "__init__",
            "signature": "__init__(self)",
            "doc": null
          },
          {
            "name": "ensure_constraints",
            "signature": "ensure_constraints(self)",
            "doc": null
          },
          {
            "name": "sync_artifact",
            "signature": "sync_artifact(self, artifact)",
            "doc": null
          },
          {
            "name": "sync_chunks",
            "signature": "sync_chunks(self, chunk_embeddings)",
            "doc": null
          },
          {
            "name": "delete_artifact",
            "signature": "delete_artifact(self, path)",
            "doc": null
          }
        ],
        "fields": []
      }
    ],
    "assignments": []
  },
  {
    "path": "tests/test_km_watch.py",
    "doc": null,
    "imports": [
      "__future__",
      "os",
      "pathlib",
      "prometheus_client",
      "runpy",
      "sys"
    ],
    "functions": [
      {
        "name": "_metric_value",
        "signature": "_metric_value(name, labels)",
        "doc": null
      },
      {
        "name": "test_compute_fingerprints",
        "signature": "test_compute_fingerprints(tmp_path)",
        "doc": null
      },
      {
        "name": "test_diff_fingerprints_detects_changes",
        "signature": "test_diff_fingerprints_detects_changes()",
        "doc": null
      },
      {
        "name": "test_watch_metrics_increment",
        "signature": "test_watch_metrics_increment(tmp_path)",
        "doc": null
      }
    ],
    "classes": [],
    "assignments": [
      "_root_dir",
      "_bin_dir",
      "module",
      "compute_fingerprints",
      "diff_fingerprints"
    ]
  },
  {
    "path": "tests/test_lifecycle_cli.py",
    "doc": null,
    "imports": [
      "__future__",
      "gateway.lifecycle.cli",
      "json",
      "pathlib",
      "pytest"
    ],
    "functions": [
      {
        "name": "test_lifecycle_cli_json",
        "signature": "test_lifecycle_cli_json(tmp_path, capsys)",
        "doc": null
      },
      {
        "name": "test_lifecycle_cli_missing_file",
        "signature": "test_lifecycle_cli_missing_file(tmp_path, capsys)",
        "doc": null
      }
    ],
    "classes": [],
    "assignments": []
  },
  {
    "path": "tests/test_lifecycle_report.py",
    "doc": null,
    "imports": [
      "__future__",
      "datetime",
      "gateway.graph",
      "gateway.ingest.lifecycle",
      "gateway.ingest.pipeline",
      "json",
      "pathlib",
      "prometheus_client",
      "pytest",
      "typing"
    ],
    "functions": [
      {
        "name": "_ingestion_result",
        "signature": "_ingestion_result()",
        "doc": "Build a representative ingestion result for lifecycle reporting tests."
      },
      {
        "name": "test_write_lifecycle_report_without_graph",
        "signature": "test_write_lifecycle_report_without_graph(tmp_path, ingestion_result)",
        "doc": "Reports render correctly when graph enrichment is disabled."
      },
      {
        "name": "test_write_lifecycle_report_with_graph",
        "signature": "test_write_lifecycle_report_with_graph(tmp_path, ingestion_result)",
        "doc": "Graph enrichment populates isolated node information in the payload."
      }
    ],
    "classes": [
      {
        "name": "DummyGraphService",
        "bases": [],
        "doc": "Test double that returns pre-seeded orphan graph nodes.",
        "methods": [
          {
            "name": "__init__",
            "signature": "__init__(self, pages)",
            "doc": null
          },
          {
            "name": "list_orphan_nodes",
            "signature": "list_orphan_nodes(self)",
            "doc": "Yield nodes in pages for the requested label."
          }
        ],
        "fields": []
      }
    ],
    "assignments": []
  },
  {
    "path": "tests/test_mcp_recipes.py",
    "doc": null,
    "imports": [
      "__future__",
      "json",
      "pathlib",
      "pytest"
    ],
    "functions": [
      {
        "name": "test_snippets_are_valid_json",
        "signature": "test_snippets_are_valid_json(snippet)",
        "doc": null
      }
    ],
    "classes": [],
    "assignments": [
      "RECIPES"
    ]
  },
  {
    "path": "tests/test_mcp_smoke_recipes.py",
    "doc": null,
    "imports": [
      "__future__",
      "json",
      "pathlib",
      "pytest"
    ],
    "functions": [
      {
        "name": "_recipe_params",
        "signature": "_recipe_params()",
        "doc": null
      },
      {
        "name": "test_recipe_lines_are_valid_json",
        "signature": "test_recipe_lines_are_valid_json(line)",
        "doc": null
      }
    ],
    "classes": [],
    "assignments": [
      "RECIPES"
    ]
  },
  {
    "path": "tests/test_neo4j_writer.py",
    "doc": null,
    "imports": [
      "__future__",
      "gateway.ingest.artifacts",
      "gateway.ingest.neo4j_writer",
      "neo4j",
      "pathlib",
      "types",
      "typing"
    ],
    "functions": [
      {
        "name": "_make_writer",
        "signature": "_make_writer()",
        "doc": "Create a writer bound to a recording driver for inspection."
      },
      {
        "name": "test_sync_artifact_creates_domain_relationships",
        "signature": "test_sync_artifact_creates_domain_relationships()",
        "doc": "Artifacts trigger the expected Cypher commands and relationships."
      },
      {
        "name": "test_sync_artifact_merges_subsystem_edge_once",
        "signature": "test_sync_artifact_merges_subsystem_edge_once()",
        "doc": "Syncing an artifact does not duplicate the subsystem relationship."
      },
      {
        "name": "test_sync_chunks_links_chunk_to_artifact",
        "signature": "test_sync_chunks_links_chunk_to_artifact()",
        "doc": "Chunk synchronization creates chunk nodes and linking edges."
      }
    ],
    "classes": [
      {
        "name": "RecordingSession",
        "bases": [],
        "doc": "Stubbed session that records Cypher queries for assertions.",
        "methods": [
          {
            "name": "__init__",
            "signature": "__init__(self)",
            "doc": null
          },
          {
            "name": "run",
            "signature": "run(self, query)",
            "doc": null
          },
          {
            "name": "__enter__",
            "signature": "__enter__(self)",
            "doc": null
          },
          {
            "name": "__exit__",
            "signature": "__exit__(self, exc_type, exc, tb)",
            "doc": null
          }
        ],
        "fields": []
      },
      {
        "name": "RecordingDriver",
        "bases": [],
        "doc": "Stubbed driver that yields recording sessions.",
        "methods": [
          {
            "name": "__init__",
            "signature": "__init__(self)",
            "doc": null
          },
          {
            "name": "session",
            "signature": "session(self)",
            "doc": "Return a new recording session; database name is ignored."
          }
        ],
        "fields": []
      }
    ],
    "assignments": []
  },
  {
    "path": "tests/test_qdrant_writer.py",
    "doc": null,
    "imports": [
      "__future__",
      "gateway.ingest.artifacts",
      "gateway.ingest.qdrant_writer",
      "unittest"
    ],
    "functions": [
      {
        "name": "build_chunk",
        "signature": "build_chunk(path, text, metadata)",
        "doc": null
      },
      {
        "name": "test_ensure_collection_creates_when_missing",
        "signature": "test_ensure_collection_creates_when_missing()",
        "doc": null
      },
      {
        "name": "test_ensure_collection_noop_when_exists",
        "signature": "test_ensure_collection_noop_when_exists()",
        "doc": null
      },
      {
        "name": "test_upsert_chunks_builds_points",
        "signature": "test_upsert_chunks_builds_points()",
        "doc": null
      },
      {
        "name": "test_upsert_chunks_noop_on_empty",
        "signature": "test_upsert_chunks_noop_on_empty()",
        "doc": null
      }
    ],
    "classes": [
      {
        "name": "RecordingClient",
        "bases": [],
        "doc": null,
        "methods": [
          {
            "name": "__init__",
            "signature": "__init__(self)",
            "doc": null
          },
          {
            "name": "get_collection",
            "signature": "get_collection(self, name)",
            "doc": null
          },
          {
            "name": "recreate_collection",
            "signature": "recreate_collection(self, collection_name, vectors_config, optimizers_config)",
            "doc": null
          },
          {
            "name": "upsert",
            "signature": "upsert(self, collection_name, points)",
            "doc": null
          }
        ],
        "fields": []
      }
    ],
    "assignments": []
  },
  {
    "path": "tests/test_recipes_executor.py",
    "doc": null,
    "imports": [
      "__future__",
      "gateway.mcp.config",
      "gateway.recipes.executor",
      "gateway.recipes.models",
      "pathlib",
      "pytest",
      "types",
      "typing"
    ],
    "functions": [],
    "classes": [
      {
        "name": "FakeToolExecutor",
        "bases": [],
        "doc": null,
        "methods": [
          {
            "name": "__init__",
            "signature": "__init__(self, responses)",
            "doc": null
          }
        ],
        "fields": []
      }
    ],
    "assignments": []
  },
  {
    "path": "tests/test_release_scripts.py",
    "doc": null,
    "imports": [
      "__future__",
      "os",
      "pathlib",
      "subprocess"
    ],
    "functions": [
      {
        "name": "_env_with_venv",
        "signature": "_env_with_venv()",
        "doc": null
      },
      {
        "name": "test_build_wheel_script",
        "signature": "test_build_wheel_script(tmp_path)",
        "doc": null
      },
      {
        "name": "test_checksums_script",
        "signature": "test_checksums_script(tmp_path)",
        "doc": null
      },
      {
        "name": "test_generate_changelog",
        "signature": "test_generate_changelog(tmp_path)",
        "doc": null
      }
    ],
    "classes": [],
    "assignments": [
      "REPO_ROOT",
      "SCRIPTS_DIR"
    ]
  },
  {
    "path": "tests/test_scheduler.py",
    "doc": "Unit tests exercising the ingestion scheduler behaviour and metrics.",
    "imports": [
      "__future__",
      "apscheduler.triggers.cron",
      "apscheduler.triggers.interval",
      "collections.abc",
      "filelock",
      "gateway.config.settings",
      "gateway.ingest.pipeline",
      "gateway.scheduler",
      "pathlib",
      "prometheus_client",
      "pytest",
      "unittest"
    ],
    "functions": [
      {
        "name": "reset_cache",
        "signature": "reset_cache()",
        "doc": "Clear cached settings before and after each test."
      },
      {
        "name": "scheduler_settings",
        "signature": "scheduler_settings(tmp_path)",
        "doc": "Provide scheduler settings pointing at a temporary repo."
      },
      {
        "name": "make_scheduler",
        "signature": "make_scheduler(settings)",
        "doc": "Instantiate a scheduler with its APScheduler stubbed out."
      },
      {
        "name": "_metric_value",
        "signature": "_metric_value(name, labels)",
        "doc": "Fetch a Prometheus sample value with defaults for missing metrics."
      },
      {
        "name": "make_result",
        "signature": "make_result(head)",
        "doc": "Construct a minimal ingestion result for scheduler tests."
      },
      {
        "name": "test_scheduler_skips_when_repo_head_unchanged",
        "signature": "test_scheduler_skips_when_repo_head_unchanged(scheduler_settings)",
        "doc": "Scheduler skips when repository head hash matches the cached value."
      },
      {
        "name": "test_scheduler_runs_when_repo_head_changes",
        "signature": "test_scheduler_runs_when_repo_head_changes(scheduler_settings)",
        "doc": "Scheduler triggers ingestion when the repository head changes."
      },
      {
        "name": "test_scheduler_start_uses_interval_trigger",
        "signature": "test_scheduler_start_uses_interval_trigger(scheduler_settings)",
        "doc": "Schedulers without cron use the configured interval trigger."
      },
      {
        "name": "test_scheduler_start_uses_cron_trigger",
        "signature": "test_scheduler_start_uses_cron_trigger(tmp_path)",
        "doc": "Cron expressions configure a cron trigger instead of interval."
      },
      {
        "name": "test_scheduler_skips_when_lock_contended",
        "signature": "test_scheduler_skips_when_lock_contended(scheduler_settings)",
        "doc": "Lock contention causes the scheduler to skip runs and record metrics."
      },
      {
        "name": "test_scheduler_requires_maintainer_token",
        "signature": "test_scheduler_requires_maintainer_token(tmp_path)",
        "doc": "Schedulers skip setup when auth is enabled without a maintainer token."
      }
    ],
    "classes": [],
    "assignments": []
  },
  {
    "path": "tests/test_search_api.py",
    "doc": null,
    "imports": [
      "__future__",
      "datetime",
      "fastapi.testclient",
      "gateway.api.app",
      "gateway.config.settings",
      "gateway.search.service",
      "json",
      "pathlib",
      "pytest"
    ],
    "functions": [
      {
        "name": "test_search_endpoint_returns_results",
        "signature": "test_search_endpoint_returns_results(monkeypatch, tmp_path)",
        "doc": null
      },
      {
        "name": "test_search_reuses_incoming_request_id",
        "signature": "test_search_reuses_incoming_request_id(monkeypatch, tmp_path)",
        "doc": null
      },
      {
        "name": "test_search_requires_reader_token",
        "signature": "test_search_requires_reader_token(monkeypatch, tmp_path)",
        "doc": null
      },
      {
        "name": "test_search_allows_maintainer_token",
        "signature": "test_search_allows_maintainer_token(monkeypatch, tmp_path)",
        "doc": null
      },
      {
        "name": "test_search_feedback_logged",
        "signature": "test_search_feedback_logged(monkeypatch, tmp_path)",
        "doc": null
      },
      {
        "name": "test_search_filters_passed_to_service",
        "signature": "test_search_filters_passed_to_service(monkeypatch, tmp_path)",
        "doc": null
      },
      {
        "name": "test_search_filters_invalid_type",
        "signature": "test_search_filters_invalid_type(monkeypatch, tmp_path)",
        "doc": null
      },
      {
        "name": "test_search_filters_invalid_namespaces",
        "signature": "test_search_filters_invalid_namespaces(monkeypatch, tmp_path)",
        "doc": null
      },
      {
        "name": "test_search_filters_invalid_updated_after",
        "signature": "test_search_filters_invalid_updated_after(monkeypatch, tmp_path)",
        "doc": null
      },
      {
        "name": "test_search_filters_invalid_max_age",
        "signature": "test_search_filters_invalid_max_age(monkeypatch, tmp_path)",
        "doc": null
      },
      {
        "name": "test_search_weights_endpoint",
        "signature": "test_search_weights_endpoint(monkeypatch, tmp_path)",
        "doc": null
      }
    ],
    "classes": [
      {
        "name": "DummySearchService",
        "bases": [],
        "doc": null,
        "methods": [
          {
            "name": "__init__",
            "signature": "__init__(self)",
            "doc": null
          },
          {
            "name": "search",
            "signature": "search(self)",
            "doc": null
          }
        ],
        "fields": []
      }
    ],
    "assignments": []
  },
  {
    "path": "tests/test_search_cli_show_weights.py",
    "doc": null,
    "imports": [
      "__future__",
      "gateway.config.settings",
      "gateway.search",
      "pathlib",
      "pytest"
    ],
    "functions": [
      {
        "name": "clear_settings_cache",
        "signature": "clear_settings_cache(monkeypatch, tmp_path)",
        "doc": null
      },
      {
        "name": "test_show_weights_command",
        "signature": "test_show_weights_command(capsys)",
        "doc": null
      }
    ],
    "classes": [],
    "assignments": []
  },
  {
    "path": "tests/test_search_evaluation.py",
    "doc": null,
    "imports": [
      "__future__",
      "gateway.search.cli",
      "gateway.search.dataset",
      "gateway.search.evaluation",
      "json",
      "math",
      "pathlib",
      "pytest"
    ],
    "functions": [
      {
        "name": "test_evaluate_model",
        "signature": "test_evaluate_model(tmp_path)",
        "doc": null
      },
      {
        "name": "test_evaluate_cli",
        "signature": "test_evaluate_cli(tmp_path, monkeypatch, capsys)",
        "doc": null
      },
      {
        "name": "test_evaluate_model_with_empty_dataset",
        "signature": "test_evaluate_model_with_empty_dataset(tmp_path)",
        "doc": null
      }
    ],
    "classes": [],
    "assignments": []
  },
  {
    "path": "tests/test_search_exporter.py",
    "doc": null,
    "imports": [
      "__future__",
      "csv",
      "gateway.config.settings",
      "gateway.search.cli",
      "gateway.search.exporter",
      "gateway.search.trainer",
      "json",
      "pathlib",
      "pytest"
    ],
    "functions": [
      {
        "name": "_write_events",
        "signature": "_write_events(path, events)",
        "doc": null
      },
      {
        "name": "_sample_event",
        "signature": "_sample_event(request_id, vote)",
        "doc": null
      },
      {
        "name": "test_export_training_dataset_csv",
        "signature": "test_export_training_dataset_csv(tmp_path)",
        "doc": null
      },
      {
        "name": "test_export_training_data_cli",
        "signature": "test_export_training_data_cli(tmp_path, monkeypatch)",
        "doc": null
      },
      {
        "name": "test_train_model_from_dataset",
        "signature": "test_train_model_from_dataset(tmp_path)",
        "doc": null
      },
      {
        "name": "test_train_model_cli",
        "signature": "test_train_model_cli(tmp_path, monkeypatch)",
        "doc": null
      }
    ],
    "classes": [],
    "assignments": []
  },
  {
    "path": "tests/test_search_maintenance.py",
    "doc": "Tests for the search maintenance helpers.",
    "imports": [
      "__future__",
      "datetime",
      "gateway.search.maintenance",
      "json",
      "os",
      "pathlib",
      "pytest",
      "stat"
    ],
    "functions": [
      {
        "name": "_write_events",
        "signature": "_write_events(path, requests)",
        "doc": "Write JSON lines representing feedback events for the supplied requests."
      },
      {
        "name": "test_prune_feedback_log_parses_various_timestamp_formats",
        "signature": "test_prune_feedback_log_parses_various_timestamp_formats(tmp_path)",
        "doc": "Ensure prune handles numeric, Z-suffixed, and missing timestamps."
      },
      {
        "name": "test_prune_feedback_log_by_age",
        "signature": "test_prune_feedback_log_by_age(tmp_path)",
        "doc": "Retains only entries newer than the configured age threshold."
      },
      {
        "name": "test_prune_feedback_log_missing_file",
        "signature": "test_prune_feedback_log_missing_file(tmp_path)",
        "doc": "Raises if the feedback log file is absent."
      },
      {
        "name": "test_prune_feedback_log_requires_limit",
        "signature": "test_prune_feedback_log_requires_limit(tmp_path)",
        "doc": "Rejects calls without an age or request limit configured."
      },
      {
        "name": "test_prune_feedback_log_empty_file",
        "signature": "test_prune_feedback_log_empty_file(tmp_path)",
        "doc": "Returns zeroed stats when the log contains no events."
      },
      {
        "name": "test_prune_feedback_log_guard_when_pruning_everything",
        "signature": "test_prune_feedback_log_guard_when_pruning_everything(tmp_path, caplog)",
        "doc": "Leaves the log intact when filters would drop every request."
      },
      {
        "name": "test_prune_feedback_log_max_requests_prefers_newest",
        "signature": "test_prune_feedback_log_max_requests_prefers_newest(tmp_path)",
        "doc": "Keeps only the newest requests when enforcing a max count."
      },
      {
        "name": "test_redact_dataset_csv",
        "signature": "test_redact_dataset_csv(tmp_path)",
        "doc": "Redacts populated CSV fields for queries, contexts, and notes."
      },
      {
        "name": "test_redact_dataset_csv_handles_missing_and_blank_fields",
        "signature": "test_redact_dataset_csv_handles_missing_and_blank_fields(tmp_path)",
        "doc": "Leaves missing or blank CSV fields untouched while redacting non-empty ones."
      },
      {
        "name": "test_redact_dataset_jsonl",
        "signature": "test_redact_dataset_jsonl(tmp_path)",
        "doc": "Redacts JSONL query and context fields when toggled."
      },
      {
        "name": "test_redact_dataset_jsonl_handles_missing_and_blank_fields",
        "signature": "test_redact_dataset_jsonl_handles_missing_and_blank_fields(tmp_path)",
        "doc": "Leaves absent or empty JSONL fields untouched while redacting populated ones."
      },
      {
        "name": "test_redact_dataset_missing_file",
        "signature": "test_redact_dataset_missing_file(tmp_path)",
        "doc": "Raises if the target dataset file is absent."
      },
      {
        "name": "test_redact_dataset_unsupported_suffix",
        "signature": "test_redact_dataset_unsupported_suffix(tmp_path)",
        "doc": "Rejects unsupported dataset extensions."
      },
      {
        "name": "test_redact_dataset_output_path_copies_metadata",
        "signature": "test_redact_dataset_output_path_copies_metadata(tmp_path)",
        "doc": "Preserves metadata when writing to an alternate output path."
      },
      {
        "name": "test_redact_dataset_jsonl_handles_blank_lines",
        "signature": "test_redact_dataset_jsonl_handles_blank_lines(tmp_path)",
        "doc": "Preserves blank lines in JSONL datasets while redacting content."
      }
    ],
    "classes": [],
    "assignments": []
  },
  {
    "path": "tests/test_search_profiles.py",
    "doc": null,
    "imports": [
      "__future__",
      "gateway.config.settings",
      "pytest"
    ],
    "functions": [
      {
        "name": "clear_weight_env",
        "signature": "clear_weight_env(monkeypatch)",
        "doc": null
      },
      {
        "name": "test_resolved_search_weights_default",
        "signature": "test_resolved_search_weights_default()",
        "doc": null
      },
      {
        "name": "test_resolved_search_weights_profile_selection",
        "signature": "test_resolved_search_weights_profile_selection(monkeypatch)",
        "doc": null
      },
      {
        "name": "test_resolved_search_weights_overrides",
        "signature": "test_resolved_search_weights_overrides(monkeypatch)",
        "doc": null
      }
    ],
    "classes": [],
    "assignments": []
  },
  {
    "path": "tests/test_search_service.py",
    "doc": null,
    "imports": [
      "__future__",
      "collections.abc",
      "datetime",
      "gateway.graph.service",
      "gateway.search",
      "gateway.search.trainer",
      "prometheus_client",
      "pytest",
      "typing"
    ],
    "functions": [
      {
        "name": "_metric_value",
        "signature": "_metric_value(name, labels)",
        "doc": null
      },
      {
        "name": "sample_points",
        "signature": "sample_points()",
        "doc": null
      },
      {
        "name": "graph_response",
        "signature": "graph_response()",
        "doc": null
      },
      {
        "name": "test_search_service_enriches_with_graph",
        "signature": "test_search_service_enriches_with_graph(sample_points, graph_response)",
        "doc": null
      },
      {
        "name": "test_search_service_handles_missing_graph",
        "signature": "test_search_service_handles_missing_graph(sample_points)",
        "doc": null
      },
      {
        "name": "test_search_hnsw_search_params",
        "signature": "test_search_hnsw_search_params(sample_points)",
        "doc": null
      },
      {
        "name": "test_lexical_score_affects_ranking",
        "signature": "test_lexical_score_affects_ranking()",
        "doc": null
      },
      {
        "name": "test_search_service_orders_by_adjusted_score",
        "signature": "test_search_service_orders_by_adjusted_score()",
        "doc": null
      },
      {
        "name": "test_search_service_caches_graph_lookups",
        "signature": "test_search_service_caches_graph_lookups(sample_points, graph_response)",
        "doc": null
      },
      {
        "name": "test_search_service_filters_artifact_types",
        "signature": "test_search_service_filters_artifact_types()",
        "doc": null
      },
      {
        "name": "test_search_service_filters_namespaces",
        "signature": "test_search_service_filters_namespaces()",
        "doc": null
      },
      {
        "name": "test_search_service_filters_tags",
        "signature": "test_search_service_filters_tags()",
        "doc": null
      },
      {
        "name": "test_search_service_filters_recency_updated_after",
        "signature": "test_search_service_filters_recency_updated_after()",
        "doc": null
      },
      {
        "name": "test_search_service_filters_recency_max_age_days",
        "signature": "test_search_service_filters_recency_max_age_days()",
        "doc": null
      },
      {
        "name": "test_search_service_filters_subsystem_via_graph",
        "signature": "test_search_service_filters_subsystem_via_graph(graph_response)",
        "doc": null
      },
      {
        "name": "test_search_service_ml_model_reorders_results",
        "signature": "test_search_service_ml_model_reorders_results()",
        "doc": null
      }
    ],
    "classes": [
      {
        "name": "FakeEmbedder",
        "bases": [],
        "doc": null,
        "methods": [
          {
            "name": "encode",
            "signature": "encode(self, texts)",
            "doc": null
          }
        ],
        "fields": []
      },
      {
        "name": "FakePoint",
        "bases": [],
        "doc": null,
        "methods": [
          {
            "name": "__init__",
            "signature": "__init__(self, payload, score)",
            "doc": null
          }
        ],
        "fields": []
      },
      {
        "name": "FakeQdrantClient",
        "bases": [],
        "doc": null,
        "methods": [
          {
            "name": "__init__",
            "signature": "__init__(self, points)",
            "doc": null
          },
          {
            "name": "search",
            "signature": "search(self)",
            "doc": null
          }
        ],
        "fields": []
      },
      {
        "name": "DummyGraphService",
        "bases": [
          "GraphService"
        ],
        "doc": null,
        "methods": [
          {
            "name": "__init__",
            "signature": "__init__(self, response)",
            "doc": null
          },
          {
            "name": "get_node",
            "signature": "get_node(self, node_id)",
            "doc": null
          },
          {
            "name": "get_subsystem",
            "signature": "get_subsystem(self)",
            "doc": null
          },
          {
            "name": "search",
            "signature": "search(self, term)",
            "doc": null
          },
          {
            "name": "run_cypher",
            "signature": "run_cypher(self, query, parameters)",
            "doc": null
          },
          {
            "name": "shortest_path_depth",
            "signature": "shortest_path_depth(self, node_id)",
            "doc": null
          }
        ],
        "fields": []
      },
      {
        "name": "MapGraphService",
        "bases": [
          "GraphService"
        ],
        "doc": null,
        "methods": [
          {
            "name": "__init__",
            "signature": "__init__(self, data)",
            "doc": null
          },
          {
            "name": "get_node",
            "signature": "get_node(self, node_id)",
            "doc": null
          },
          {
            "name": "get_subsystem",
            "signature": "get_subsystem(self)",
            "doc": null
          },
          {
            "name": "search",
            "signature": "search(self, term)",
            "doc": null
          },
          {
            "name": "run_cypher",
            "signature": "run_cypher(self, query, parameters)",
            "doc": null
          },
          {
            "name": "shortest_path_depth",
            "signature": "shortest_path_depth(self, node_id)",
            "doc": null
          }
        ],
        "fields": []
      },
      {
        "name": "CountingGraphService",
        "bases": [
          "GraphService"
        ],
        "doc": null,
        "methods": [
          {
            "name": "__init__",
            "signature": "__init__(self, response, depth)",
            "doc": null
          },
          {
            "name": "get_node",
            "signature": "get_node(self, node_id)",
            "doc": null
          },
          {
            "name": "shortest_path_depth",
            "signature": "shortest_path_depth(self, node_id)",
            "doc": null
          },
          {
            "name": "get_subsystem",
            "signature": "get_subsystem(self)",
            "doc": null
          },
          {
            "name": "search",
            "signature": "search(self, term)",
            "doc": null
          },
          {
            "name": "run_cypher",
            "signature": "run_cypher(self, query, parameters)",
            "doc": null
          }
        ],
        "fields": []
      }
    ],
    "assignments": []
  },
  {
    "path": "tests/test_settings_defaults.py",
    "doc": null,
    "imports": [
      "__future__",
      "gateway.config.settings",
      "pytest"
    ],
    "functions": [
      {
        "name": "test_neo4j_database_defaults_to_knowledge",
        "signature": "test_neo4j_database_defaults_to_knowledge(monkeypatch)",
        "doc": null
      },
      {
        "name": "test_neo4j_auth_enabled_defaults_true",
        "signature": "test_neo4j_auth_enabled_defaults_true(monkeypatch)",
        "doc": null
      },
      {
        "name": "test_auth_enabled_defaults_true",
        "signature": "test_auth_enabled_defaults_true(monkeypatch)",
        "doc": null
      },
      {
        "name": "test_neo4j_password_defaults_empty",
        "signature": "test_neo4j_password_defaults_empty(monkeypatch)",
        "doc": null
      }
    ],
    "classes": [],
    "assignments": []
  },
  {
    "path": "tests/test_tracing.py",
    "doc": null,
    "imports": [
      "__future__",
      "gateway.api.app",
      "gateway.config.settings",
      "gateway.observability",
      "gateway.observability.tracing",
      "opentelemetry.exporter.otlp.proto.http.trace_exporter",
      "opentelemetry.sdk.trace",
      "opentelemetry.sdk.trace.export",
      "pytest"
    ],
    "functions": [
      {
        "name": "test_tracing_disabled_by_default",
        "signature": "test_tracing_disabled_by_default(monkeypatch)",
        "doc": null
      },
      {
        "name": "test_tracing_enabled_instruments_app",
        "signature": "test_tracing_enabled_instruments_app(monkeypatch)",
        "doc": null
      },
      {
        "name": "test_tracing_uses_otlp_exporter",
        "signature": "test_tracing_uses_otlp_exporter(monkeypatch)",
        "doc": null
      },
      {
        "name": "test_tracing_console_fallback",
        "signature": "test_tracing_console_fallback(monkeypatch)",
        "doc": null
      }
    ],
    "classes": [],
    "assignments": []
  },
  {
    "path": "tests/test_ui_routes.py",
    "doc": null,
    "imports": [
      "__future__",
      "fastapi.testclient",
      "gateway.api.app",
      "gateway.config.settings",
      "pathlib",
      "prometheus_client",
      "pytest"
    ],
    "functions": [
      {
        "name": "_reset_settings",
        "signature": "_reset_settings(tmp_path)",
        "doc": "Clear cached settings and ensure the state directory exists for tests."
      },
      {
        "name": "test_ui_landing_served",
        "signature": "test_ui_landing_served(tmp_path, monkeypatch)",
        "doc": "The landing page renders successfully and increments the landing metric."
      },
      {
        "name": "test_ui_search_view",
        "signature": "test_ui_search_view(tmp_path, monkeypatch)",
        "doc": "The search view renders and increments the search metric."
      },
      {
        "name": "test_ui_subsystems_view",
        "signature": "test_ui_subsystems_view(tmp_path, monkeypatch)",
        "doc": "The subsystems view renders and increments the subsystem metric."
      },
      {
        "name": "test_ui_lifecycle_download",
        "signature": "test_ui_lifecycle_download(tmp_path, monkeypatch)",
        "doc": "Lifecycle report downloads are returned and recorded in metrics."
      },
      {
        "name": "test_ui_events_endpoint",
        "signature": "test_ui_events_endpoint(tmp_path, monkeypatch)",
        "doc": "Custom UI events are accepted and reflected in Prometheus metrics."
      }
    ],
    "classes": [],
    "assignments": []
  }
]