# Deployment & Hardening Guide

This guide summarises the hardened container runtime introduced in WP-006 and outlines deployment patterns for Docker Compose and Kubernetes.

## Service Topology

The Duskmantle stack now runs each dependency in its own container:

- **Gateway API** (`duskmantle/km`): FastAPI + schedulers, runs as the dedicated `km` user (UID/GID 1000) with `/opt/knowledge/var` mounted read/write.
- **Qdrant** (`qdrant/qdrant`): Vector index, persists under `compose/config/qdrant` and exposes HTTP on `6333/tcp` within the overlay network.
- **Neo4j** (`neo4j`): Graph database, persists under `compose/config/neo4j` and exposes Bolt on `7687/tcp` within the overlay network.

Only the gateway container publishes a host port (`8000/tcp`). Internal traffic stays on the private compose network (`duskmantle-internal`) or the equivalent Kubernetes namespace network.

## Docker Compose

`bin/km-bootstrap` generates the following layout under `.duskmantle/`:

```
.duskmantle/
├── compose/
│   ├── docker-compose.yml
│   ├── gateway.env -> ../secrets.env
│   └── config/
│       ├── gateway/
│       ├── neo4j/
│       └── qdrant/
├── data/                # mounted to /workspace/repo
└── secrets.env          # reader token, maintainer token, Neo4j password
```

Launch the stack with:

```bash
bin/km-bootstrap               # first run – pulls images + generates secrets
bin/km-run --detach             # subsequent starts, honours KM_COMPOSE_* overrides
```

Key environment overrides:

| Variable | Purpose |
|----------|---------|
| `KM_IMAGE` | Gateway API image tag (default `ghcr.io/tachyon-beep/duskmantle-km`). |
| `KM_QDRANT_IMAGE` / `KM_NEO4J_IMAGE` | Override the dependency images if you pin to internal registries. |
| `KM_COMPOSE_DIR` | Relocate compose assets (defaults to `.duskmantle/compose`). |
| `KM_COMPOSE_PROJECT` | Compose project name (used as container prefix + network). |

### Compose Hardening Checklist

- Keep `gateway.env` (symlink to `.duskmantle/secrets.env`) restricted to trusted operators (`chmod 600`).
- Enable TLS termination (Traefik, Nginx, Envoy) in front of port `8000`; only expose maintainer-only endpoints (`/metrics`, `/graph/cypher`) behind auth.
- If Qdrant/Neo4j must be reachable from other hosts, add explicit firewall rules rather than exposing compose ports globally.
- For rootless Docker hosts, set `KM_EXPECTED_UID` to match the remapped UID so the entrypoint can warn about privilege drift.

## Kubernetes

Run the gateway as a Deployment with the following security context:

```yaml
spec:
  template:
    spec:
      securityContext:
        runAsUser: 1000
        runAsGroup: 1000
        fsGroup: 1000
        seccompProfile:
          type: RuntimeDefault
      containers:
        - name: gateway
          image: ghcr.io/tachyon-beep/duskmantle-km:v1.1.0
          securityContext:
            allowPrivilegeEscalation: false
            capabilities:
              drop: ["ALL"]
          ports:
            - containerPort: 8000
          envFrom:
            - secretRef: { name: gateway-secrets }
          volumeMounts:
            - name: gateway-state
              mountPath: /opt/knowledge/var
      volumes:
        - name: gateway-state
          persistentVolumeClaim:
            claimName: gateway-state-pvc
```

Provision Qdrant and Neo4j using their upstream Helm charts or Deployments. The gateway needs the following environment variables to find them:

```yaml
KM_QDRANT_URL=http://qdrant.default.svc.cluster.local:6333
KM_NEO4J_URI=bolt://neo4j.default.svc.cluster.local:7687
KM_NEO4J_PASSWORD=<from secret>
```

Mount the same secret into the Neo4j pod as `NEO4J_AUTH=neo4j/<password>` so both services stay in sync.

## Secrets Management

- Store `.duskmantle/secrets.env` (or the Kubernetes Secret) in your vault/secret manager. It contains the reader token, maintainer token, and Neo4j password.
- Rotate credentials with `bin/km-rotate-neo4j-password` (compose) or by updating the Kubernetes Secret followed by restarting the Neo4j + gateway Deployments.
- Never check secrets into version control. Add `.duskmantle/secrets.env` to your global ignore rules.

## Non-root Runtime Validation

Use the smoke test to confirm the hardened defaults:

```bash
./infra/smoke-test.sh duskmantle/km:dev
```

The script builds the gateway image, starts the compose stack, verifies the gateway runs as UID 1000, exercises ingest, and confirms Neo4j requires the generated password.

## Network Policy Recommendations

- Compose: rely on the autogenerated `duskmantle-internal` network and avoid `ports:` on Qdrant/Neo4j unless absolutely required.
- Kubernetes: add NetworkPolicies/Calico policies that permit gateway→Neo4j/Qdrant traffic but deny ingress directly to those pods from untrusted namespaces.
- Expose `/metrics` via a sidecar/ServiceMonitor rather than opening the API publicly when auth is enabled.

## File-System Permissions

- Gateway: `/opt/knowledge/var` must be writable by UID/GID 1000. Other paths remain read-only (the image ships with an explicit `tmpfs` mount for `/tmp` in compose).
- Qdrant: ensure the storage directory is owned by UID 1000 (`qdrant` image default).
- Neo4j: ensure the PVC/host path is writable by UID 7474 (the official image default). When using hostPath volumes, pre-create directories with `chown 7474:7474`.

## Troubleshooting

- Gateway fails to start with `KM_NEO4J_PASSWORD must be provided`: populate the password in `secrets.env`/Kubernetes Secret and restart.
- Compose health check loops on Neo4j: confirm the auth file under `compose/config/neo4j/data/dbms` was removed before restarting with a new password.
- `bin/km-run` complains about missing `gateway.env`: re-run `bin/km-bootstrap` or copy `infra/examples/gateway.env.sample` and supply values manually.

For additional operational guidance see `docs/OPERATIONS.md` and `docs/OBSERVABILITY_GUIDE.md`.
