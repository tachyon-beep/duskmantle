{
  "gateway/__init__.py": {
    "doc": "Core package for the Duskmantle knowledge gateway.",
    "imports": {
      "external": [
        "__future__"
      ],
      "internal": []
    },
    "classes": [],
    "functions": [
      {
        "name": "get_version",
        "signature": "()",
        "is_async": false,
        "doc": "Return the current package version."
      }
    ],
    "constants": []
  },
  "gateway/__main__.py": {
    "doc": "Console entry point that launches the FastAPI application.",
    "imports": {
      "external": [
        "__future__",
        "uvicorn"
      ],
      "internal": []
    },
    "classes": [],
    "functions": [
      {
        "name": "main",
        "signature": "()",
        "is_async": false,
        "doc": "Run the gateway API using Uvicorn."
      }
    ],
    "constants": []
  },
  "gateway/api/__init__.py": {
    "doc": "API layer for the knowledge gateway.",
    "imports": {
      "external": [],
      "internal": []
    },
    "classes": [],
    "functions": [],
    "constants": []
  },
  "gateway/api/app.py": {
    "doc": "Primary FastAPI application wiring for the knowledge gateway.",
    "imports": {
      "external": [
        "__future__",
        "apscheduler",
        "asyncio",
        "collections",
        "contextlib",
        "fastapi",
        "json",
        "logging",
        "neo4j",
        "qdrant_client",
        "slowapi",
        "time",
        "typing",
        "uuid"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [],
    "functions": [
      {
        "name": "_validate_auth_settings",
        "signature": "(settings)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_log_startup_configuration",
        "signature": "(settings)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_build_lifespan",
        "signature": "(settings)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_configure_rate_limits",
        "signature": "(app, settings)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_init_feedback_store",
        "signature": "(settings)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_load_search_model",
        "signature": "(settings)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_initialise_graph_manager",
        "signature": "(manager, settings)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_initialise_qdrant_manager",
        "signature": "(manager)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_dependency_heartbeat_loop",
        "signature": "(app, interval)",
        "is_async": true,
        "doc": null
      },
      {
        "name": "_verify_graph_database",
        "signature": "(driver, database)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_ensure_graph_database",
        "signature": "(settings)",
        "is_async": false,
        "doc": "Ensure the configured Neo4j database exists, creating it if missing."
      },
      {
        "name": "_run_graph_auto_migration",
        "signature": "(driver, database)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_fetch_pending_migrations",
        "signature": "(runner)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_log_migration_plan",
        "signature": "(pending)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_log_migration_completion",
        "signature": "(pending)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_set_migration_metrics",
        "signature": "(status, timestamp)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "create_app",
        "signature": "()",
        "is_async": false,
        "doc": "Create the FastAPI application instance."
      },
      {
        "name": "_rate_limit_handler",
        "signature": "(_request, exc)",
        "is_async": false,
        "doc": null
      }
    ],
    "constants": [
      {
        "targets": [
          "DEPENDENCY_HEARTBEAT_INTERVAL_SECONDS"
        ],
        "value": "30.0"
      }
    ]
  },
  "gateway/api/auth.py": {
    "doc": "Authentication dependencies used across the FastAPI surface.",
    "imports": {
      "external": [
        "__future__",
        "collections",
        "fastapi"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [],
    "functions": [
      {
        "name": "require_scope",
        "signature": "(scope)",
        "is_async": false,
        "doc": "Return a dependency enforcing the given scope."
      },
      {
        "name": "_allowed_tokens_for_scope",
        "signature": "(settings, scope)",
        "is_async": false,
        "doc": null
      }
    ],
    "constants": []
  },
  "gateway/api/connections.py": {
    "doc": "Connection managers for external services (Neo4j and Qdrant).",
    "imports": {
      "external": [
        "__future__",
        "contextlib",
        "dataclasses",
        "logging",
        "neo4j",
        "qdrant_client",
        "threading",
        "time"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [
      {
        "name": "DependencyStatus",
        "bases": [],
        "methods": [],
        "doc": "Serializable snapshot of an external dependency."
      },
      {
        "name": "Neo4jConnectionManager",
        "bases": [],
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, settings, log=None)",
            "is_async": false
          },
          {
            "name": "revision",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "describe",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "get_write_driver",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "get_readonly_driver",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "mark_failure",
            "signature": "(self, exc=None)",
            "is_async": false
          },
          {
            "name": "heartbeat",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "_create_driver",
            "signature": "(self, uri, user, password)",
            "is_async": false
          },
          {
            "name": "_record_success",
            "signature": "(self)",
            "is_async": false
          }
        ],
        "doc": "Lazy initialisation and health tracking for Neo4j drivers."
      },
      {
        "name": "QdrantConnectionManager",
        "bases": [],
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, settings, log=None)",
            "is_async": false
          },
          {
            "name": "revision",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "describe",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "get_client",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "mark_failure",
            "signature": "(self, exc=None)",
            "is_async": false
          },
          {
            "name": "heartbeat",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "_create_client",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "_record_success",
            "signature": "(self)",
            "is_async": false
          }
        ],
        "doc": "Lazy initialisation and health tracking for Qdrant clients."
      }
    ],
    "functions": [],
    "constants": [
      {
        "targets": [
          "GRAPH_DRIVER_FACTORY"
        ],
        "value": "GraphDatabase.driver"
      },
      {
        "targets": [
          "QDRANT_CLIENT_FACTORY"
        ],
        "value": "QdrantClient"
      }
    ]
  },
  "gateway/api/constants.py": {
    "doc": "Shared API constants.",
    "imports": {
      "external": [
        "__future__"
      ],
      "internal": []
    },
    "classes": [],
    "functions": [],
    "constants": [
      {
        "targets": [
          "API_V1_PREFIX"
        ],
        "value": "'/api/v1'"
      }
    ]
  },
  "gateway/api/dependencies.py": {
    "doc": "FastAPI dependency helpers for the gateway application.",
    "imports": {
      "external": [
        "__future__",
        "fastapi",
        "logging",
        "slowapi"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [],
    "functions": [
      {
        "name": "get_app_settings",
        "signature": "(request)",
        "is_async": false,
        "doc": "Return the application settings attached to the FastAPI app."
      },
      {
        "name": "get_limiter",
        "signature": "(request)",
        "is_async": false,
        "doc": "Return the rate limiter configured on the FastAPI app."
      },
      {
        "name": "get_search_model",
        "signature": "(request)",
        "is_async": false,
        "doc": "Return the cached search ranking model from application state."
      },
      {
        "name": "get_graph_service_dependency",
        "signature": "(request)",
        "is_async": false,
        "doc": "Return a memoised graph service bound to the current FastAPI app."
      },
      {
        "name": "get_search_service_dependency",
        "signature": "(request)",
        "is_async": false,
        "doc": "Construct (and cache) the hybrid search service for the application."
      },
      {
        "name": "get_feedback_store",
        "signature": "(request)",
        "is_async": false,
        "doc": "Return the configured search feedback store, if any."
      }
    ],
    "constants": []
  },
  "gateway/api/routes/__init__.py": {
    "doc": "FastAPI route modules for the gateway application.",
    "imports": {
      "external": [
        "graph",
        "health",
        "reporting",
        "search"
      ],
      "internal": []
    },
    "classes": [],
    "functions": [],
    "constants": []
  },
  "gateway/api/routes/graph.py": {
    "doc": "Graph API routes.",
    "imports": {
      "external": [
        "__future__",
        "fastapi",
        "slowapi",
        "typing"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [],
    "functions": [
      {
        "name": "create_router",
        "signature": "(limiter, metrics_limit)",
        "is_async": false,
        "doc": "Create an API router exposing graph endpoints with shared rate limits."
      }
    ],
    "constants": []
  },
  "gateway/api/routes/health.py": {
    "doc": "Health and observability endpoints.",
    "imports": {
      "external": [
        "__future__",
        "contextlib",
        "fastapi",
        "json",
        "prometheus_client",
        "slowapi",
        "sqlite3",
        "time",
        "typing"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [],
    "functions": [
      {
        "name": "create_router",
        "signature": "(limiter, metrics_limit)",
        "is_async": false,
        "doc": "Wire up health, readiness, and metrics endpoints."
      },
      {
        "name": "build_health_report",
        "signature": "(app, settings)",
        "is_async": false,
        "doc": "Assemble the health payload consumed by `/healthz`."
      },
      {
        "name": "_coverage_health",
        "signature": "(settings)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_audit_health",
        "signature": "(settings)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_scheduler_health",
        "signature": "(app, settings)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_graph_health",
        "signature": "(app, settings)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_qdrant_health",
        "signature": "(app, settings)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_dependency_health",
        "signature": "(manager)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_backup_health",
        "signature": "(app, settings)",
        "is_async": false,
        "doc": null
      }
    ],
    "constants": []
  },
  "gateway/api/routes/reporting.py": {
    "doc": "Observability and reporting routes.",
    "imports": {
      "external": [
        "__future__",
        "fastapi",
        "json",
        "logging",
        "pathlib",
        "slowapi",
        "typing"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [],
    "functions": [
      {
        "name": "create_router",
        "signature": "(limiter)",
        "is_async": false,
        "doc": "Expose reporting and audit endpoints protected by maintainer auth."
      }
    ],
    "constants": []
  },
  "gateway/api/routes/search.py": {
    "doc": "Search API routes.",
    "imports": {
      "external": [
        "__future__",
        "collections",
        "datetime",
        "fastapi",
        "logging",
        "qdrant_client",
        "slowapi",
        "typing",
        "uuid"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [],
    "functions": [
      {
        "name": "create_router",
        "signature": "(limiter, metrics_limit)",
        "is_async": false,
        "doc": "Return an API router for the search endpoints with shared rate limits."
      },
      {
        "name": "_parse_iso8601_to_utc",
        "signature": "(value)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_has_vote",
        "signature": "(mapping)",
        "is_async": false,
        "doc": null
      }
    ],
    "constants": []
  },
  "gateway/backup/__init__.py": {
    "doc": "Backup utilities for the knowledge gateway.",
    "imports": {
      "external": [
        "exceptions",
        "service"
      ],
      "internal": []
    },
    "classes": [],
    "functions": [],
    "constants": []
  },
  "gateway/backup/exceptions.py": {
    "doc": "Custom exceptions for gateway backup operations.",
    "imports": {
      "external": [
        "__future__"
      ],
      "internal": []
    },
    "classes": [
      {
        "name": "BackupExecutionError",
        "bases": [
          "RuntimeError"
        ],
        "methods": [],
        "doc": "Raised when the backup helper fails to produce an archive."
      }
    ],
    "functions": [],
    "constants": []
  },
  "gateway/backup/service.py": {
    "doc": "Helper functions for orchestrating state backups.",
    "imports": {
      "external": [
        "__future__",
        "collections",
        "contextlib",
        "exceptions",
        "os",
        "pathlib",
        "re",
        "subprocess"
      ],
      "internal": []
    },
    "classes": [
      {
        "name": "BackupResult",
        "bases": [
          "dict"
        ],
        "methods": [],
        "doc": "Simple mapping describing the archive produced by a backup run."
      }
    ],
    "functions": [
      {
        "name": "default_backup_destination",
        "signature": "(state_path)",
        "is_async": false,
        "doc": "Return the default directory for storing backup archives."
      },
      {
        "name": "is_backup_archive",
        "signature": "(path)",
        "is_async": false,
        "doc": "Return ``True`` when ``path`` matches the managed backup filename pattern."
      },
      {
        "name": "run_backup",
        "signature": "(state_path, script_path, destination_path=None, extra_env=None)",
        "is_async": false,
        "doc": "Execute the backup helper synchronously and return archive metadata."
      },
      {
        "name": "_parse_archive_path",
        "signature": "(output)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_default_backup_script",
        "signature": "()",
        "is_async": false,
        "doc": null
      }
    ],
    "constants": [
      {
        "targets": [
          "_BACKUP_DONE_PATTERN"
        ],
        "value": "re.compile('Backup written to (?P<path>.+)$')"
      },
      {
        "targets": [
          "ARCHIVE_FILENAME_PREFIX"
        ],
        "value": "'km-backup-'"
      },
      {
        "targets": [
          "ARCHIVE_ALLOWED_SUFFIXES"
        ],
        "value": "('.tgz', '.tar.gz')"
      },
      {
        "targets": [
          "DEFAULT_BACKUP_DIRNAME"
        ],
        "value": "'backups'"
      },
      {
        "targets": [
          "DEFAULT_BACKUP_ARCHIVE_DIRNAME"
        ],
        "value": "'archives'"
      }
    ]
  },
  "gateway/config/__init__.py": {
    "doc": "Configuration helpers for the knowledge gateway.",
    "imports": {
      "external": [
        "__future__",
        "settings"
      ],
      "internal": []
    },
    "classes": [],
    "functions": [],
    "constants": []
  },
  "gateway/config/settings.py": {
    "doc": "Pydantic-based configuration for the knowledge gateway.",
    "imports": {
      "external": [
        "__future__",
        "functools",
        "pathlib",
        "pydantic",
        "pydantic_settings",
        "typing"
      ],
      "internal": []
    },
    "classes": [
      {
        "name": "AppSettings",
        "bases": [
          "BaseSettings"
        ],
        "methods": [
          {
            "name": "_clamp_tracing_ratio",
            "signature": "(cls, value)",
            "is_async": false
          },
          {
            "name": "_clamp_search_weights",
            "signature": "(cls, value)",
            "is_async": false
          },
          {
            "name": "_sanitize_hnsw_ef",
            "signature": "(cls, value)",
            "is_async": false
          },
          {
            "name": "_sanitize_graph_cache_ttl",
            "signature": "(cls, value)",
            "is_async": false
          },
          {
            "name": "_sanitize_graph_cache_max",
            "signature": "(cls, value)",
            "is_async": false
          },
          {
            "name": "_sanitize_backup_interval",
            "signature": "(cls, value)",
            "is_async": false
          },
          {
            "name": "_sanitize_backup_retention",
            "signature": "(cls, value)",
            "is_async": false
          },
          {
            "name": "_sanitize_feedback_bytes",
            "signature": "(cls, value)",
            "is_async": false
          },
          {
            "name": "_sanitize_feedback_files",
            "signature": "(cls, value)",
            "is_async": false
          },
          {
            "name": "_sanitize_graph_max_results",
            "signature": "(cls, value)",
            "is_async": false
          },
          {
            "name": "_sanitize_graph_budget",
            "signature": "(cls, value)",
            "is_async": false
          },
          {
            "name": "resolved_search_weights",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "backup_trigger_config",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "scheduler_trigger_config",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "_validate_history_limit",
            "signature": "(cls, value)",
            "is_async": false
          },
          {
            "name": "_validate_audit_history_limit",
            "signature": "(cls, value)",
            "is_async": false
          },
          {
            "name": "_validate_lifecycle_stale",
            "signature": "(cls, value)",
            "is_async": false
          },
          {
            "name": "_ensure_positive_parallelism",
            "signature": "(cls, value)",
            "is_async": false
          }
        ],
        "doc": "Runtime configuration for the knowledge gateway."
      }
    ],
    "functions": [
      {
        "name": "get_settings",
        "signature": "()",
        "is_async": false,
        "doc": "Load settings from environment (cached)."
      }
    ],
    "constants": [
      {
        "targets": [
          "SEARCH_WEIGHT_PROFILES"
        ],
        "annotation": "dict[str, dict[str, float]]",
        "value": "{'default': {'weight_subsystem': 0.28, 'weight_relationship': 0.05, 'weight_support': 0.09, 'weight_coverage_penalty': 0.15, 'weight_criticality': 0.12}, 'analysis': {'weight_subsystem': 0.38, 'weight_relationship': 0.1, 'weight_support': 0.08, 'weight_coverage_penalty': 0.18, 'weight_criticality': 0.18}, 'operations': {'weight_subsystem': 0.22, 'weight_relationship': 0.08, 'weight_support': 0.06, 'weight_coverage_penalty': 0.28, 'weight_criticality': 0.1}, 'docs-heavy': {'weight_subsystem': 0.26, 'weight_relationship': 0.04, 'weight_support': 0.22, 'weight_coverage_penalty': 0.12, 'weight_criticality': 0.08}}"
      }
    ]
  },
  "gateway/graph/__init__.py": {
    "doc": "Graph query utilities and service layer.",
    "imports": {
      "external": [
        "service"
      ],
      "internal": []
    },
    "classes": [],
    "functions": [],
    "constants": []
  },
  "gateway/graph/cli.py": {
    "doc": "Command-line utilities for managing the Neo4j graph schema.",
    "imports": {
      "external": [
        "__future__",
        "argparse",
        "logging",
        "neo4j"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [],
    "functions": [
      {
        "name": "build_parser",
        "signature": "()",
        "is_async": false,
        "doc": "Return the CLI argument parser for graph administration commands."
      },
      {
        "name": "run_migrations",
        "signature": "(dry_run=False)",
        "is_async": false,
        "doc": "Execute graph schema migrations, optionally printing the pending set."
      },
      {
        "name": "main",
        "signature": "(argv=None)",
        "is_async": false,
        "doc": "Entrypoint for the `gateway-graph` command-line interface."
      }
    ],
    "constants": []
  },
  "gateway/graph/migrations/__init__.py": {
    "doc": "Graph schema migrations.",
    "imports": {
      "external": [
        "runner"
      ],
      "internal": []
    },
    "classes": [],
    "functions": [],
    "constants": []
  },
  "gateway/graph/migrations/runner.py": {
    "doc": "Helpers for applying and tracking Neo4j schema migrations.",
    "imports": {
      "external": [
        "__future__",
        "collections",
        "dataclasses",
        "logging",
        "neo4j"
      ],
      "internal": []
    },
    "classes": [
      {
        "name": "Migration",
        "bases": [],
        "methods": [],
        "doc": "Describe a single migration and the Cypher statements it executes."
      },
      {
        "name": "MigrationRunner",
        "bases": [],
        "methods": [
          {
            "name": "pending_ids",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "run",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "_is_applied",
            "signature": "(self, migration_id)",
            "is_async": false
          },
          {
            "name": "_apply",
            "signature": "(self, migration)",
            "is_async": false
          }
        ],
        "doc": "Apply ordered graph migrations using a shared Neo4j driver."
      }
    ],
    "functions": [],
    "constants": [
      {
        "targets": [
          "MIGRATIONS"
        ],
        "annotation": "list[Migration]",
        "value": "[Migration(id='001_constraints', statements=['CREATE CONSTRAINT IF NOT EXISTS FOR (s:Subsystem) REQUIRE s.name IS UNIQUE', 'CREATE CONSTRAINT IF NOT EXISTS FOR (f:SourceFile) REQUIRE f.path IS UNIQUE', 'CREATE CONSTRAINT IF NOT EXISTS FOR (d:DesignDoc) REQUIRE d.path IS UNIQUE', 'CREATE CONSTRAINT IF NOT EXISTS FOR (t:TestCase) REQUIRE t.path IS UNIQUE', 'CREATE CONSTRAINT IF NOT EXISTS FOR (c:Chunk) REQUIRE c.chunk_id IS UNIQUE']), Migration(id='002_domain_entities', statements=['CREATE CONSTRAINT IF NOT EXISTS FOR (m:IntegrationMessage) REQUIRE m.name IS UNIQUE', 'CREATE CONSTRAINT IF NOT EXISTS FOR (tc:TelemetryChannel) REQUIRE tc.name IS UNIQUE', 'CREATE CONSTRAINT IF NOT EXISTS FOR (cfg:ConfigFile) REQUIRE cfg.path IS UNIQUE'])]"
      }
    ]
  },
  "gateway/graph/service.py": {
    "doc": "Read-only graph service utilities backed by Neo4j.",
    "imports": {
      "external": [
        "__future__",
        "base64",
        "collections",
        "dataclasses",
        "neo4j",
        "threading",
        "time",
        "typing"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [
      {
        "name": "GraphServiceError",
        "bases": [
          "RuntimeError"
        ],
        "methods": [],
        "doc": "Base class for graph-related errors."
      },
      {
        "name": "GraphNotFoundError",
        "bases": [
          "GraphServiceError"
        ],
        "methods": [],
        "doc": "Raised when a requested node cannot be found."
      },
      {
        "name": "GraphQueryError",
        "bases": [
          "GraphServiceError"
        ],
        "methods": [],
        "doc": "Raised when a supplied query is invalid or unsafe."
      },
      {
        "name": "SubsystemGraphSnapshot",
        "bases": [],
        "methods": [],
        "doc": "Snapshot of a subsystem node and its related graph context."
      },
      {
        "name": "SubsystemGraphCache",
        "bases": [],
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, ttl_seconds, max_entries)",
            "is_async": false
          },
          {
            "name": "get",
            "signature": "(self, key)",
            "is_async": false
          },
          {
            "name": "set",
            "signature": "(self, key, snapshot)",
            "is_async": false
          },
          {
            "name": "clear",
            "signature": "(self)",
            "is_async": false
          }
        ],
        "doc": "Simple TTL cache for subsystem graph snapshots."
      },
      {
        "name": "GraphService",
        "bases": [],
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, driver_provider, database, cache_ttl=None, cache_max_entries=128, readonly_provider=None, failure_callback=None)",
            "is_async": false
          },
          {
            "name": "clear_cache",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "_get_driver",
            "signature": "(self, readonly=False)",
            "is_async": false
          },
          {
            "name": "_execute",
            "signature": "(self, operation, readonly=False)",
            "is_async": false
          },
          {
            "name": "_run_with_session",
            "signature": "(self, operation, readonly=False, **session_kwargs)",
            "is_async": false
          },
          {
            "name": "get_subsystem",
            "signature": "(self, name, depth, limit, cursor, include_artifacts)",
            "is_async": false
          },
          {
            "name": "get_subsystem_graph",
            "signature": "(self, name, depth)",
            "is_async": false
          },
          {
            "name": "list_orphan_nodes",
            "signature": "(self, label, cursor, limit)",
            "is_async": false
          },
          {
            "name": "_load_subsystem_snapshot",
            "signature": "(self, name, depth)",
            "is_async": false
          },
          {
            "name": "_build_subsystem_snapshot",
            "signature": "(self, name, depth)",
            "is_async": false
          },
          {
            "name": "get_node",
            "signature": "(self, node_id, relationships, limit)",
            "is_async": false
          },
          {
            "name": "search",
            "signature": "(self, term, limit)",
            "is_async": false
          },
          {
            "name": "shortest_path_depth",
            "signature": "(self, node_id, max_depth=4)",
            "is_async": false
          },
          {
            "name": "run_cypher",
            "signature": "(self, query, parameters=None)",
            "is_async": false
          }
        ],
        "doc": "Service layer for read-only graph queries."
      }
    ],
    "functions": [
      {
        "name": "get_graph_service",
        "signature": "(driver, database, cache_ttl=None, cache_max_entries=128, readonly_driver=None, failure_callback=None)",
        "is_async": false,
        "doc": "Factory helper that constructs a `GraphService` with optional caching."
      },
      {
        "name": "_extract_path_components",
        "signature": "(record)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_record_path_edges",
        "signature": "(path_nodes, relationships, nodes_by_id, edges_by_key)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_ensure_serialized_node",
        "signature": "(node, nodes_by_id)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_relationship_direction",
        "signature": "(relationship, source_node)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_build_related_entry",
        "signature": "(target_serialized, relationships, path_edges)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_append_related_entry",
        "signature": "(entry, target_id, related_entries, related_order)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_fetch_subsystem_node",
        "signature": "(tx, name)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_fetch_subsystem_paths",
        "signature": "(tx, name, depth)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_fetch_artifacts_for_subsystem",
        "signature": "(tx, name)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_fetch_orphan_nodes",
        "signature": "(tx, label, skip, limit)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_fetch_node_by_id",
        "signature": "(tx, label, key, value)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_fetch_node_relationships",
        "signature": "(tx, label, key, value, direction, limit)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_search_entities",
        "signature": "(tx, term, limit)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_serialize_related",
        "signature": "(record, subsystem_node)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_serialize_node",
        "signature": "(node)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_serialize_relationship",
        "signature": "(record)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_serialize_value",
        "signature": "(value)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_ensure_node",
        "signature": "(value)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_node_element_id",
        "signature": "(node)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_canonical_node_id",
        "signature": "(node)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_parse_node_id",
        "signature": "(node_id)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_encode_cursor",
        "signature": "(offset)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_decode_cursor",
        "signature": "(cursor)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_validate_cypher",
        "signature": "(query)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_strip_literals_and_comments",
        "signature": "(query)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_tokenize_query",
        "signature": "(upper_query)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_extract_procedure_calls",
        "signature": "(tokens)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_deny_cypher",
        "signature": "(reason, message)",
        "is_async": false,
        "doc": null
      }
    ],
    "constants": [
      {
        "targets": [
          "T"
        ],
        "value": "TypeVar('T')"
      },
      {
        "targets": [
          "ORPHAN_DEFAULT_LABELS"
        ],
        "annotation": "tuple[str, ...]",
        "value": "('DesignDoc', 'SourceFile', 'Chunk', 'TestCase', 'IntegrationMessage')"
      },
      {
        "targets": [
          "_ALLOWED_PROCEDURE_PREFIXES"
        ],
        "value": "('DB.SCHEMA.', 'DB.LABELS', 'DB.RELATIONSHIPTYPES', 'DB.INDEXES', 'DB.CONSTRAINTS', 'DB.PROPERTYKEYS')"
      }
    ]
  },
  "gateway/ingest/__init__.py": {
    "doc": "Ingestion pipeline components for the knowledge gateway.",
    "imports": {
      "external": [],
      "internal": [
        "gateway"
      ]
    },
    "classes": [],
    "functions": [],
    "constants": []
  },
  "gateway/ingest/artifacts.py": {
    "doc": "Domain models representing artifacts produced during ingestion.",
    "imports": {
      "external": [
        "__future__",
        "dataclasses",
        "pathlib",
        "typing"
      ],
      "internal": []
    },
    "classes": [
      {
        "name": "Artifact",
        "bases": [],
        "methods": [],
        "doc": "Represents a repository artifact prior to chunking."
      },
      {
        "name": "Chunk",
        "bases": [],
        "methods": [],
        "doc": "Represents a chunk ready for embedding and indexing."
      },
      {
        "name": "ChunkEmbedding",
        "bases": [],
        "methods": [],
        "doc": "Chunk plus embedding vector."
      }
    ],
    "functions": [],
    "constants": []
  },
  "gateway/ingest/audit.py": {
    "doc": "SQLite-backed audit log utilities for ingestion runs.",
    "imports": {
      "external": [
        "__future__",
        "pathlib",
        "sqlite3",
        "time",
        "typing"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [
      {
        "name": "AuditLogger",
        "bases": [],
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, db_path)",
            "is_async": false
          },
          {
            "name": "record",
            "signature": "(self, result)",
            "is_async": false
          },
          {
            "name": "recent",
            "signature": "(self, limit=20)",
            "is_async": false
          }
        ],
        "doc": "Persist and retrieve ingestion run metadata in SQLite."
      }
    ],
    "functions": [],
    "constants": [
      {
        "targets": [
          "_SCHEMA"
        ],
        "value": "'\\nCREATE TABLE IF NOT EXISTS ingestion_runs (\\n    run_id TEXT PRIMARY KEY,\\n    profile TEXT,\\n    started_at REAL,\\n    duration_seconds REAL,\\n    artifact_count INTEGER,\\n    chunk_count INTEGER,\\n    repo_head TEXT,\\n    success INTEGER,\\n    created_at REAL\\n)\\n'"
      },
      {
        "targets": [
          "_SELECT_RECENT"
        ],
        "value": "'\\nSELECT run_id, profile, started_at, duration_seconds, artifact_count, chunk_count, repo_head, success, created_at\\nFROM ingestion_runs\\nORDER BY created_at DESC\\nLIMIT ?\\n'"
      },
      {
        "targets": [
          "_INSERT_RUN"
        ],
        "value": "'\\nINSERT INTO ingestion_runs (\\n    run_id,\\n    profile,\\n    started_at,\\n    duration_seconds,\\n    artifact_count,\\n    chunk_count,\\n    repo_head,\\n    success,\\n    created_at\\n) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\\n'"
      }
    ]
  },
  "gateway/ingest/chunking.py": {
    "doc": "Chunk source artifacts into overlapping windows for indexing.",
    "imports": {
      "external": [
        "__future__",
        "collections",
        "hashlib",
        "math",
        "pathlib",
        "typing"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [
      {
        "name": "Chunker",
        "bases": [],
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, window=DEFAULT_WINDOW, overlap=DEFAULT_OVERLAP)",
            "is_async": false
          },
          {
            "name": "split",
            "signature": "(self, artifact)",
            "is_async": false
          },
          {
            "name": "estimate_chunk_count",
            "signature": "(path, text, window=DEFAULT_WINDOW, overlap=DEFAULT_OVERLAP)",
            "is_async": false
          }
        ],
        "doc": "Split artifacts into overlapping textual chunks."
      }
    ],
    "functions": [
      {
        "name": "_derive_namespace",
        "signature": "(path)",
        "is_async": false,
        "doc": "Infer a namespace from a file path for tagging chunks."
      },
      {
        "name": "_build_tags",
        "signature": "(extra_metadata)",
        "is_async": false,
        "doc": "Collect tag-like signals from artifact metadata."
      }
    ],
    "constants": [
      {
        "targets": [
          "DEFAULT_WINDOW"
        ],
        "value": "1000"
      },
      {
        "targets": [
          "DEFAULT_OVERLAP"
        ],
        "value": "200"
      }
    ]
  },
  "gateway/ingest/cli.py": {
    "doc": "Command-line helpers for triggering and inspecting ingestion runs.",
    "imports": {
      "external": [
        "__future__",
        "argparse",
        "collections",
        "datetime",
        "logging",
        "pathlib",
        "rich"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [],
    "functions": [
      {
        "name": "_ensure_maintainer_scope",
        "signature": "(settings)",
        "is_async": false,
        "doc": "Abort execution if maintainer credentials are missing during auth."
      },
      {
        "name": "build_parser",
        "signature": "()",
        "is_async": false,
        "doc": "Create an argument parser for the ingestion CLI."
      },
      {
        "name": "rebuild",
        "signature": "(profile, repo, dry_run, dummy_embeddings, incremental, settings=None)",
        "is_async": false,
        "doc": "Execute a full ingestion pass."
      },
      {
        "name": "audit_history",
        "signature": "(limit, output_json, settings=None)",
        "is_async": false,
        "doc": "Display recent ingestion runs from the audit ledger."
      },
      {
        "name": "_render_audit_table",
        "signature": "(entries)",
        "is_async": false,
        "doc": "Render recent audit entries as a Rich table."
      },
      {
        "name": "_format_timestamp",
        "signature": "(raw)",
        "is_async": false,
        "doc": "Format timestamps from the audit ledger for display."
      },
      {
        "name": "_coerce_int",
        "signature": "(value)",
        "is_async": false,
        "doc": "Attempt to interpret the value as an integer."
      },
      {
        "name": "_coerce_float",
        "signature": "(value)",
        "is_async": false,
        "doc": "Attempt to interpret the value as a floating point number."
      },
      {
        "name": "main",
        "signature": "(argv=None)",
        "is_async": false,
        "doc": "Entry point for the CLI."
      }
    ],
    "constants": []
  },
  "gateway/ingest/coverage.py": {
    "doc": "Utilities for writing ingestion coverage reports.",
    "imports": {
      "external": [
        "__future__",
        "contextlib",
        "datetime",
        "json",
        "pathlib",
        "time"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [],
    "functions": [
      {
        "name": "write_coverage_report",
        "signature": "(result, config, output_path, history_limit=None)",
        "is_async": false,
        "doc": "Persist coverage metrics derived from an ingestion result."
      },
      {
        "name": "_write_history_snapshot",
        "signature": "(payload, reports_dir, history_limit)",
        "is_async": false,
        "doc": "Write coverage history snapshots and prune old entries."
      }
    ],
    "constants": []
  },
  "gateway/ingest/discovery.py": {
    "doc": "Repository discovery helpers for ingestion pipeline.",
    "imports": {
      "external": [
        "__future__",
        "collections",
        "dataclasses",
        "fnmatch",
        "json",
        "logging",
        "pathlib",
        "re",
        "subprocess",
        "typing"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [
      {
        "name": "DiscoveryConfig",
        "bases": [],
        "methods": [],
        "doc": "Runtime knobs influencing which artifacts are discovered."
      }
    ],
    "functions": [
      {
        "name": "discover",
        "signature": "(config)",
        "is_async": false,
        "doc": "Yield textual artifacts from the repository."
      },
      {
        "name": "_should_include",
        "signature": "(path, repo_root, include_patterns)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_is_textual",
        "signature": "(path)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_infer_artifact_type",
        "signature": "(path, repo_root)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_lookup_git_metadata",
        "signature": "(path, repo_root)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_load_subsystem_catalog",
        "signature": "(repo_root)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_detect_source_prefixes",
        "signature": "(repo_root)",
        "is_async": false,
        "doc": "Infer source package prefixes (e.g. ``(\"src\", \"gateway\")``)."
      },
      {
        "name": "_collect_pyproject_prefixes",
        "signature": "(root, prefixes)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_load_pyproject",
        "signature": "(path)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_collect_poetry_prefixes",
        "signature": "(tool_cfg, prefixes)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_collect_project_prefixes",
        "signature": "(project_cfg, prefixes)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_collect_setuptools_prefixes",
        "signature": "(tool_cfg, prefixes)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_collect_src_directory_prefixes",
        "signature": "(root, prefixes)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_add_prefix",
        "signature": "(prefixes, include, base='src')",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_ensure_str_list",
        "signature": "(value)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_infer_subsystem",
        "signature": "(path, repo_root, source_prefixes)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_normalize_subsystem_name",
        "signature": "(value)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_match_catalog_entry",
        "signature": "(path, repo_root, catalog)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_iter_metadata_patterns",
        "signature": "(metadata)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_pattern_matches",
        "signature": "(target, pattern)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "dump_artifacts",
        "signature": "(artifacts)",
        "is_async": false,
        "doc": "Serialize artifacts for debugging or dry-run output."
      }
    ],
    "constants": [
      {
        "targets": [
          "_TEXTUAL_SUFFIXES"
        ],
        "value": "{'.md', '.txt', '.py', '.proto', '.yml', '.yaml', '.json', '.ini', '.cfg', '.toml', '.sql'}"
      },
      {
        "targets": [
          "_MESSAGE_PATTERN"
        ],
        "value": "re.compile('[A-Z]\\\\w*Message')"
      },
      {
        "targets": [
          "_TELEMETRY_PATTERN"
        ],
        "value": "re.compile('Telemetry\\\\w+')"
      },
      {
        "targets": [
          "_SUBSYSTEM_METADATA_CACHE"
        ],
        "annotation": "dict[Path, dict[str, Any]]",
        "value": "{}"
      },
      {
        "targets": [
          "_SOURCE_PREFIX_CACHE"
        ],
        "annotation": "dict[Path, list[tuple[str, ...]]]",
        "value": "{}"
      }
    ]
  },
  "gateway/ingest/embedding.py": {
    "doc": "Embedding helpers used during ingestion.",
    "imports": {
      "external": [
        "__future__",
        "collections",
        "functools",
        "logging",
        "sentence_transformers"
      ],
      "internal": []
    },
    "classes": [
      {
        "name": "Embedder",
        "bases": [],
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, model_name)",
            "is_async": false
          },
          {
            "name": "dimension",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "encode",
            "signature": "(self, texts)",
            "is_async": false
          },
          {
            "name": "_load_model",
            "signature": "(model_name)",
            "is_async": false
          }
        ],
        "doc": "Wrapper around sentence-transformers for configurable embeddings."
      },
      {
        "name": "DummyEmbedder",
        "bases": [
          "Embedder"
        ],
        "methods": [
          {
            "name": "__init__",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "dimension",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "encode",
            "signature": "(self, texts)",
            "is_async": false
          }
        ],
        "doc": "Deterministic embedder for dry-runs and tests."
      }
    ],
    "functions": [],
    "constants": []
  },
  "gateway/ingest/lifecycle.py": {
    "doc": "Lifecycle reporting helpers for ingestion outputs.",
    "imports": {
      "external": [
        "__future__",
        "collections",
        "contextlib",
        "dataclasses",
        "datetime",
        "json",
        "neo4j",
        "pathlib",
        "time",
        "typing"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [
      {
        "name": "LifecycleConfig",
        "bases": [],
        "methods": [],
        "doc": "Configuration values that influence lifecycle report generation."
      }
    ],
    "functions": [
      {
        "name": "write_lifecycle_report",
        "signature": "(result, config, graph_service)",
        "is_async": false,
        "doc": "Persist lifecycle insights derived from the most recent ingest run."
      },
      {
        "name": "build_graph_service",
        "signature": "(driver, database, cache_ttl)",
        "is_async": false,
        "doc": "Construct a graph service with sensible defaults for lifecycle usage."
      },
      {
        "name": "summarize_lifecycle",
        "signature": "(payload)",
        "is_async": false,
        "doc": "Produce a summarized view of lifecycle data for reporting."
      },
      {
        "name": "_fetch_isolated_nodes",
        "signature": "(graph_service)",
        "is_async": false,
        "doc": "Collect isolated graph nodes grouped by label."
      },
      {
        "name": "_find_stale_docs",
        "signature": "(artifacts, stale_days, now)",
        "is_async": false,
        "doc": "Identify design documents that are older than the stale threshold."
      },
      {
        "name": "_find_missing_tests",
        "signature": "(artifacts)",
        "is_async": false,
        "doc": "Determine subsystems lacking corresponding tests."
      },
      {
        "name": "_write_history_snapshot",
        "signature": "(payload, reports_dir, history_limit)",
        "is_async": false,
        "doc": "Write lifecycle history to disk while enforcing retention."
      },
      {
        "name": "_coerce_float",
        "signature": "(value)",
        "is_async": false,
        "doc": "Coerce numeric-like values to float when possible."
      },
      {
        "name": "_lifecycle_counts",
        "signature": "(isolated, stale_docs, missing_tests, removed)",
        "is_async": false,
        "doc": "Aggregate lifecycle metrics into counters."
      }
    ],
    "constants": [
      {
        "targets": [
          "SECONDS_PER_DAY"
        ],
        "value": "60 * 60 * 24"
      }
    ]
  },
  "gateway/ingest/neo4j_writer.py": {
    "doc": "Write ingestion artifacts and chunks into Neo4j.",
    "imports": {
      "external": [
        "__future__",
        "collections",
        "logging",
        "neo4j"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [
      {
        "name": "Neo4jWriter",
        "bases": [],
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, driver, database='knowledge')",
            "is_async": false
          },
          {
            "name": "ensure_constraints",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "sync_artifact",
            "signature": "(self, artifact)",
            "is_async": false
          },
          {
            "name": "sync_chunks",
            "signature": "(self, chunk_embeddings)",
            "is_async": false
          },
          {
            "name": "delete_artifact",
            "signature": "(self, path)",
            "is_async": false
          }
        ],
        "doc": "Persist artifacts and derived data into a Neo4j database."
      }
    ],
    "functions": [
      {
        "name": "_artifact_label",
        "signature": "(artifact)",
        "is_async": false,
        "doc": "Map artifact types to Neo4j labels."
      },
      {
        "name": "_label_for_type",
        "signature": "(artifact_type)",
        "is_async": false,
        "doc": "Return the default label for the given artifact type."
      },
      {
        "name": "_relationship_for_label",
        "signature": "(label)",
        "is_async": false,
        "doc": "Return the relationship used to link artifacts to subsystems."
      },
      {
        "name": "_clean_string_list",
        "signature": "(values)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_normalize_subsystem_name",
        "signature": "(value)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_extract_dependencies",
        "signature": "(metadata)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_subsystem_properties",
        "signature": "(metadata)",
        "is_async": false,
        "doc": null
      }
    ],
    "constants": []
  },
  "gateway/ingest/pipeline.py": {
    "doc": "Pipeline orchestrations for ingestion, chunking, and persistence.",
    "imports": {
      "external": [
        "__future__",
        "collections",
        "concurrent",
        "contextlib",
        "dataclasses",
        "filelock",
        "hashlib",
        "json",
        "logging",
        "opentelemetry",
        "os",
        "pathlib",
        "subprocess",
        "time",
        "uuid"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [
      {
        "name": "IngestionConfig",
        "bases": [],
        "methods": [],
        "doc": "Configuration options controlling ingestion behaviour."
      },
      {
        "name": "IngestionResult",
        "bases": [],
        "methods": [],
        "doc": "Summary of outputs emitted by an ingestion run."
      },
      {
        "name": "IngestionPipeline",
        "bases": [],
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, qdrant_writer, neo4j_writer, config)",
            "is_async": false
          },
          {
            "name": "run",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "_build_embedder",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "_encode_batch",
            "signature": "(self, embedder, chunks)",
            "is_async": false
          },
          {
            "name": "_build_embeddings",
            "signature": "(self, chunks, vectors)",
            "is_async": false
          },
          {
            "name": "_persist_embeddings",
            "signature": "(self, embeddings)",
            "is_async": false
          },
          {
            "name": "_handle_stale_artifacts",
            "signature": "(self, previous, current, profile)",
            "is_async": false
          },
          {
            "name": "_delete_artifact_from_backends",
            "signature": "(self, path)",
            "is_async": false
          },
          {
            "name": "_load_artifact_ledger",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "_read_ledger_file",
            "signature": "(self, ledger_path)",
            "is_async": false
          },
          {
            "name": "_write_artifact_ledger",
            "signature": "(self, entries)",
            "is_async": false
          },
          {
            "name": "_atomic_write",
            "signature": "(self, ledger_path, payload)",
            "is_async": false
          }
        ],
        "doc": "Execute the ingestion workflow end-to-end."
      }
    ],
    "functions": [
      {
        "name": "_current_repo_head",
        "signature": "(repo_root)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_coerce_int",
        "signature": "(value)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_coerce_float",
        "signature": "(value)",
        "is_async": false,
        "doc": null
      }
    ],
    "constants": []
  },
  "gateway/ingest/qdrant_writer.py": {
    "doc": "Helpers for writing chunk embeddings into Qdrant collections.",
    "imports": {
      "external": [
        "__future__",
        "collections",
        "logging",
        "qdrant_client",
        "time",
        "uuid"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [
      {
        "name": "QdrantWriter",
        "bases": [],
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, client, collection_name)",
            "is_async": false
          },
          {
            "name": "ensure_collection",
            "signature": "(self, vector_size, retries=3, retry_backoff=0.5)",
            "is_async": false
          },
          {
            "name": "reset_collection",
            "signature": "(self, vector_size)",
            "is_async": false
          },
          {
            "name": "upsert_chunks",
            "signature": "(self, chunks)",
            "is_async": false
          },
          {
            "name": "delete_artifact",
            "signature": "(self, artifact_path)",
            "is_async": false
          },
          {
            "name": "_collection_exists",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "_create_collection",
            "signature": "(self, vector_size)",
            "is_async": false
          }
        ],
        "doc": "Lightweight adapter around the Qdrant client."
      }
    ],
    "functions": [],
    "constants": []
  },
  "gateway/ingest/service.py": {
    "doc": "High-level orchestration routines for running ingestion.",
    "imports": {
      "external": [
        "__future__",
        "logging",
        "neo4j",
        "pathlib",
        "qdrant_client"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [],
    "functions": [
      {
        "name": "execute_ingestion",
        "signature": "(settings, profile, repo_override=None, dry_run=None, use_dummy_embeddings=None, incremental=None, graph_manager=None, qdrant_manager=None)",
        "is_async": false,
        "doc": "Run ingestion using shared settings and return result."
      }
    ],
    "constants": []
  },
  "gateway/lifecycle/__init__.py": {
    "doc": "Lifecycle reporting package.",
    "imports": {
      "external": [],
      "internal": []
    },
    "classes": [],
    "functions": [],
    "constants": []
  },
  "gateway/lifecycle/cli.py": {
    "doc": "Command-line utilities for inspecting lifecycle health reports.",
    "imports": {
      "external": [
        "__future__",
        "argparse",
        "collections",
        "datetime",
        "json",
        "pathlib",
        "rich"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [],
    "functions": [
      {
        "name": "build_parser",
        "signature": "()",
        "is_async": false,
        "doc": "Create the CLI argument parser shared across entrypoints."
      },
      {
        "name": "render_table",
        "signature": "(payload)",
        "is_async": false,
        "doc": "Pretty-print the lifecycle report payload using Rich tables."
      },
      {
        "name": "_render_isolated_nodes",
        "signature": "(value)",
        "is_async": false,
        "doc": "Render the isolated node section when data is present."
      },
      {
        "name": "_render_stale_docs",
        "signature": "(value)",
        "is_async": false,
        "doc": "Render the stale documentation summary rows."
      },
      {
        "name": "_render_missing_tests",
        "signature": "(value)",
        "is_async": false,
        "doc": "Render subsystems missing tests in a tabular format."
      },
      {
        "name": "_format_timestamp",
        "signature": "(value)",
        "is_async": false,
        "doc": "Convert a timestamp-like input into an ISO formatted string."
      },
      {
        "name": "main",
        "signature": "(argv=None)",
        "is_async": false,
        "doc": "CLI entry point for lifecycle reporting."
      }
    ],
    "constants": []
  },
  "gateway/mcp/__init__.py": {
    "doc": "Model Context Protocol server integration for the knowledge gateway.",
    "imports": {
      "external": [
        "config",
        "server"
      ],
      "internal": []
    },
    "classes": [],
    "functions": [],
    "constants": []
  },
  "gateway/mcp/backup.py": {
    "doc": "Backup helpers for the MCP server.",
    "imports": {
      "external": [
        "__future__",
        "asyncio",
        "config",
        "pathlib",
        "typing"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [],
    "functions": [
      {
        "name": "trigger_backup",
        "signature": "(settings)",
        "is_async": true,
        "doc": "Invoke the km-backup helper and return the resulting archive metadata."
      }
    ],
    "constants": []
  },
  "gateway/mcp/cli.py": {
    "doc": "Command-line entry point for the MCP server.",
    "imports": {
      "external": [
        "__future__",
        "argparse",
        "collections",
        "config",
        "logging",
        "server",
        "sys"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [],
    "functions": [
      {
        "name": "build_parser",
        "signature": "()",
        "is_async": false,
        "doc": "Return the CLI parser for launching the MCP server."
      },
      {
        "name": "main",
        "signature": "(argv=None)",
        "is_async": false,
        "doc": "Entry point for the MCP server management CLI."
      }
    ],
    "constants": [
      {
        "targets": [
          "_TRANSPORT_CHOICES"
        ],
        "value": "['stdio', 'http', 'sse', 'streamable-http']"
      }
    ]
  },
  "gateway/mcp/client.py": {
    "doc": "HTTP client for interacting with the gateway API.",
    "imports": {
      "external": [
        "__future__",
        "collections",
        "config",
        "exceptions",
        "httpx",
        "json",
        "logging",
        "types",
        "typing",
        "urllib"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [
      {
        "name": "GatewayClient",
        "bases": [],
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, settings)",
            "is_async": false
          },
          {
            "name": "__aenter__",
            "signature": "(self)",
            "is_async": true
          },
          {
            "name": "__aexit__",
            "signature": "(self, exc_type, exc, tb)",
            "is_async": true
          },
          {
            "name": "settings",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "search",
            "signature": "(self, payload)",
            "is_async": true
          },
          {
            "name": "graph_node",
            "signature": "(self, node_id, relationships, limit)",
            "is_async": true
          },
          {
            "name": "graph_subsystem",
            "signature": "(self, name, depth, include_artifacts, cursor, limit)",
            "is_async": true
          },
          {
            "name": "graph_search",
            "signature": "(self, term, limit)",
            "is_async": true
          },
          {
            "name": "coverage_summary",
            "signature": "(self)",
            "is_async": true
          },
          {
            "name": "lifecycle_report",
            "signature": "(self)",
            "is_async": true
          },
          {
            "name": "audit_history",
            "signature": "(self, limit=10)",
            "is_async": true
          },
          {
            "name": "_request",
            "signature": "(self, method, path, json_payload=None, params=None, require_admin=False, require_reader=False)",
            "is_async": true
          }
        ],
        "doc": "Thin async wrapper over the gateway REST API."
      }
    ],
    "functions": [
      {
        "name": "_extract_error_detail",
        "signature": "(response)",
        "is_async": false,
        "doc": "Extract a human-readable error detail from an HTTP response."
      },
      {
        "name": "_safe_json",
        "signature": "(response)",
        "is_async": false,
        "doc": "Safely decode a JSON response, returning ``None`` on failure."
      },
      {
        "name": "_quote_segment",
        "signature": "(value)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_expect_dict",
        "signature": "(data, operation)",
        "is_async": false,
        "doc": null
      }
    ],
    "constants": []
  },
  "gateway/mcp/config.py": {
    "doc": "Configuration for the MCP adapter.",
    "imports": {
      "external": [
        "__future__",
        "pathlib",
        "pydantic",
        "pydantic_settings",
        "typing"
      ],
      "internal": []
    },
    "classes": [
      {
        "name": "MCPSettings",
        "bases": [
          "BaseSettings"
        ],
        "methods": [],
        "doc": "Settings controlling the MCP server runtime."
      }
    ],
    "functions": [],
    "constants": []
  },
  "gateway/mcp/exceptions.py": {
    "doc": "Custom exceptions for the MCP adapter.",
    "imports": {
      "external": [
        "__future__"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [
      {
        "name": "MCPAdapterError",
        "bases": [
          "Exception"
        ],
        "methods": [],
        "doc": "Base error raised by the MCP bridge."
      },
      {
        "name": "GatewayRequestError",
        "bases": [
          "MCPAdapterError"
        ],
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, status_code, detail, payload=None)",
            "is_async": false
          }
        ],
        "doc": "Raised when the gateway API returns an error response."
      },
      {
        "name": "MissingTokenError",
        "bases": [
          "MCPAdapterError"
        ],
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, scope)",
            "is_async": false
          }
        ],
        "doc": "Raised when a privileged operation lacks an authentication token."
      },
      {
        "name": "BackupExecutionError",
        "bases": [
          "_BackupExecutionError",
          "MCPAdapterError"
        ],
        "methods": [],
        "doc": "Raised when the backup helper fails to produce an archive."
      }
    ],
    "functions": [],
    "constants": []
  },
  "gateway/mcp/feedback.py": {
    "doc": "Feedback logging utilities used by MCP tools.",
    "imports": {
      "external": [
        "__future__",
        "asyncio",
        "collections",
        "config",
        "datetime",
        "json",
        "pathlib",
        "typing"
      ],
      "internal": []
    },
    "classes": [],
    "functions": [
      {
        "name": "record_feedback",
        "signature": "(settings, request_id, chunk_id, vote, note, context)",
        "is_async": true,
        "doc": "Append a manual feedback entry to the state directory."
      },
      {
        "name": "_append_line",
        "signature": "(path, line)",
        "is_async": false,
        "doc": null
      }
    ],
    "constants": []
  },
  "gateway/mcp/ingest.py": {
    "doc": "Helpers for managing ingestion workflows via MCP.",
    "imports": {
      "external": [
        "__future__",
        "asyncio",
        "config",
        "dataclasses",
        "typing"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [],
    "functions": [
      {
        "name": "trigger_ingest",
        "signature": "(settings, profile, dry_run, use_dummy_embeddings)",
        "is_async": true,
        "doc": "Execute an ingestion run in a worker thread and return a serialisable summary."
      },
      {
        "name": "latest_ingest_status",
        "signature": "(history, profile)",
        "is_async": true,
        "doc": "Return the newest ingest record optionally filtered by profile."
      }
    ],
    "constants": []
  },
  "gateway/mcp/server.py": {
    "doc": "FastMCP server exposing the knowledge gateway.",
    "imports": {
      "external": [
        "__future__",
        "backup",
        "client",
        "collections",
        "config",
        "contextlib",
        "datetime",
        "exceptions",
        "fastmcp",
        "feedback",
        "functools",
        "ingest",
        "json",
        "pathlib",
        "storetext",
        "textwrap",
        "time",
        "typing",
        "upload"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [
      {
        "name": "MCPServerState",
        "bases": [],
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, settings)",
            "is_async": false
          },
          {
            "name": "require_client",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "lifespan",
            "signature": "(self)",
            "is_async": false
          }
        ],
        "doc": "Holds shared state for the MCP server lifespan."
      }
    ],
    "functions": [
      {
        "name": "build_server",
        "signature": "(settings=None)",
        "is_async": false,
        "doc": "Create a FastMCP server wired to the gateway API."
      },
      {
        "name": "_report_info",
        "signature": "(context, message)",
        "is_async": true,
        "doc": null
      },
      {
        "name": "_report_error",
        "signature": "(context, message)",
        "is_async": true,
        "doc": null
      },
      {
        "name": "_record_success",
        "signature": "(tool, start)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_record_failure",
        "signature": "(tool, exc, start)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_clamp",
        "signature": "(value, minimum, maximum)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_normalise_filters",
        "signature": "(payload)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_resolve_usage",
        "signature": "(tool)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_ensure_maintainer_scope",
        "signature": "(settings)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_append_audit_entry",
        "signature": "(settings, tool, payload)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_load_help_document",
        "signature": "()",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_initialise_metric_labels",
        "signature": "()",
        "is_async": false,
        "doc": null
      }
    ],
    "constants": [
      {
        "targets": [
          "TOOL_USAGE"
        ],
        "value": "{'km-search': {'description': 'Hybrid search across the knowledge base with optional filters and graph context', 'details': dedent('\\n            Required: `query` text. Optional: `limit` (default 10, max 25), `include_graph`, structured `filters`, `sort_by_vector`.\\n            Example: `/sys mcp run duskmantle km-search --query \"ingest pipeline\" --limit 5`.\\n            Returns scored chunks with metadata and optional graph enrichments.\\n            ').strip()}, 'km-graph-node': {'description': 'Fetch a graph node by ID and inspect incoming/outgoing relationships', 'details': dedent('\\n            Required: `node_id` such as `DesignDoc:docs/archive/WP6/WP6_RELEASE_TOOLING_PLAN.md`.\\n            Optional: `relationships` (`outgoing`, `incoming`, `all`, `none`) and `limit` (default 50, max 200).\\n            Example: `/sys mcp run duskmantle km-graph-node --node-id \"Code:gateway/mcp/server.py\"`.\\n            ').strip()}, 'km-graph-subsystem': {'description': 'Review a subsystem, related artifacts, and connected subsystems', 'details': dedent('\\n            Required: `name` of the subsystem.\\n            Optional: `depth` (default 1, max 5), `include_artifacts`, pagination `cursor`, `limit` (default 25, max 100).\\n            Example: `/sys mcp run duskmantle km-graph-subsystem --name Kasmina --depth 2`.\\n            ').strip()}, 'km-graph-search': {'description': 'Search graph entities (artifacts, subsystems, teams) by term', 'details': dedent('\\n            Required: `term` to match against graph nodes.\\n            Optional: `limit` (default 20, max 50).\\n            Example: `/sys mcp run duskmantle km-graph-search --term coverage`.\\n            ').strip()}, 'km-coverage-summary': {'description': 'Summarise ingestion coverage (artifact and chunk counts, freshness)', 'details': dedent('\\n            No parameters. Returns the same payload as `/coverage` including summary counts and stale thresholds.\\n            Example: `/sys mcp run duskmantle km-coverage-summary`.\\n            ').strip()}, 'km-lifecycle-report': {'description': 'Summarise isolated nodes, stale docs, and missing tests', 'details': dedent('\\n            No parameters. Mirrors the `/lifecycle` endpoint and highlights isolated graph nodes, stale design docs, and subsystems missing tests.\\n            Example: `/sys mcp run duskmantle km-lifecycle-report`.\\n            ').strip()}, 'km-ingest-status': {'description': 'Show the most recent ingest run (profile, status, timestamps)', 'details': dedent('\\n            Optional: `profile` to scope results to a specific ingest profile.\\n            Example: `/sys mcp run duskmantle km-ingest-status --profile demo`.\\n            Returns `status: ok` with run metadata or `status: not_found` when history is empty.\\n            ').strip()}, 'km-ingest-trigger': {'description': 'Kick off a manual ingest run (full rebuild via gateway-ingest)', 'details': dedent('\\n            Optional: `profile` (defaults to MCP settings), `dry_run`, `use_dummy_embeddings`.\\n            Example: `/sys mcp run duskmantle km-ingest-trigger --profile local --dry-run true`.\\n            Requires maintainer token (`KM_ADMIN_TOKEN`).\\n            ').strip()}, 'km-backup-trigger': {'description': 'Create a compressed backup of gateway state (Neo4j/Qdrant data)', 'details': dedent('\\n            No parameters. Returns archive path and metadata.\\n            Example: `/sys mcp run duskmantle km-backup-trigger`.\\n            Requires maintainer token; mirrors the `bin/km-backup` helper.\\n            ').strip()}, 'km-feedback-submit': {'description': 'Vote on a search result and attach optional notes for training data', 'details': dedent('\\n            Required: `request_id` (search request) and `chunk_id` (result identifier).\\n            Optional: numeric `vote` (-1.0 to 1.0) and freeform `note`.\\n            Example: `/sys mcp run duskmantle km-feedback-submit --request-id req123 --chunk-id chunk456 --vote 1`.\\n            Maintainer token required when auth is enforced.\\n            ').strip()}, 'km-upload': {'description': 'Copy an existing file into the knowledge workspace and optionally trigger ingest', 'details': dedent('\\n            Required: `source_path` (file visible to the MCP host). Optional: `destination` (relative path inside the\\n            content root), `overwrite`, `ingest`. Default behaviour stores the file under the configured docs directory.\\n            Example: `/sys mcp run duskmantle km-upload --source-path ./notes/design.md --destination docs/uploads/`.\\n            Maintainer scope recommended because this writes to the repository volume and may trigger ingestion.\\n            ').strip()}, 'km-storetext': {'description': 'Persist raw text as a document within the knowledge workspace', 'details': dedent('\\n            Required: `content` (text body). Optional: `title`, `destination`, `subsystem`, `tags`, `metadata` map,\\n            `overwrite`, `ingest`. Defaults write markdown into the configured docs directory with YAML front matter\\n            derived from the provided metadata.\\n            Example: `/sys mcp run duskmantle km-storetext --title \"Release Notes\" --content \"## Summary\"`.\\n            Maintainer scope recommended because this writes to the repository volume.\\n            ').strip()}}"
      },
      {
        "targets": [
          "HELP_DOC_PATH"
        ],
        "value": "Path(__file__).resolve().parents[2] / 'docs' / 'MCP_INTERFACE_SPEC.md'"
      }
    ]
  },
  "gateway/mcp/storetext.py": {
    "doc": "Handlers for storing text via MCP.",
    "imports": {
      "external": [
        "__future__",
        "datetime",
        "ingest",
        "pathlib",
        "typing"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [],
    "functions": [
      {
        "name": "_build_filename",
        "signature": "(title)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_normalise_destination",
        "signature": "(destination, default_dir, filename)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_compose_content",
        "signature": "(title, subsystem, tags, metadata, body)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "handle_storetext",
        "signature": "(settings, content, title, destination, subsystem, tags, metadata, overwrite, ingest)",
        "is_async": true,
        "doc": null
      }
    ],
    "constants": []
  },
  "gateway/mcp/upload.py": {
    "doc": "Handlers for MCP file uploads.",
    "imports": {
      "external": [
        "__future__",
        "ingest",
        "pathlib",
        "typing"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [],
    "functions": [
      {
        "name": "handle_upload",
        "signature": "(settings, source_path, destination, overwrite, ingest)",
        "is_async": true,
        "doc": "Copy ``source_path`` into the configured content root and optionally trigger ingest."
      },
      {
        "name": "_resolve_destination",
        "signature": "(destination, default_dir, filename)",
        "is_async": false,
        "doc": null
      }
    ],
    "constants": []
  },
  "gateway/mcp/utils/__init__.py": {
    "doc": null,
    "imports": {
      "external": [],
      "internal": []
    },
    "classes": [],
    "functions": [],
    "constants": []
  },
  "gateway/mcp/utils/files.py": {
    "doc": "Shared helpers for MCP content management.",
    "imports": {
      "external": [
        "__future__",
        "collections",
        "dataclasses",
        "os",
        "pathlib",
        "re",
        "shutil",
        "unicodedata"
      ],
      "internal": []
    },
    "classes": [
      {
        "name": "DocumentCopyResult",
        "bases": [],
        "methods": [],
        "doc": "Result of an attempted document copy."
      },
      {
        "name": "DocumentCopyError",
        "bases": [
          "Exception"
        ],
        "methods": [],
        "doc": "Raised when a copy operation fails fatally."
      }
    ],
    "functions": [
      {
        "name": "slugify",
        "signature": "(value, fallback='document')",
        "is_async": false,
        "doc": "Create a filesystem-friendly slug."
      },
      {
        "name": "is_supported_document",
        "signature": "(path)",
        "is_async": false,
        "doc": "Return ``True`` if the path has a supported document extension."
      },
      {
        "name": "_assert_within_root",
        "signature": "(root, candidate)",
        "is_async": false,
        "doc": "Ensure ``candidate`` is within ``root`` to prevent path traversal."
      },
      {
        "name": "sweep_documents",
        "signature": "(root, target, dry_run=False, overwrite=False)",
        "is_async": false,
        "doc": "Copy supported documents under ``root`` into ``target``."
      },
      {
        "name": "copy_into_root",
        "signature": "(source, root, destination=None, overwrite=False)",
        "is_async": false,
        "doc": "Copy ``source`` into ``root``."
      },
      {
        "name": "write_text_document",
        "signature": "(content, root, relative_path, overwrite=False, encoding='utf-8')",
        "is_async": false,
        "doc": "Write ``content`` to ``root / relative_path`` ensuring safety."
      }
    ],
    "constants": [
      {
        "targets": [
          "SUPPORTED_EXTENSIONS"
        ],
        "value": "{'.md', '.docx', '.txt', '.doc', '.pdf'}"
      },
      {
        "targets": [
          "_SLUG_REGEX"
        ],
        "value": "re.compile('[^a-z0-9]+')"
      }
    ]
  },
  "gateway/observability/__init__.py": {
    "doc": "Observability utilities (metrics, logging, tracing).",
    "imports": {
      "external": [
        "logging",
        "metrics",
        "tracing"
      ],
      "internal": []
    },
    "classes": [],
    "functions": [],
    "constants": []
  },
  "gateway/observability/logging.py": {
    "doc": "Structured logging configuration for the gateway.",
    "imports": {
      "external": [
        "__future__",
        "logging",
        "pythonjsonlogger",
        "sys",
        "typing"
      ],
      "internal": []
    },
    "classes": [
      {
        "name": "IngestAwareFormatter",
        "bases": [
          "json.JsonFormatter"
        ],
        "methods": [
          {
            "name": "add_fields",
            "signature": "(self, log_record, record, message_dict)",
            "is_async": false
          }
        ],
        "doc": "JSON formatter that enforces consistent keys."
      }
    ],
    "functions": [
      {
        "name": "configure_logging",
        "signature": "()",
        "is_async": false,
        "doc": "Configure root logging with a JSON formatter once per process."
      }
    ],
    "constants": [
      {
        "targets": [
          "_LOG_CONFIGURED"
        ],
        "value": "False"
      }
    ]
  },
  "gateway/observability/metrics.py": {
    "doc": "Prometheus metric definitions for the knowledge gateway.",
    "imports": {
      "external": [
        "__future__",
        "prometheus_client"
      ],
      "internal": []
    },
    "classes": [],
    "functions": [],
    "constants": [
      {
        "targets": [
          "BACKUP_RUNS_TOTAL"
        ],
        "value": "Counter('km_backup_runs_total', 'Backup job outcomes partitioned by result', labelnames=['result'])"
      },
      {
        "targets": [
          "BACKUP_LAST_STATUS"
        ],
        "value": "Gauge('km_backup_last_status', 'Last backup status (1=success,0=failure)')"
      },
      {
        "targets": [
          "BACKUP_LAST_SUCCESS_TIMESTAMP"
        ],
        "value": "Gauge('km_backup_last_success_timestamp', 'Unix timestamp of the last successful backup run')"
      },
      {
        "targets": [
          "BACKUP_RETENTION_DELETES_TOTAL"
        ],
        "value": "Counter('km_backup_retention_deletes_total', 'Number of backup archives removed by retention pruning')"
      },
      {
        "targets": [
          "GRAPH_DEPENDENCY_STATUS"
        ],
        "value": "Gauge('km_graph_dependency_status', 'Neo4j connectivity status (1=healthy,0=unavailable)')"
      },
      {
        "targets": [
          "GRAPH_DEPENDENCY_LAST_SUCCESS"
        ],
        "value": "Gauge('km_graph_dependency_last_success_timestamp', 'Unix timestamp of the last successful Neo4j heartbeat')"
      },
      {
        "targets": [
          "QDRANT_DEPENDENCY_STATUS"
        ],
        "value": "Gauge('km_qdrant_dependency_status', 'Qdrant connectivity status (1=healthy,0=unavailable)')"
      },
      {
        "targets": [
          "QDRANT_DEPENDENCY_LAST_SUCCESS"
        ],
        "value": "Gauge('km_qdrant_dependency_last_success_timestamp', 'Unix timestamp of the last successful Qdrant heartbeat')"
      },
      {
        "targets": [
          "INGEST_DURATION_SECONDS"
        ],
        "value": "Histogram('km_ingest_duration_seconds', 'Duration of ingestion runs', labelnames=['profile', 'status'])"
      },
      {
        "targets": [
          "INGEST_ARTIFACTS_TOTAL"
        ],
        "value": "Counter('km_ingest_artifacts_total', 'Number of artifacts processed', labelnames=['profile', 'artifact_type'])"
      },
      {
        "targets": [
          "INGEST_CHUNKS_TOTAL"
        ],
        "value": "Counter('km_ingest_chunks_total', 'Number of chunks generated', labelnames=['profile'])"
      },
      {
        "targets": [
          "INGEST_LAST_RUN_STATUS"
        ],
        "value": "Gauge('km_ingest_last_run_status', 'Last ingestion status (1=success,0=failure)', labelnames=['profile'])"
      },
      {
        "targets": [
          "INGEST_LAST_RUN_TIMESTAMP"
        ],
        "value": "Gauge('km_ingest_last_run_timestamp', 'Unix timestamp of last ingestion run', labelnames=['profile'])"
      },
      {
        "targets": [
          "COVERAGE_LAST_RUN_STATUS"
        ],
        "value": "Gauge('km_coverage_last_run_status', 'Last coverage report generation status (1=success,0=failure)', labelnames=['profile'])"
      },
      {
        "targets": [
          "COVERAGE_LAST_RUN_TIMESTAMP"
        ],
        "value": "Gauge('km_coverage_last_run_timestamp', 'Unix timestamp of last coverage report', labelnames=['profile'])"
      },
      {
        "targets": [
          "COVERAGE_MISSING_ARTIFACTS"
        ],
        "value": "Gauge('km_coverage_missing_artifacts_total', 'Number of artifacts without chunks discovered in last coverage report', labelnames=['profile'])"
      },
      {
        "targets": [
          "COVERAGE_STALE_ARTIFACTS"
        ],
        "value": "Gauge('km_coverage_stale_artifacts_total', 'Number of stale or removed artifacts recorded in last coverage report', labelnames=['profile'])"
      },
      {
        "targets": [
          "INGEST_STALE_RESOLVED_TOTAL"
        ],
        "value": "Counter('km_ingest_stale_resolved_total', 'Count of stale artifacts removed from backends during ingestion', labelnames=['profile'])"
      },
      {
        "targets": [
          "INGEST_SKIPS_TOTAL"
        ],
        "value": "Counter('km_ingest_skips_total', 'Ingestion runs skipped partitioned by reason', labelnames=['reason'])"
      },
      {
        "targets": [
          "SEARCH_REQUESTS_TOTAL"
        ],
        "value": "Counter('km_search_requests_total', 'Search API requests partitioned by outcome', labelnames=['status'])"
      },
      {
        "targets": [
          "SEARCH_GRAPH_CACHE_EVENTS"
        ],
        "value": "Counter('km_search_graph_cache_events_total', 'Graph context cache events during search', labelnames=['status'])"
      },
      {
        "targets": [
          "SEARCH_GRAPH_SKIPPED_TOTAL"
        ],
        "value": "Counter('km_search_graph_skipped_total', 'Number of search results where graph enrichment was skipped', labelnames=['reason'])"
      },
      {
        "targets": [
          "SEARCH_FEEDBACK_ROTATIONS_TOTAL"
        ],
        "value": "Counter('km_feedback_rotations_total', 'Number of times the search feedback log rotated due to size limits')"
      },
      {
        "targets": [
          "SEARCH_FEEDBACK_LOG_BYTES"
        ],
        "value": "Gauge('km_feedback_log_bytes', 'Current size of the primary search feedback log in bytes')"
      },
      {
        "targets": [
          "SEARCH_GRAPH_LOOKUP_SECONDS"
        ],
        "value": "Histogram('km_search_graph_lookup_seconds', 'Latency of graph lookups for search enrichment')"
      },
      {
        "targets": [
          "SEARCH_SCORE_DELTA"
        ],
        "value": "Histogram('km_search_adjusted_minus_vector', 'Distribution of adjusted minus vector scores')"
      },
      {
        "targets": [
          "GRAPH_CYPHER_DENIED_TOTAL"
        ],
        "value": "Counter('km_graph_cypher_denied_total', 'Maintainer Cypher requests blocked by read-only safeguards', labelnames=['reason'])"
      },
      {
        "targets": [
          "GRAPH_MIGRATION_LAST_STATUS"
        ],
        "value": "Gauge('km_graph_migration_last_status', 'Graph migration result (1=success, 0=failure, -1=skipped)')"
      },
      {
        "targets": [
          "GRAPH_MIGRATION_LAST_TIMESTAMP"
        ],
        "value": "Gauge('km_graph_migration_last_timestamp', 'Unix timestamp of the last graph migration attempt')"
      },
      {
        "targets": [
          "SCHEDULER_RUNS_TOTAL"
        ],
        "value": "Counter('km_scheduler_runs_total', 'Scheduled ingestion job outcomes partitioned by result', labelnames=['result'])"
      },
      {
        "targets": [
          "SCHEDULER_LAST_SUCCESS_TIMESTAMP"
        ],
        "value": "Gauge('km_scheduler_last_success_timestamp', 'Unix timestamp of the last successful scheduled ingestion run')"
      },
      {
        "targets": [
          "COVERAGE_HISTORY_SNAPSHOTS"
        ],
        "value": "Gauge('km_coverage_history_snapshots', 'Number of retained coverage history snapshots', labelnames=['profile'])"
      },
      {
        "targets": [
          "WATCH_RUNS_TOTAL"
        ],
        "value": "Counter('km_watch_runs_total', 'Watcher outcomes partitioned by result', labelnames=['result'])"
      },
      {
        "targets": [
          "LIFECYCLE_LAST_RUN_STATUS"
        ],
        "value": "Gauge('km_lifecycle_last_run_status', 'Lifecycle report generation status (1=success,0=failure)', labelnames=['profile'])"
      },
      {
        "targets": [
          "LIFECYCLE_LAST_RUN_TIMESTAMP"
        ],
        "value": "Gauge('km_lifecycle_last_run_timestamp', 'Unix timestamp of the last lifecycle report', labelnames=['profile'])"
      },
      {
        "targets": [
          "LIFECYCLE_STALE_DOCS_TOTAL"
        ],
        "value": "Gauge('km_lifecycle_stale_docs_total', 'Number of stale design docs in the latest lifecycle report', labelnames=['profile'])"
      },
      {
        "targets": [
          "LIFECYCLE_ISOLATED_NODES_TOTAL"
        ],
        "value": "Gauge('km_lifecycle_isolated_nodes_total', 'Number of isolated graph nodes recorded in the latest lifecycle report', labelnames=['profile'])"
      },
      {
        "targets": [
          "LIFECYCLE_MISSING_TEST_SUBSYSTEMS_TOTAL"
        ],
        "value": "Gauge('km_lifecycle_missing_test_subsystems_total', 'Number of subsystems missing tests in the latest lifecycle report', labelnames=['profile'])"
      },
      {
        "targets": [
          "LIFECYCLE_REMOVED_ARTIFACTS_TOTAL"
        ],
        "value": "Gauge('km_lifecycle_removed_artifacts_total', 'Number of recently removed artifacts recorded in the latest lifecycle report', labelnames=['profile'])"
      },
      {
        "targets": [
          "LIFECYCLE_HISTORY_SNAPSHOTS"
        ],
        "value": "Gauge('km_lifecycle_history_snapshots', 'Number of retained lifecycle history snapshots', labelnames=['profile'])"
      },
      {
        "targets": [
          "MCP_REQUESTS_TOTAL"
        ],
        "value": "Counter('km_mcp_requests_total', 'MCP tool invocations partitioned by result', labelnames=['tool', 'result'])"
      },
      {
        "targets": [
          "MCP_REQUEST_SECONDS"
        ],
        "value": "Histogram('km_mcp_request_seconds', 'Latency of MCP tool handlers', labelnames=['tool'])"
      },
      {
        "targets": [
          "MCP_FAILURES_TOTAL"
        ],
        "value": "Counter('km_mcp_failures_total', 'MCP tool failures partitioned by error type', labelnames=['tool', 'error'])"
      },
      {
        "targets": [
          "MCP_UPLOAD_TOTAL"
        ],
        "value": "Counter('km_mcp_upload_total', 'MCP upload tool invocations partitioned by result', labelnames=['result'])"
      },
      {
        "targets": [
          "MCP_STORETEXT_TOTAL"
        ],
        "value": "Counter('km_mcp_storetext_total', 'MCP storetext tool invocations partitioned by result', labelnames=['result'])"
      },
      {
        "targets": [
          "UI_REQUESTS_TOTAL"
        ],
        "value": "Counter('km_ui_requests_total', 'Embedded UI visits partitioned by view', labelnames=['view'])"
      },
      {
        "targets": [
          "UI_EVENTS_TOTAL"
        ],
        "value": "Counter('km_ui_events_total', 'Embedded UI events partitioned by event label', labelnames=['event'])"
      }
    ]
  },
  "gateway/observability/tracing.py": {
    "doc": "Tracing helpers for wiring OpenTelemetry exporters.",
    "imports": {
      "external": [
        "__future__",
        "fastapi",
        "opentelemetry"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [],
    "functions": [
      {
        "name": "configure_tracing",
        "signature": "(app, settings)",
        "is_async": false,
        "doc": "Configure OpenTelemetry tracing based on runtime settings."
      },
      {
        "name": "_select_exporter",
        "signature": "(settings)",
        "is_async": false,
        "doc": "Choose the span exporter based on settings."
      },
      {
        "name": "_parse_headers",
        "signature": "(header_string)",
        "is_async": false,
        "doc": "Parse comma-separated OTLP header strings into a dict."
      },
      {
        "name": "reset_tracing_for_tests",
        "signature": "()",
        "is_async": false,
        "doc": "Reset module-level state so tests can reconfigure tracing cleanly."
      }
    ],
    "constants": [
      {
        "targets": [
          "_TRACING_CONFIGURED"
        ],
        "value": "False"
      }
    ]
  },
  "gateway/plugins/__init__.py": {
    "doc": "Plugin namespace for future ingestion extensions.",
    "imports": {
      "external": [],
      "internal": []
    },
    "classes": [],
    "functions": [],
    "constants": []
  },
  "gateway/recipes/__init__.py": {
    "doc": "Utilities for running knowledge recipes.",
    "imports": {
      "external": [
        "executor",
        "models"
      ],
      "internal": []
    },
    "classes": [],
    "functions": [],
    "constants": []
  },
  "gateway/recipes/cli.py": {
    "doc": "Command-line utilities for inspecting and running MCP recipes.",
    "imports": {
      "external": [
        "__future__",
        "argparse",
        "asyncio",
        "collections",
        "executor",
        "json",
        "logging",
        "models",
        "pathlib",
        "pydantic",
        "rich",
        "typing"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [],
    "functions": [
      {
        "name": "build_parser",
        "signature": "()",
        "is_async": false,
        "doc": "Construct the top-level argument parser for the CLI."
      },
      {
        "name": "load_recipe_by_name",
        "signature": "(recipes_dir, name)",
        "is_async": false,
        "doc": "Load a recipe by stem name from the given directory."
      },
      {
        "name": "parse_variables",
        "signature": "(pairs)",
        "is_async": false,
        "doc": "Parse ``key=value`` overrides supplied on the command line."
      },
      {
        "name": "command_list",
        "signature": "(args)",
        "is_async": false,
        "doc": "List recipes available in the configured directory."
      },
      {
        "name": "command_show",
        "signature": "(args)",
        "is_async": false,
        "doc": "Print a single recipe definition in JSON form."
      },
      {
        "name": "command_validate",
        "signature": "(args)",
        "is_async": false,
        "doc": "Validate one or all recipes and report the outcome."
      },
      {
        "name": "recipe_executor_factory",
        "signature": "(settings)",
        "is_async": false,
        "doc": "Create a factory that instantiates a gateway-backed tool executor."
      },
      {
        "name": "command_run",
        "signature": "(args, settings)",
        "is_async": false,
        "doc": "Execute a recipe and render the results."
      },
      {
        "name": "_render_run_result",
        "signature": "(result)",
        "is_async": false,
        "doc": "Pretty-print a recipe execution result in tabular form."
      },
      {
        "name": "main",
        "signature": "(argv=None)",
        "is_async": false,
        "doc": "Entry point for the recipes CLI."
      }
    ],
    "constants": [
      {
        "targets": [
          "DEFAULT_RECIPES_DIR"
        ],
        "value": "Path(__file__).resolve().parents[2] / 'recipes'"
      }
    ]
  },
  "gateway/recipes/executor.py": {
    "doc": "Recipe execution layer for automating MCP-driven workflows.",
    "imports": {
      "external": [
        "__future__",
        "asyncio",
        "collections",
        "contextlib",
        "dataclasses",
        "json",
        "logging",
        "models",
        "pathlib",
        "re",
        "time",
        "types",
        "yaml"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [
      {
        "name": "RecipeExecutionError",
        "bases": [
          "RuntimeError"
        ],
        "methods": [],
        "doc": "Raised when a recipe step fails."
      },
      {
        "name": "StepResult",
        "bases": [],
        "methods": [],
        "doc": "Lightweight representation of a single recipe step outcome."
      },
      {
        "name": "RecipeRunResult",
        "bases": [],
        "methods": [
          {
            "name": "to_dict",
            "signature": "(self)",
            "is_async": false
          }
        ],
        "doc": "Aggregate outcome for a recipe execution, including captured outputs."
      },
      {
        "name": "ToolExecutor",
        "bases": [],
        "methods": [
          {
            "name": "call",
            "signature": "(self, tool, params)",
            "is_async": true
          },
          {
            "name": "__aenter__",
            "signature": "(self)",
            "is_async": true
          },
          {
            "name": "__aexit__",
            "signature": "(self, exc_type, exc, tb)",
            "is_async": true
          }
        ],
        "doc": "Abstract tool executor interface."
      },
      {
        "name": "GatewayToolExecutor",
        "bases": [
          "ToolExecutor"
        ],
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, settings)",
            "is_async": false
          },
          {
            "name": "__aenter__",
            "signature": "(self)",
            "is_async": true
          },
          {
            "name": "__aexit__",
            "signature": "(self, exc_type, exc, tb)",
            "is_async": true
          },
          {
            "name": "call",
            "signature": "(self, tool, params)",
            "is_async": true
          }
        ],
        "doc": "Execute tools by reusing gateway HTTP/MCP helpers."
      },
      {
        "name": "RecipeRunner",
        "bases": [],
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, settings, executor_factory=None, audit_path=None)",
            "is_async": false
          },
          {
            "name": "make_executor",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "run",
            "signature": "(self, recipe, variables=None, dry_run=False)",
            "is_async": true
          },
          {
            "name": "_execute_wait",
            "signature": "(self, executor, context, wait)",
            "is_async": true
          },
          {
            "name": "_append_audit",
            "signature": "(self, result, context)",
            "is_async": false
          }
        ],
        "doc": "Run recipes using the configured MCP settings."
      }
    ],
    "functions": [
      {
        "name": "_resolve_template",
        "signature": "(value, context)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_lookup_expression",
        "signature": "(expr, context)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_descend",
        "signature": "(current, part)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_evaluate_condition",
        "signature": "(result, condition)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_compute_capture",
        "signature": "(result, capture)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_executor_cm",
        "signature": "(factory)",
        "is_async": true,
        "doc": "Context manager that yields a tool executor from the provided factory."
      },
      {
        "name": "load_recipe",
        "signature": "(path)",
        "is_async": false,
        "doc": "Load a recipe file from disk and validate the schema."
      },
      {
        "name": "_ensure_object_map",
        "signature": "(value, label)",
        "is_async": false,
        "doc": "Ensure template resolution returned a mapping, raising otherwise."
      },
      {
        "name": "_require_str",
        "signature": "(params, key)",
        "is_async": false,
        "doc": "Fetch a required string parameter from a mapping of arguments."
      },
      {
        "name": "_coerce_optional_str",
        "signature": "(value)",
        "is_async": false,
        "doc": "Convert optional string-like values to trimmed strings."
      },
      {
        "name": "_coerce_positive_int",
        "signature": "(value, default)",
        "is_async": false,
        "doc": "Convert inputs to a positive integer, falling back to the default."
      },
      {
        "name": "_coerce_int",
        "signature": "(value)",
        "is_async": false,
        "doc": "Coerce common primitive values to an integer when possible."
      },
      {
        "name": "_coerce_bool",
        "signature": "(value, default=None)",
        "is_async": false,
        "doc": "Interpret truthy/falsey string values and return a boolean."
      },
      {
        "name": "list_recipes",
        "signature": "(recipes_dir)",
        "is_async": false,
        "doc": "Return all recipe definition files within the directory."
      }
    ],
    "constants": []
  },
  "gateway/recipes/models.py": {
    "doc": "Pydantic models describing MCP recipe configuration.",
    "imports": {
      "external": [
        "__future__",
        "pydantic",
        "typing"
      ],
      "internal": []
    },
    "classes": [
      {
        "name": "Condition",
        "bases": [
          "BaseModel"
        ],
        "methods": [],
        "doc": "Assertion condition evaluated against a step result."
      },
      {
        "name": "Capture",
        "bases": [
          "BaseModel"
        ],
        "methods": [],
        "doc": "Capture part of a step result into the execution context."
      },
      {
        "name": "WaitConfig",
        "bases": [
          "BaseModel"
        ],
        "methods": [],
        "doc": "Poll a tool until a condition is satisfied."
      },
      {
        "name": "RecipeStep",
        "bases": [
          "BaseModel"
        ],
        "methods": [
          {
            "name": "validate_mode",
            "signature": "(self)",
            "is_async": false
          }
        ],
        "doc": "Single step inside a recipe."
      },
      {
        "name": "Recipe",
        "bases": [
          "BaseModel"
        ],
        "methods": [
          {
            "name": "ensure_unique_step_ids",
            "signature": "(self)",
            "is_async": false
          }
        ],
        "doc": "Top level recipe definition."
      }
    ],
    "functions": [],
    "constants": []
  },
  "gateway/scheduler.py": {
    "doc": "Background scheduler that drives periodic ingestion runs.",
    "imports": {
      "external": [
        "__future__",
        "apscheduler",
        "collections",
        "contextlib",
        "filelock",
        "logging",
        "pathlib",
        "subprocess",
        "time"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [
      {
        "name": "IngestionScheduler",
        "bases": [],
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, settings, graph_manager=None, qdrant_manager=None)",
            "is_async": false
          },
          {
            "name": "start",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "shutdown",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "_run_ingestion",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "_run_backup",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "_read_last_head",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "_write_last_head",
            "signature": "(self, head)",
            "is_async": false
          },
          {
            "name": "_prune_backups",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "backup_health",
            "signature": "(self)",
            "is_async": false
          }
        ],
        "doc": "APScheduler wrapper that coordinates repo-aware ingestion jobs."
      }
    ],
    "functions": [
      {
        "name": "_current_repo_head",
        "signature": "(repo_root)",
        "is_async": false,
        "doc": "Return the git HEAD sha for the repo, or ``None`` when unavailable."
      },
      {
        "name": "_build_trigger",
        "signature": "(config)",
        "is_async": false,
        "doc": "Construct the APScheduler trigger based on user configuration."
      },
      {
        "name": "_describe_trigger",
        "signature": "(config)",
        "is_async": false,
        "doc": "Provide a human readable summary of the configured trigger."
      },
      {
        "name": "_coerce_positive_int",
        "signature": "(value, default)",
        "is_async": false,
        "doc": "Best-effort conversion to a positive integer with sane defaults."
      }
    ],
    "constants": []
  },
  "gateway/search/__init__.py": {
    "doc": "Search service exposing vector search with graph context.",
    "imports": {
      "external": [
        "dataset",
        "evaluation",
        "exporter",
        "feedback",
        "maintenance",
        "models",
        "service"
      ],
      "internal": []
    },
    "classes": [],
    "functions": [],
    "constants": []
  },
  "gateway/search/cli.py": {
    "doc": "Command-line helpers for search training, exports, and maintenance.",
    "imports": {
      "external": [
        "__future__",
        "argparse",
        "datetime",
        "logging",
        "pathlib",
        "rich"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [],
    "functions": [
      {
        "name": "build_parser",
        "signature": "()",
        "is_async": false,
        "doc": "Return an argument parser covering all search CLI commands."
      },
      {
        "name": "export_training_data",
        "signature": "(output, fmt, require_vote, limit, include_rotations, settings=None)",
        "is_async": false,
        "doc": "Materialise feedback events into a training dataset file."
      },
      {
        "name": "train_model",
        "signature": "(dataset, output, settings)",
        "is_async": false,
        "doc": "Train a ranking model from a prepared dataset and save the artifact."
      },
      {
        "name": "show_weights",
        "signature": "(settings)",
        "is_async": false,
        "doc": "Print the active search weight profile to the console."
      },
      {
        "name": "prune_feedback",
        "signature": "(settings, max_age_days, max_requests, output)",
        "is_async": false,
        "doc": "Trim feedback logs by age/request count and optionally archive removals."
      },
      {
        "name": "redact_training_dataset",
        "signature": "(dataset, output, drop_query, drop_context, drop_note)",
        "is_async": false,
        "doc": "Strip sensitive fields and emit a sanitized dataset."
      },
      {
        "name": "evaluate_trained_model",
        "signature": "(dataset, model)",
        "is_async": false,
        "doc": "Run offline evaluation of a trained model against a labelled dataset."
      },
      {
        "name": "main",
        "signature": "(argv=None)",
        "is_async": false,
        "doc": "Entry point for the `gateway-search` command-line interface."
      }
    ],
    "constants": []
  },
  "gateway/search/dataset.py": {
    "doc": "Utilities for reading and preparing search training datasets.",
    "imports": {
      "external": [
        "__future__",
        "collections",
        "csv",
        "json",
        "pathlib"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [
      {
        "name": "DatasetLoadError",
        "bases": [
          "RuntimeError"
        ],
        "methods": [],
        "doc": "Raised when a dataset cannot be parsed."
      }
    ],
    "functions": [
      {
        "name": "load_dataset_records",
        "signature": "(path)",
        "is_async": false,
        "doc": "Load dataset rows from disk, raising when the file is missing."
      },
      {
        "name": "build_feature_matrix",
        "signature": "(records, feature_names)",
        "is_async": false,
        "doc": "Convert dataset rows into numeric feature vectors and targets."
      },
      {
        "name": "_parse_float",
        "signature": "(value)",
        "is_async": false,
        "doc": null
      }
    ],
    "constants": [
      {
        "targets": [
          "TARGET_FIELD"
        ],
        "value": "'feedback_vote'"
      }
    ]
  },
  "gateway/search/evaluation.py": {
    "doc": "Model evaluation utilities for the search ranking pipeline.",
    "imports": {
      "external": [
        "__future__",
        "collections",
        "dataclasses",
        "math",
        "numpy",
        "pathlib",
        "statistics",
        "typing"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [
      {
        "name": "EvaluationMetrics",
        "bases": [],
        "methods": [],
        "doc": "Aggregate metrics produced after evaluating a ranking model."
      }
    ],
    "functions": [
      {
        "name": "evaluate_model",
        "signature": "(dataset_path, model_path)",
        "is_async": false,
        "doc": "Load a dataset and model artifact, returning evaluation metrics."
      },
      {
        "name": "_mean_ndcg",
        "signature": "(request_ids, relevance, scores, k)",
        "is_async": false,
        "doc": "Compute mean NDCG@k for groups identified by request ids."
      },
      {
        "name": "_dcg",
        "signature": "(relevances, k)",
        "is_async": false,
        "doc": "Compute discounted cumulative gain at rank ``k``."
      },
      {
        "name": "_spearman_correlation",
        "signature": "(y_true, y_pred)",
        "is_async": false,
        "doc": "Return Spearman rank correlation between true and predicted values."
      }
    ],
    "constants": []
  },
  "gateway/search/exporter.py": {
    "doc": "Utilities for exporting feedback logs into training datasets.",
    "imports": {
      "external": [
        "__future__",
        "collections",
        "csv",
        "dataclasses",
        "json",
        "logging",
        "pathlib",
        "re",
        "typing"
      ],
      "internal": []
    },
    "classes": [
      {
        "name": "ExportOptions",
        "bases": [],
        "methods": [],
        "doc": "User-configurable options controlling dataset export."
      },
      {
        "name": "ExportStats",
        "bases": [],
        "methods": [],
        "doc": "Basic statistics about the export process."
      }
    ],
    "functions": [
      {
        "name": "export_training_dataset",
        "signature": "(events_path, options)",
        "is_async": false,
        "doc": "Write feedback events from a single log into the requested dataset format."
      },
      {
        "name": "export_feedback_logs",
        "signature": "(log_paths, options)",
        "is_async": false,
        "doc": "Write feedback events from one or more log files into the requested dataset format."
      },
      {
        "name": "iter_feedback_events",
        "signature": "(path)",
        "is_async": false,
        "doc": "Yield feedback events from a JSON lines log file."
      },
      {
        "name": "discover_feedback_logs",
        "signature": "(root, include_rotations)",
        "is_async": false,
        "doc": "Return feedback log files in chronological order (oldest to newest)."
      },
      {
        "name": "_iter_feedback_logs",
        "signature": "(paths)",
        "is_async": false,
        "doc": "Yield events from a sequence of log files."
      },
      {
        "name": "_write_csv",
        "signature": "(events, options)",
        "is_async": false,
        "doc": "Write feedback events into a CSV file."
      },
      {
        "name": "_write_jsonl",
        "signature": "(events, options)",
        "is_async": false,
        "doc": "Write feedback events into a JSONL file."
      },
      {
        "name": "_flatten_event",
        "signature": "(event)",
        "is_async": false,
        "doc": "Flatten nested event data into scalar fields."
      }
    ],
    "constants": [
      {
        "targets": [
          "FIELDNAMES"
        ],
        "annotation": "Sequence[str]",
        "value": "('request_id', 'timestamp', 'rank', 'query', 'result_count', 'chunk_id', 'artifact_path', 'artifact_type', 'subsystem', 'vector_score', 'adjusted_score', 'signal_subsystem_affinity', 'signal_relationship_count', 'signal_supporting_bonus', 'signal_coverage_missing', 'graph_context_present', 'feedback_vote', 'feedback_note', 'context_json', 'metadata_request_id', 'metadata_graph_context_included', 'metadata_warnings_count')"
      },
      {
        "targets": [
          "LOG_SUFFIX_PATTERN"
        ],
        "value": "re.compile('events\\\\.log(?:\\\\.(?P<index>\\\\d+))?$')"
      }
    ]
  },
  "gateway/search/feedback.py": {
    "doc": "Persistent storage helpers for search feedback events.",
    "imports": {
      "external": [
        "__future__",
        "collections",
        "datetime",
        "json",
        "pathlib",
        "threading",
        "typing",
        "uuid"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [
      {
        "name": "SearchFeedbackStore",
        "bases": [],
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, root, max_bytes, max_files)",
            "is_async": false
          },
          {
            "name": "record",
            "signature": "(self, response, feedback, context=None, request_id=None)",
            "is_async": false
          },
          {
            "name": "_append",
            "signature": "(self, rows)",
            "is_async": false
          },
          {
            "name": "_rotate_if_needed",
            "signature": "(self, incoming_size)",
            "is_async": false
          },
          {
            "name": "_perform_rotation",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "_suffix_path",
            "signature": "(self, index)",
            "is_async": false
          },
          {
            "name": "_current_size",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "_update_metrics",
            "signature": "(self)",
            "is_async": false
          }
        ],
        "doc": "Append-only store for search telemetry and feedback."
      }
    ],
    "functions": [
      {
        "name": "_serialize_results",
        "signature": "(response, request_id, timestamp, vote, note, context, feedback)",
        "is_async": false,
        "doc": null
      }
    ],
    "constants": []
  },
  "gateway/search/filtering.py": {
    "doc": "Filter processing helpers for search queries.",
    "imports": {
      "external": [
        "__future__",
        "collections",
        "datetime",
        "typing"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [],
    "functions": [
      {
        "name": "build_filter_state",
        "signature": "(filters)",
        "is_async": false,
        "doc": "Normalise raw filter payloads into a `FilterState`."
      },
      {
        "name": "payload_passes_filters",
        "signature": "(payload, state)",
        "is_async": false,
        "doc": "Return True when the payload matches the provided filter state."
      },
      {
        "name": "parse_iso_datetime",
        "signature": "(value)",
        "is_async": false,
        "doc": "Parse integers, floats, or ISO-8601 strings into timezone-aware datetimes."
      },
      {
        "name": "_normalise_payload_tags",
        "signature": "(raw_tags)",
        "is_async": false,
        "doc": null
      }
    ],
    "constants": []
  },
  "gateway/search/graph_enricher.py": {
    "doc": "Graph enrichment helpers for search results.",
    "imports": {
      "external": [
        "__future__",
        "dataclasses",
        "logging",
        "neo4j",
        "time",
        "typing"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [
      {
        "name": "GraphEnrichmentResult",
        "bases": [],
        "methods": [],
        "doc": "Graph enrichment output for a single search hit."
      },
      {
        "name": "GraphEnricher",
        "bases": [],
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, graph_service, include_graph, filter_state, graph_max_results, time_budget_seconds, slow_warn_seconds, request_id)",
            "is_async": false
          },
          {
            "name": "slots_exhausted",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "time_exhausted",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "resolve",
            "signature": "(self, payload, subsystem_match, warnings)",
            "is_async": false
          }
        ],
        "doc": "Manage graph lookups with caching, budgets, and telemetry."
      }
    ],
    "functions": [
      {
        "name": "_label_for_artifact",
        "signature": "(artifact_type)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_summarize_graph_context",
        "signature": "(data)",
        "is_async": false,
        "doc": null
      }
    ],
    "constants": []
  },
  "gateway/search/maintenance.py": {
    "doc": "Maintenance routines for pruning feedback logs and redacting datasets.",
    "imports": {
      "external": [
        "__future__",
        "collections",
        "csv",
        "dataclasses",
        "datetime",
        "json",
        "logging",
        "pathlib",
        "shutil"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [
      {
        "name": "PruneOptions",
        "bases": [],
        "methods": [],
        "doc": "Configures retention rules for the feedback log pruning routine."
      },
      {
        "name": "PruneStats",
        "bases": [],
        "methods": [],
        "doc": "Summary of how many feedback requests were kept versus removed."
      },
      {
        "name": "RedactOptions",
        "bases": [],
        "methods": [],
        "doc": "Toggles that control which sensitive fields should be redacted."
      },
      {
        "name": "RedactStats",
        "bases": [],
        "methods": [],
        "doc": "Summary of how many dataset rows required redaction."
      }
    ],
    "functions": [
      {
        "name": "prune_feedback_log",
        "signature": "(events_path, options)",
        "is_async": false,
        "doc": "Prune feedback requests based on age and count thresholds."
      },
      {
        "name": "redact_dataset",
        "signature": "(dataset_path, options)",
        "is_async": false,
        "doc": "Redact sensitive fields from datasets stored as CSV or JSON Lines."
      },
      {
        "name": "_parse_timestamp",
        "signature": "(value)",
        "is_async": false,
        "doc": "Parse timestamps stored as numbers or ISO 8601 strings."
      },
      {
        "name": "_collect_events",
        "signature": "(events_path)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_build_timestamps",
        "signature": "(events_by_request)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_apply_prune_filters",
        "signature": "(request_order, timestamps, options, now)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_preserve_original_order",
        "signature": "(order, selected_ids)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_write_retained_events",
        "signature": "(destination, retained_order, events_by_request)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_redact_csv",
        "signature": "(source, destination, options)",
        "is_async": false,
        "doc": "Redact sensitive columns from a CSV dataset."
      },
      {
        "name": "_redact_csv_row",
        "signature": "(row, options)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_clear_field",
        "signature": "(row, field, replacement)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_redact_jsonl",
        "signature": "(source, destination, options)",
        "is_async": false,
        "doc": "Redact sensitive fields from JSON lines datasets."
      },
      {
        "name": "_redact_json_record",
        "signature": "(record, options)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_null_field",
        "signature": "(record, field)",
        "is_async": false,
        "doc": null
      }
    ],
    "constants": [
      {
        "targets": [
          "_FALLBACK_TIMESTAMP"
        ],
        "value": "datetime.fromordinal(1).replace(tzinfo=UTC)"
      }
    ]
  },
  "gateway/search/ml.py": {
    "doc": "Machine-learning scoring helpers for search results.",
    "imports": {
      "external": [
        "__future__",
        "dataclasses",
        "typing"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [
      {
        "name": "ModelScore",
        "bases": [],
        "methods": [],
        "doc": "Container for ML score and per-feature contributions."
      },
      {
        "name": "ModelScorer",
        "bases": [],
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, artifact)",
            "is_async": false
          },
          {
            "name": "available",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "intercept",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "score",
            "signature": "(self, scoring, graph_context, graph_context_included, warnings_count)",
            "is_async": false
          },
          {
            "name": "_build_features",
            "signature": "(self, scoring, graph_context, graph_context_included, warnings_count)",
            "is_async": false
          },
          {
            "name": "_apply",
            "signature": "(self, features)",
            "is_async": false
          }
        ],
        "doc": "Apply linear model artifacts to enrich search scoring."
      }
    ],
    "functions": [],
    "constants": []
  },
  "gateway/search/models.py": {
    "doc": "Shared dataclasses and type helpers for search components.",
    "imports": {
      "external": [
        "__future__",
        "dataclasses",
        "datetime",
        "typing"
      ],
      "internal": []
    },
    "classes": [
      {
        "name": "SearchResult",
        "bases": [],
        "methods": [],
        "doc": "Single ranked chunk returned from the search pipeline."
      },
      {
        "name": "SearchResponse",
        "bases": [],
        "methods": [],
        "doc": "API-friendly container for search results and metadata."
      },
      {
        "name": "SearchOptions",
        "bases": [],
        "methods": [],
        "doc": "Runtime options controlling the search service behaviour."
      },
      {
        "name": "SearchWeights",
        "bases": [],
        "methods": [],
        "doc": "Weighting configuration for hybrid scoring."
      },
      {
        "name": "FilterState",
        "bases": [],
        "methods": [],
        "doc": "Preprocessed filter collections derived from request parameters."
      },
      {
        "name": "CoverageInfo",
        "bases": [],
        "methods": [],
        "doc": "Coverage characteristics used during scoring."
      }
    ],
    "functions": [
      {
        "name": "ensure_utc",
        "signature": "(dt)",
        "is_async": false,
        "doc": "Normalise datetimes to UTC for serialisation."
      }
    ],
    "constants": []
  },
  "gateway/search/scoring.py": {
    "doc": "Heuristic scoring helpers used by the search service.",
    "imports": {
      "external": [
        "__future__",
        "datetime",
        "re",
        "typing"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [
      {
        "name": "HeuristicScorer",
        "bases": [],
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, weights, vector_weight, lexical_weight)",
            "is_async": false
          },
          {
            "name": "build_chunk",
            "signature": "(self, payload, score)",
            "is_async": false
          },
          {
            "name": "lexical_score",
            "signature": "(self, query, chunk)",
            "is_async": false
          },
          {
            "name": "base_scoring",
            "signature": "(self, vector_score, lexical_score)",
            "is_async": false
          },
          {
            "name": "apply_graph_scoring",
            "signature": "(self, base_scoring, vector_score, lexical_score, query_tokens, chunk, graph_context)",
            "is_async": false
          },
          {
            "name": "populate_additional_signals",
            "signature": "(self, scoring, chunk, graph_context, path_depth, freshness_days)",
            "is_async": false
          },
          {
            "name": "compute_freshness_days",
            "signature": "(self, chunk, graph_context)",
            "is_async": false
          },
          {
            "name": "_calculate_subsystem_affinity",
            "signature": "(subsystem, query_tokens)",
            "is_async": false
          },
          {
            "name": "_calculate_supporting_bonus",
            "signature": "(related_artifacts)",
            "is_async": false
          },
          {
            "name": "_calculate_coverage_info",
            "signature": "(self, chunk)",
            "is_async": false
          },
          {
            "name": "_coerce_ratio_value",
            "signature": "(value)",
            "is_async": false
          },
          {
            "name": "_calculate_criticality_score",
            "signature": "(chunk, graph_context)",
            "is_async": false
          },
          {
            "name": "_extract_subsystem_criticality",
            "signature": "(graph_context)",
            "is_async": false
          },
          {
            "name": "_normalise_criticality",
            "signature": "(value)",
            "is_async": false
          },
          {
            "name": "_estimate_path_depth",
            "signature": "(graph_context)",
            "is_async": false
          }
        ],
        "doc": "Apply hybrid heuristic signals and aggregate scoring metadata."
      }
    ],
    "functions": [],
    "constants": []
  },
  "gateway/search/service.py": {
    "doc": "Hybrid search orchestration for Duskmantle's knowledge gateway.",
    "imports": {
      "external": [
        "__future__",
        "collections",
        "datetime",
        "logging",
        "qdrant_client",
        "re",
        "typing"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [
      {
        "name": "SearchService",
        "bases": [],
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, qdrant_client, collection_name, embedder, options=None, weights=None, model_artifact=None, failure_callback=None)",
            "is_async": false
          },
          {
            "name": "search",
            "signature": "(self, query, limit, include_graph, graph_service, sort_by_vector=False, request_id=None, filters=None)",
            "is_async": false
          }
        ],
        "doc": "Execute hybrid vector/graph search with heuristic or ML scoring."
      }
    ],
    "functions": [
      {
        "name": "_subsystems_from_context",
        "signature": "(graph_context)",
        "is_async": false,
        "doc": "Extract subsystem identifiers from cached graph context."
      },
      {
        "name": "_detect_query_subsystems",
        "signature": "(query)",
        "is_async": false,
        "doc": "Tokenise the query to detect subsystem keywords for affinity scoring."
      },
      {
        "name": "_normalise_hybrid_weights",
        "signature": "(vector_weight, lexical_weight)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_resolve_chunk_datetime",
        "signature": "(chunk, graph_context)",
        "is_async": false,
        "doc": null
      }
    ],
    "constants": []
  },
  "gateway/search/trainer.py": {
    "doc": "Training utilities for search ranking models.",
    "imports": {
      "external": [
        "__future__",
        "collections",
        "dataclasses",
        "datetime",
        "json",
        "math",
        "numpy",
        "pathlib"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [
      {
        "name": "TrainingResult",
        "bases": [],
        "methods": [],
        "doc": "Capture optimiser output for debug or inspection."
      },
      {
        "name": "ModelArtifact",
        "bases": [],
        "methods": [],
        "doc": "Persisted search model metadata and coefficients."
      }
    ],
    "functions": [
      {
        "name": "train_from_dataset",
        "signature": "(path)",
        "is_async": false,
        "doc": "Train a logistic regression model from the labelled dataset."
      },
      {
        "name": "save_artifact",
        "signature": "(artifact, path)",
        "is_async": false,
        "doc": "Write the model artifact to disk as JSON."
      },
      {
        "name": "load_artifact",
        "signature": "(path)",
        "is_async": false,
        "doc": "Load a saved model artifact from disk."
      },
      {
        "name": "_linear_regression",
        "signature": "(X, y)",
        "is_async": false,
        "doc": null
      }
    ],
    "constants": [
      {
        "targets": [
          "FEATURE_FIELDS"
        ],
        "annotation": "Sequence[str]",
        "value": "('vector_score', 'signal_subsystem_affinity', 'signal_relationship_count', 'signal_supporting_bonus', 'signal_coverage_missing', 'graph_context_present', 'metadata_graph_context_included', 'metadata_warnings_count')"
      }
    ]
  },
  "gateway/search/vector_retriever.py": {
    "doc": "Utilities for running vector retrieval against Qdrant.",
    "imports": {
      "external": [
        "__future__",
        "collections",
        "logging",
        "qdrant_client"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [
      {
        "name": "VectorRetrievalError",
        "bases": [
          "RuntimeError"
        ],
        "methods": [],
        "doc": "Raised when vector search fails before results are returned."
      },
      {
        "name": "VectorRetriever",
        "bases": [],
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, embedder, qdrant_client, collection_name, hnsw_ef_search=None, failure_callback=None)",
            "is_async": false
          },
          {
            "name": "search",
            "signature": "(self, query, limit, request_id=None)",
            "is_async": false
          }
        ],
        "doc": "Encode a query and execute Qdrant search with optional tuning."
      }
    ],
    "functions": [],
    "constants": []
  },
  "gateway/ui/__init__.py": {
    "doc": "UI utilities and routers.",
    "imports": {
      "external": [
        "routes"
      ],
      "internal": []
    },
    "classes": [],
    "functions": [],
    "constants": []
  },
  "gateway/ui/routes.py": {
    "doc": "UI router exposing static assets and HTML entry points.",
    "imports": {
      "external": [
        "__future__",
        "fastapi",
        "json",
        "logging",
        "pathlib"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [],
    "functions": [
      {
        "name": "get_static_path",
        "signature": "()",
        "is_async": false,
        "doc": "Return the absolute path to UI static assets."
      },
      {
        "name": "ui_index",
        "signature": "(request)",
        "is_async": true,
        "doc": "Render the landing page for the embedded UI."
      },
      {
        "name": "ui_search",
        "signature": "(request)",
        "is_async": true,
        "doc": "Render the search console view."
      },
      {
        "name": "ui_subsystems",
        "signature": "(request)",
        "is_async": true,
        "doc": "Render the subsystem explorer view."
      },
      {
        "name": "ui_lifecycle",
        "signature": "(request)",
        "is_async": true,
        "doc": "Render the lifecycle dashboard view."
      },
      {
        "name": "ui_lifecycle_report",
        "signature": "(request)",
        "is_async": true,
        "doc": "Serve the lifecycle report JSON while recording UI metrics."
      },
      {
        "name": "ui_event",
        "signature": "(request, payload)",
        "is_async": true,
        "doc": "Record a UI event for observability purposes."
      }
    ],
    "constants": [
      {
        "targets": [
          "STATIC_DIR"
        ],
        "value": "Path(__file__).resolve().parent / 'static'"
      },
      {
        "targets": [
          "TEMPLATES_DIR"
        ],
        "value": "Path(__file__).resolve().parent / 'templates'"
      }
    ]
  },
  "scripts/generate-changelog.py": {
    "doc": "Generate changelog entries from Conventional Commits.",
    "imports": {
      "external": [
        "__future__",
        "argparse",
        "collections",
        "datetime",
        "pathlib",
        "subprocess",
        "sys"
      ],
      "internal": []
    },
    "classes": [],
    "functions": [
      {
        "name": "_run_git",
        "signature": "(args)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "discover_commits",
        "signature": "(since)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "categorize",
        "signature": "(commits)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "update_changelog",
        "signature": "(version, released, entries)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "main",
        "signature": "()",
        "is_async": false,
        "doc": null
      }
    ],
    "constants": [
      {
        "targets": [
          "ROOT"
        ],
        "value": "Path(__file__).resolve().parents[1]"
      },
      {
        "targets": [
          "CHANGELOG"
        ],
        "value": "ROOT / 'CHANGELOG.md'"
      },
      {
        "targets": [
          "CATEGORY_MAP"
        ],
        "value": "{'feat': 'Added', 'fix': 'Fixed', 'docs': 'Documentation', 'perf': 'Performance', 'refactor': 'Changed', 'chore': 'Chore', 'test': 'Tests'}"
      }
    ]
  },
  "tests/__init__.py": {
    "doc": "Test package for the knowledge gateway.",
    "imports": {
      "external": [],
      "internal": []
    },
    "classes": [],
    "functions": [],
    "constants": []
  },
  "tests/conftest.py": {
    "doc": null,
    "imports": {
      "external": [
        "__future__",
        "collections",
        "neo4j",
        "os",
        "pytest",
        "shutil",
        "subprocess",
        "sys",
        "time",
        "types",
        "typing",
        "uuid",
        "warnings"
      ],
      "internal": []
    },
    "classes": [
      {
        "name": "_NullSession",
        "bases": [],
        "methods": [
          {
            "name": "__init__",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "__enter__",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "__exit__",
            "signature": "(self, exc_type, exc, tb)",
            "is_async": false
          },
          {
            "name": "close",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "execute_read",
            "signature": "(self, func, *args, **kwargs)",
            "is_async": false
          },
          {
            "name": "run",
            "signature": "(self, *args, **kwargs)",
            "is_async": false
          }
        ],
        "doc": null
      },
      {
        "name": "_NullDriver",
        "bases": [],
        "methods": [
          {
            "name": "session",
            "signature": "(self, **kwargs)",
            "is_async": false
          },
          {
            "name": "close",
            "signature": "(self)",
            "is_async": false
          }
        ],
        "doc": null
      }
    ],
    "functions": [
      {
        "name": "disable_real_graph_driver",
        "signature": "(monkeypatch, request)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "default_authentication_env",
        "signature": "(monkeypatch)",
        "is_async": false,
        "doc": "Provide secure default credentials so create_app() can boot under auth-on defaults."
      },
      {
        "name": "neo4j_test_environment",
        "signature": "()",
        "is_async": false,
        "doc": null
      },
      {
        "name": "pytest_collection_modifyitems",
        "signature": "(config, items)",
        "is_async": false,
        "doc": null
      }
    ],
    "constants": []
  },
  "tests/mcp/test_server_tools.py": {
    "doc": "Integration tests for MCP server tools and metrics wiring.",
    "imports": {
      "external": [
        "__future__",
        "asyncio",
        "collections",
        "pathlib",
        "prometheus_client",
        "pytest",
        "typing"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [],
    "functions": [
      {
        "name": "_reset_mcp_metrics",
        "signature": "()",
        "is_async": false,
        "doc": null
      },
      {
        "name": "mcp_server",
        "signature": "()",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_counter_value",
        "signature": "(counter, *labels)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_histogram_sum",
        "signature": "(histogram, *labels)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_upload_counter",
        "signature": "(result)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_storetext_counter",
        "signature": "(result)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_tool_fn",
        "signature": "(tool)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_km_help_lists_tools_and_provides_details",
        "signature": "(monkeypatch, mcp_server)",
        "is_async": true,
        "doc": null
      },
      {
        "name": "test_metrics_export_includes_tool_labels",
        "signature": "(monkeypatch, mcp_server)",
        "is_async": true,
        "doc": null
      },
      {
        "name": "test_km_search_success_records_metrics",
        "signature": "(mcp_server)",
        "is_async": true,
        "doc": null
      },
      {
        "name": "test_km_search_gateway_error_records_failure",
        "signature": "(mcp_server)",
        "is_async": true,
        "doc": null
      },
      {
        "name": "test_graph_tools_delegate_to_client_and_record_metrics",
        "signature": "(mcp_server)",
        "is_async": true,
        "doc": null
      },
      {
        "name": "test_lifecycle_report_records_metrics",
        "signature": "(mcp_server)",
        "is_async": true,
        "doc": null
      },
      {
        "name": "test_coverage_summary_records_metrics",
        "signature": "(mcp_server)",
        "is_async": true,
        "doc": null
      },
      {
        "name": "test_ingest_status_handles_missing_history",
        "signature": "(mcp_server)",
        "is_async": true,
        "doc": null
      },
      {
        "name": "test_ingest_trigger_succeeds",
        "signature": "(monkeypatch, mcp_server)",
        "is_async": true,
        "doc": null
      },
      {
        "name": "test_ingest_trigger_failure_records_metrics",
        "signature": "(monkeypatch, mcp_server)",
        "is_async": true,
        "doc": null
      },
      {
        "name": "test_backup_trigger",
        "signature": "(monkeypatch, mcp_server)",
        "is_async": true,
        "doc": null
      },
      {
        "name": "test_feedback_submit",
        "signature": "(monkeypatch, mcp_server)",
        "is_async": true,
        "doc": null
      },
      {
        "name": "test_km_upload_copies_file_and_records_metrics",
        "signature": "(tmp_path)",
        "is_async": true,
        "doc": null
      },
      {
        "name": "test_km_upload_missing_source_raises",
        "signature": "(tmp_path)",
        "is_async": true,
        "doc": null
      },
      {
        "name": "test_km_upload_requires_admin_token",
        "signature": "(tmp_path)",
        "is_async": true,
        "doc": null
      },
      {
        "name": "test_km_upload_triggers_ingest_when_requested",
        "signature": "(monkeypatch, tmp_path)",
        "is_async": true,
        "doc": null
      },
      {
        "name": "test_km_storetext_creates_document_with_front_matter",
        "signature": "(tmp_path)",
        "is_async": true,
        "doc": null
      },
      {
        "name": "test_km_storetext_requires_content",
        "signature": "(tmp_path)",
        "is_async": true,
        "doc": null
      },
      {
        "name": "test_km_storetext_triggers_ingest_when_requested",
        "signature": "(monkeypatch, tmp_path)",
        "is_async": true,
        "doc": null
      },
      {
        "name": "test_km_storetext_requires_admin_token",
        "signature": "(tmp_path)",
        "is_async": true,
        "doc": null
      },
      {
        "name": "test_mcp_smoke_run",
        "signature": "(monkeypatch, mcp_server)",
        "is_async": true,
        "doc": null
      }
    ],
    "constants": []
  },
  "tests/mcp/test_utils_files.py": {
    "doc": null,
    "imports": {
      "external": [
        "__future__",
        "pathlib",
        "pytest"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [],
    "functions": [
      {
        "name": "test_sweep_documents_copies_supported_files",
        "signature": "(tmp_path)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_sweep_documents_dry_run_reports_actions",
        "signature": "(tmp_path)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_copy_into_root_prevents_traversal",
        "signature": "(tmp_path)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_write_text_document_requires_content",
        "signature": "(tmp_path)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_slugify_generates_fallback_when_empty",
        "signature": "()",
        "is_async": false,
        "doc": null
      }
    ],
    "constants": []
  },
  "tests/playwright_server.py": {
    "doc": null,
    "imports": {
      "external": [
        "__future__",
        "datetime",
        "json",
        "os",
        "pathlib",
        "shutil",
        "signal",
        "uvicorn"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [],
    "functions": [
      {
        "name": "_write_json",
        "signature": "(path, payload)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_prepare_state",
        "signature": "(state_path)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_configure_environment",
        "signature": "(state_path)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "main",
        "signature": "()",
        "is_async": false,
        "doc": null
      }
    ],
    "constants": []
  },
  "tests/search/test_exporter.py": {
    "doc": null,
    "imports": {
      "external": [
        "__future__",
        "csv",
        "json",
        "pathlib",
        "types"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [],
    "functions": [
      {
        "name": "test_discover_feedback_logs_orders_oldest_first",
        "signature": "(tmp_path)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_export_feedback_logs_combines_rotations",
        "signature": "(tmp_path)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_export_training_data_includes_rotations",
        "signature": "(tmp_path)",
        "is_async": false,
        "doc": null
      }
    ],
    "constants": []
  },
  "tests/search/test_filtering.py": {
    "doc": null,
    "imports": {
      "external": [
        "__future__",
        "datetime"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [],
    "functions": [
      {
        "name": "test_build_filter_state_normalises_filters",
        "signature": "()",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_payload_passes_filters_checks_all_fields",
        "signature": "()",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_parse_iso_datetime_handles_multiple_formats",
        "signature": "()",
        "is_async": false,
        "doc": null
      }
    ],
    "constants": []
  },
  "tests/search/test_graph_enricher.py": {
    "doc": null,
    "imports": {
      "external": [
        "__future__",
        "pytest",
        "time",
        "typing"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [
      {
        "name": "DummyGraphService",
        "bases": [
          "GraphService"
        ],
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, response, delay=0.0)",
            "is_async": false
          },
          {
            "name": "get_node",
            "signature": "(self, node_id, relationships, limit)",
            "is_async": false
          },
          {
            "name": "shortest_path_depth",
            "signature": "(self, node_id, max_depth=4)",
            "is_async": false
          },
          {
            "name": "get_subsystem",
            "signature": "(self, *args, **kwargs)",
            "is_async": false
          },
          {
            "name": "search",
            "signature": "(self, term, limit)",
            "is_async": false
          },
          {
            "name": "run_cypher",
            "signature": "(self, query, parameters)",
            "is_async": false
          }
        ],
        "doc": null
      }
    ],
    "functions": [
      {
        "name": "_metric_value",
        "signature": "(name, labels=None)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "graph_payload",
        "signature": "()",
        "is_async": false,
        "doc": null
      },
      {
        "name": "graph_response",
        "signature": "()",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_graph_enricher_caches_results",
        "signature": "(graph_payload, graph_response)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_graph_enricher_respects_result_budget",
        "signature": "(graph_payload, graph_response)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_graph_enricher_respects_time_budget",
        "signature": "(graph_payload, graph_response)",
        "is_async": false,
        "doc": null
      }
    ],
    "constants": []
  },
  "tests/search/test_ml_scorer.py": {
    "doc": null,
    "imports": {
      "external": [
        "__future__",
        "pytest"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [],
    "functions": [
      {
        "name": "_artifact",
        "signature": "()",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_model_scorer_produces_contributions",
        "signature": "()",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_model_scorer_handles_missing_features_with_defaults",
        "signature": "()",
        "is_async": false,
        "doc": null
      }
    ],
    "constants": []
  },
  "tests/search/test_scoring.py": {
    "doc": null,
    "imports": {
      "external": [
        "__future__",
        "datetime",
        "pytest"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [],
    "functions": [
      {
        "name": "test_heuristic_scorer_applies_graph_signals",
        "signature": "()",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_compute_freshness_days_prefers_chunk_timestamp",
        "signature": "()",
        "is_async": false,
        "doc": null
      }
    ],
    "constants": []
  },
  "tests/search/test_vector_retriever.py": {
    "doc": null,
    "imports": {
      "external": [
        "__future__",
        "collections",
        "pytest",
        "typing"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [
      {
        "name": "DummyEmbedder",
        "bases": [],
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, raise_on_encode=None)",
            "is_async": false
          },
          {
            "name": "encode",
            "signature": "(self, texts)",
            "is_async": false
          }
        ],
        "doc": null
      },
      {
        "name": "DummyQdrantClient",
        "bases": [],
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, raise_on_search=None)",
            "is_async": false
          },
          {
            "name": "search",
            "signature": "(self, **kwargs)",
            "is_async": false
          }
        ],
        "doc": null
      }
    ],
    "functions": [
      {
        "name": "test_vector_retriever_returns_hits",
        "signature": "()",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_vector_retriever_failure_calls_callback",
        "signature": "()",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_vector_retriever_encode_failure_propagates",
        "signature": "()",
        "is_async": false,
        "doc": null
      }
    ],
    "constants": []
  },
  "tests/test_api_security.py": {
    "doc": null,
    "imports": {
      "external": [
        "__future__",
        "fastapi",
        "json",
        "logging",
        "pathlib",
        "pytest",
        "typing"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [],
    "functions": [
      {
        "name": "reset_settings_cache",
        "signature": "()",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_audit_requires_token",
        "signature": "(tmp_path, monkeypatch)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_audit_history_limit_clamped",
        "signature": "(tmp_path, monkeypatch)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_audit_history_limit_too_low_normalized",
        "signature": "(tmp_path, monkeypatch)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_coverage_endpoint",
        "signature": "(tmp_path, monkeypatch)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_coverage_missing_report",
        "signature": "(tmp_path, monkeypatch)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_rate_limiting",
        "signature": "(monkeypatch)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_startup_logs_configuration",
        "signature": "(monkeypatch, tmp_path, caplog)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_secure_mode_without_admin_token_fails",
        "signature": "(tmp_path, monkeypatch)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_secure_mode_requires_custom_neo4j_password",
        "signature": "(tmp_path, monkeypatch)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_rate_limiting_search",
        "signature": "(monkeypatch, tmp_path)",
        "is_async": false,
        "doc": null
      }
    ],
    "constants": []
  },
  "tests/test_app_smoke.py": {
    "doc": null,
    "imports": {
      "external": [
        "__future__",
        "fastapi",
        "json",
        "logging",
        "os",
        "pathlib",
        "pytest",
        "time",
        "unittest"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [],
    "functions": [
      {
        "name": "reset_settings_cache",
        "signature": "()",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_stub_connection_managers",
        "signature": "(monkeypatch)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_health_endpoint_reports_diagnostics",
        "signature": "(tmp_path, monkeypatch)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_health_endpoint_ok_when_artifacts_present",
        "signature": "(tmp_path, monkeypatch)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_ready_endpoint_returns_ready",
        "signature": "()",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_lifecycle_history_endpoint",
        "signature": "(tmp_path, monkeypatch)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_requires_non_default_neo4j_password_when_auth_enabled",
        "signature": "(monkeypatch, tmp_path)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_requires_non_empty_neo4j_password_when_auth_enabled",
        "signature": "(monkeypatch, tmp_path)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_logs_warning_when_neo4j_auth_disabled",
        "signature": "(monkeypatch, tmp_path, caplog)",
        "is_async": false,
        "doc": null
      }
    ],
    "constants": []
  },
  "tests/test_connection_managers.py": {
    "doc": null,
    "imports": {
      "external": [
        "__future__",
        "prometheus_client",
        "pytest",
        "types",
        "unittest"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [],
    "functions": [
      {
        "name": "_reset_metric",
        "signature": "(metric)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "reset_metrics",
        "signature": "()",
        "is_async": false,
        "doc": null
      },
      {
        "name": "make_settings",
        "signature": "(**overrides)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_make_dummy_driver",
        "signature": "()",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_neo4j_manager_records_success_and_failure",
        "signature": "(monkeypatch)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_qdrant_manager_handles_health_failures",
        "signature": "(monkeypatch)",
        "is_async": false,
        "doc": null
      }
    ],
    "constants": []
  },
  "tests/test_coverage_report.py": {
    "doc": null,
    "imports": {
      "external": [
        "__future__",
        "collections",
        "fastapi",
        "json",
        "pathlib",
        "prometheus_client",
        "pytest"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [
      {
        "name": "StubQdrantWriter",
        "bases": [],
        "methods": [
          {
            "name": "ensure_collection",
            "signature": "(self, vector_size)",
            "is_async": false
          },
          {
            "name": "upsert_chunks",
            "signature": "(self, chunks)",
            "is_async": false
          }
        ],
        "doc": null
      },
      {
        "name": "StubNeo4jWriter",
        "bases": [],
        "methods": [
          {
            "name": "ensure_constraints",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "sync_artifact",
            "signature": "(self, artifact)",
            "is_async": false
          },
          {
            "name": "sync_chunks",
            "signature": "(self, chunk_embeddings)",
            "is_async": false
          }
        ],
        "doc": null
      }
    ],
    "functions": [
      {
        "name": "test_write_coverage_report",
        "signature": "(tmp_path)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_coverage_endpoint_after_report_generation",
        "signature": "(tmp_path, monkeypatch)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_coverage_history_rotation",
        "signature": "(tmp_path)",
        "is_async": false,
        "doc": null
      }
    ],
    "constants": []
  },
  "tests/test_graph_api.py": {
    "doc": null,
    "imports": {
      "external": [
        "__future__",
        "fastapi",
        "neo4j",
        "os",
        "pathlib",
        "pytest",
        "typing"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [
      {
        "name": "DummyGraphService",
        "bases": [],
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, responses)",
            "is_async": false
          },
          {
            "name": "get_subsystem",
            "signature": "(self, name, **kwargs)",
            "is_async": false
          },
          {
            "name": "get_node",
            "signature": "(self, node_id, relationships, limit)",
            "is_async": false
          },
          {
            "name": "search",
            "signature": "(self, term, limit)",
            "is_async": false
          },
          {
            "name": "get_subsystem_graph",
            "signature": "(self, name, depth)",
            "is_async": false
          },
          {
            "name": "list_orphan_nodes",
            "signature": "(self, label, cursor, limit)",
            "is_async": false
          },
          {
            "name": "run_cypher",
            "signature": "(self, query, parameters)",
            "is_async": false
          }
        ],
        "doc": null
      }
    ],
    "functions": [
      {
        "name": "app",
        "signature": "(monkeypatch)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_graph_subsystem_returns_payload",
        "signature": "(app)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_graph_subsystem_legacy_path_missing",
        "signature": "(app)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_graph_subsystem_not_found",
        "signature": "(app)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_graph_subsystem_graph_endpoint",
        "signature": "(app)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_graph_orphans_endpoint",
        "signature": "(app)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_graph_node_endpoint",
        "signature": "(app)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_graph_node_accepts_slash_encoded_ids",
        "signature": "(app)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_graph_node_endpoint_live",
        "signature": "(monkeypatch, tmp_path)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_graph_search_endpoint_live",
        "signature": "(monkeypatch, tmp_path)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_graph_search_endpoint",
        "signature": "(app)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_graph_cypher_requires_maintainer_token",
        "signature": "(monkeypatch)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_graph_reader_scope",
        "signature": "(monkeypatch)",
        "is_async": false,
        "doc": null
      }
    ],
    "constants": [
      {
        "targets": [
          "GRAPH_PREFIX"
        ],
        "value": "f'{API_V1_PREFIX}/graph'"
      }
    ]
  },
  "tests/test_graph_auto_migrate.py": {
    "doc": null,
    "imports": {
      "external": [
        "__future__",
        "neo4j",
        "prometheus_client",
        "pytest",
        "unittest"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [],
    "functions": [
      {
        "name": "reset_settings_cache",
        "signature": "()",
        "is_async": false,
        "doc": null
      },
      {
        "name": "reset_migration_metrics",
        "signature": "()",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_metric",
        "signature": "(name)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_stub_managers",
        "signature": "(monkeypatch, driver=None, qdrant_client=None, write_driver_error=None)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_auto_migrate_runs_when_enabled",
        "signature": "(monkeypatch)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_auto_migrate_skipped_when_disabled",
        "signature": "(monkeypatch)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_auto_migrate_records_failure",
        "signature": "(monkeypatch)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_missing_database_disables_graph_driver",
        "signature": "(monkeypatch)",
        "is_async": false,
        "doc": null
      }
    ],
    "constants": []
  },
  "tests/test_graph_cli.py": {
    "doc": null,
    "imports": {
      "external": [
        "__future__",
        "pytest",
        "unittest"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [
      {
        "name": "DummySettings",
        "bases": [],
        "methods": [],
        "doc": null
      }
    ],
    "functions": [
      {
        "name": "test_graph_cli_migrate_runs_runner",
        "signature": "(monkeypatch)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_graph_cli_dry_run_prints_pending",
        "signature": "(monkeypatch, capsys)",
        "is_async": false,
        "doc": null
      }
    ],
    "constants": []
  },
  "tests/test_graph_database_validation.py": {
    "doc": null,
    "imports": {
      "external": [
        "__future__",
        "neo4j",
        "unittest"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [],
    "functions": [
      {
        "name": "test_verify_graph_database_returns_false_when_database_missing",
        "signature": "()",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_verify_graph_database_returns_true_on_success",
        "signature": "()",
        "is_async": false,
        "doc": null
      }
    ],
    "constants": []
  },
  "tests/test_graph_migrations.py": {
    "doc": null,
    "imports": {
      "external": [
        "__future__",
        "collections",
        "types"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [
      {
        "name": "FakeResult",
        "bases": [],
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, record=None)",
            "is_async": false
          },
          {
            "name": "single",
            "signature": "(self)",
            "is_async": false
          }
        ],
        "doc": null
      },
      {
        "name": "FakeTransaction",
        "bases": [],
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, applied_ids, results)",
            "is_async": false
          },
          {
            "name": "run",
            "signature": "(self, query, **params)",
            "is_async": false
          },
          {
            "name": "commit",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "rollback",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "__enter__",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "__exit__",
            "signature": "(self, exc_type, exc_val, exc_tb)",
            "is_async": false
          }
        ],
        "doc": null
      },
      {
        "name": "FakeSession",
        "bases": [],
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, applied_ids, records)",
            "is_async": false
          },
          {
            "name": "run",
            "signature": "(self, query, **params)",
            "is_async": false
          },
          {
            "name": "begin_transaction",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "close",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "__enter__",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "__exit__",
            "signature": "(self, exc_type, exc_val, exc_tb)",
            "is_async": false
          }
        ],
        "doc": null
      },
      {
        "name": "FakeDriver",
        "bases": [],
        "methods": [
          {
            "name": "__init__",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "session",
            "signature": "(self, database)",
            "is_async": false
          },
          {
            "name": "close",
            "signature": "(self)",
            "is_async": false
          }
        ],
        "doc": null
      }
    ],
    "functions": [
      {
        "name": "test_migration_runner_applies_pending_migrations",
        "signature": "()",
        "is_async": false,
        "doc": null
      }
    ],
    "constants": []
  },
  "tests/test_graph_service_startup.py": {
    "doc": null,
    "imports": {
      "external": [
        "__future__",
        "fastapi",
        "pytest",
        "starlette",
        "unittest"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [],
    "functions": [
      {
        "name": "reset_settings_cache",
        "signature": "()",
        "is_async": false,
        "doc": null
      },
      {
        "name": "set_state_path",
        "signature": "(tmp_path_factory, monkeypatch)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_receive",
        "signature": "()",
        "is_async": true,
        "doc": null
      },
      {
        "name": "_make_request",
        "signature": "(app)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_graph_dependency_returns_503_when_database_missing",
        "signature": "(monkeypatch)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_graph_dependency_returns_service_when_available",
        "signature": "(monkeypatch)",
        "is_async": false,
        "doc": null
      }
    ],
    "constants": []
  },
  "tests/test_graph_service_unit.py": {
    "doc": null,
    "imports": {
      "external": [
        "__future__",
        "collections",
        "pytest",
        "types",
        "unittest"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [
      {
        "name": "DummyNode",
        "bases": [
          "dict[str, object]"
        ],
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, labels, element_id, **props)",
            "is_async": false
          }
        ],
        "doc": null
      },
      {
        "name": "DummyRelationship",
        "bases": [
          "dict[str, object]"
        ],
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, start_node, end_node, rel_type, **props)",
            "is_async": false
          }
        ],
        "doc": null
      },
      {
        "name": "DummySession",
        "bases": [],
        "methods": [
          {
            "name": "__init__",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "__enter__",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "__exit__",
            "signature": "(self, exc_type, exc, tb)",
            "is_async": false
          },
          {
            "name": "execute_read",
            "signature": "(self, func, *args, **kwargs)",
            "is_async": false
          },
          {
            "name": "run",
            "signature": "(self, query, **params)",
            "is_async": false
          }
        ],
        "doc": null
      },
      {
        "name": "DummyDriver",
        "bases": [],
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, session)",
            "is_async": false
          },
          {
            "name": "session",
            "signature": "(self, **kwargs)",
            "is_async": false
          },
          {
            "name": "execute_query",
            "signature": "(self, query, parameters, database_)",
            "is_async": false
          }
        ],
        "doc": null
      }
    ],
    "functions": [
      {
        "name": "_reset_metric",
        "signature": "(reason)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_metric_value",
        "signature": "(reason)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "patch_graph_types",
        "signature": "(monkeypatch)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "dummy_driver",
        "signature": "()",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_get_subsystem_paginates_and_includes_artifacts",
        "signature": "(monkeypatch, dummy_driver)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_get_subsystem_missing_raises",
        "signature": "(monkeypatch, dummy_driver)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_get_subsystem_graph_returns_nodes_and_edges",
        "signature": "(monkeypatch, dummy_driver)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_fetch_subsystem_paths_inlines_depth_literal",
        "signature": "(monkeypatch)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_get_node_with_relationships",
        "signature": "(monkeypatch, dummy_driver)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_list_orphan_nodes_rejects_unknown_label",
        "signature": "(dummy_driver)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_list_orphan_nodes_serializes_results",
        "signature": "(monkeypatch, dummy_driver)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_get_node_missing_raises",
        "signature": "(monkeypatch, dummy_driver)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_search_serializes_results",
        "signature": "(monkeypatch, dummy_driver)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_shortest_path_depth",
        "signature": "(monkeypatch, dummy_driver)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_shortest_path_depth_none",
        "signature": "(monkeypatch, dummy_driver)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_run_cypher_serializes_records",
        "signature": "(monkeypatch, dummy_driver)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_run_cypher_rejects_non_read_queries",
        "signature": "(dummy_driver)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_run_cypher_rejects_updates_detected_in_counters",
        "signature": "(dummy_driver)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_run_cypher_allows_whitelisted_procedure",
        "signature": "(dummy_driver)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_run_cypher_rejects_disallowed_procedure",
        "signature": "(dummy_driver)",
        "is_async": false,
        "doc": null
      }
    ],
    "constants": []
  },
  "tests/test_graph_validation.py": {
    "doc": "End-to-end validation of ingestion and graph-backed search.",
    "imports": {
      "external": [
        "__future__",
        "collections",
        "neo4j",
        "os",
        "pathlib",
        "pytest",
        "qdrant_client",
        "typing"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [
      {
        "name": "_DummyEmbedder",
        "bases": [
          "Embedder"
        ],
        "methods": [
          {
            "name": "__init__",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "dimension",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "encode",
            "signature": "(self, texts)",
            "is_async": false
          }
        ],
        "doc": "Minimal embedder returning deterministic vectors for tests."
      },
      {
        "name": "_FakePoint",
        "bases": [],
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, payload, score)",
            "is_async": false
          }
        ],
        "doc": null
      },
      {
        "name": "_DummyQdrantClient",
        "bases": [],
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, points)",
            "is_async": false
          },
          {
            "name": "search",
            "signature": "(self, **_kwargs)",
            "is_async": false
          }
        ],
        "doc": "Stub Qdrant client that returns pre-seeded points."
      }
    ],
    "functions": [
      {
        "name": "test_ingestion_populates_graph",
        "signature": "(tmp_path)",
        "is_async": false,
        "doc": "Run ingestion and verify graph nodes, edges, and metadata."
      },
      {
        "name": "test_search_replay_against_real_graph",
        "signature": "(tmp_path)",
        "is_async": false,
        "doc": "Replay saved search results against the populated knowledge graph."
      }
    ],
    "constants": []
  },
  "tests/test_ingest_cli.py": {
    "doc": null,
    "imports": {
      "external": [
        "__future__",
        "pathlib",
        "pytest",
        "time",
        "unittest"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [],
    "functions": [
      {
        "name": "reset_settings_cache",
        "signature": "()",
        "is_async": false,
        "doc": null
      },
      {
        "name": "sample_repo",
        "signature": "(tmp_path)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_cli_rebuild_dry_run",
        "signature": "(sample_repo, monkeypatch)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_cli_rebuild_requires_maintainer_token",
        "signature": "(sample_repo, monkeypatch)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_cli_rebuild_with_maintainer_token",
        "signature": "(sample_repo, monkeypatch)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_cli_rebuild_full_rebuild_flag",
        "signature": "(sample_repo, monkeypatch)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_cli_rebuild_incremental_flag",
        "signature": "(sample_repo, monkeypatch)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_cli_audit_history_json",
        "signature": "(tmp_path, monkeypatch, capsys)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_cli_audit_history_limit_clamped",
        "signature": "(tmp_path, monkeypatch, capsys)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_cli_audit_history_no_entries",
        "signature": "(tmp_path, monkeypatch, capsys)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_audit_logger_recent_normalizes_limit",
        "signature": "(tmp_path)",
        "is_async": false,
        "doc": null
      }
    ],
    "constants": []
  },
  "tests/test_ingest_pipeline.py": {
    "doc": null,
    "imports": {
      "external": [
        "__future__",
        "collections",
        "json",
        "pathlib",
        "prometheus_client",
        "pytest"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [
      {
        "name": "StubQdrantWriter",
        "bases": [],
        "methods": [
          {
            "name": "__init__",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "ensure_collection",
            "signature": "(self, vector_size)",
            "is_async": false
          },
          {
            "name": "upsert_chunks",
            "signature": "(self, chunks)",
            "is_async": false
          },
          {
            "name": "delete_artifact",
            "signature": "(self, artifact_path)",
            "is_async": false
          }
        ],
        "doc": null
      },
      {
        "name": "StubNeo4jWriter",
        "bases": [],
        "methods": [
          {
            "name": "__init__",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "ensure_constraints",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "sync_artifact",
            "signature": "(self, artifact)",
            "is_async": false
          },
          {
            "name": "sync_chunks",
            "signature": "(self, chunk_embeddings)",
            "is_async": false
          },
          {
            "name": "delete_artifact",
            "signature": "(self, path)",
            "is_async": false
          }
        ],
        "doc": null
      }
    ],
    "functions": [
      {
        "name": "_metric_value",
        "signature": "(name, labels)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "sample_repo",
        "signature": "(tmp_path)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_pipeline_generates_chunks",
        "signature": "(sample_repo)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_pipeline_removes_stale_artifacts",
        "signature": "(tmp_path)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_pipeline_skips_unchanged_artifacts",
        "signature": "(tmp_path)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_artifact_ledger_writes_atomically",
        "signature": "(tmp_path)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_artifact_ledger_loads_gracefully_on_corruption",
        "signature": "(tmp_path)",
        "is_async": false,
        "doc": null
      }
    ],
    "constants": []
  },
  "tests/test_km_watch.py": {
    "doc": null,
    "imports": {
      "external": [
        "__future__",
        "os",
        "pathlib",
        "prometheus_client",
        "runpy",
        "sys"
      ],
      "internal": []
    },
    "classes": [],
    "functions": [
      {
        "name": "_metric_value",
        "signature": "(name, labels)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_compute_fingerprints",
        "signature": "(tmp_path)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_diff_fingerprints_detects_changes",
        "signature": "()",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_watch_metrics_increment",
        "signature": "(tmp_path)",
        "is_async": false,
        "doc": null
      }
    ],
    "constants": []
  },
  "tests/test_lifecycle_cli.py": {
    "doc": null,
    "imports": {
      "external": [
        "__future__",
        "json",
        "pathlib",
        "pytest"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [],
    "functions": [
      {
        "name": "test_lifecycle_cli_json",
        "signature": "(tmp_path, capsys)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_lifecycle_cli_missing_file",
        "signature": "(tmp_path, capsys)",
        "is_async": false,
        "doc": null
      }
    ],
    "constants": []
  },
  "tests/test_lifecycle_report.py": {
    "doc": "Unit tests for lifecycle report generation and graph enrichment.",
    "imports": {
      "external": [
        "__future__",
        "datetime",
        "json",
        "pathlib",
        "prometheus_client",
        "pytest",
        "typing"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [
      {
        "name": "DummyGraphService",
        "bases": [],
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, pages)",
            "is_async": false
          },
          {
            "name": "list_orphan_nodes",
            "signature": "(self, label, cursor, limit)",
            "is_async": false
          }
        ],
        "doc": "Test double that returns pre-seeded orphan graph nodes."
      }
    ],
    "functions": [
      {
        "name": "_ingestion_result",
        "signature": "()",
        "is_async": false,
        "doc": "Build a representative ingestion result for lifecycle reporting tests."
      },
      {
        "name": "test_write_lifecycle_report_without_graph",
        "signature": "(tmp_path, ingestion_result)",
        "is_async": false,
        "doc": "Reports render correctly when graph enrichment is disabled."
      },
      {
        "name": "test_write_lifecycle_report_with_graph",
        "signature": "(tmp_path, ingestion_result)",
        "is_async": false,
        "doc": "Graph enrichment populates isolated node information in the payload."
      }
    ],
    "constants": []
  },
  "tests/test_mcp_recipes.py": {
    "doc": null,
    "imports": {
      "external": [
        "__future__",
        "json",
        "pathlib",
        "pytest"
      ],
      "internal": []
    },
    "classes": [],
    "functions": [
      {
        "name": "test_snippets_are_valid_json",
        "signature": "(snippet)",
        "is_async": false,
        "doc": null
      }
    ],
    "constants": [
      {
        "targets": [
          "RECIPES"
        ],
        "value": "Path('docs/MCP_RECIPES.md').read_text()"
      }
    ]
  },
  "tests/test_mcp_smoke_recipes.py": {
    "doc": null,
    "imports": {
      "external": [
        "__future__",
        "json",
        "pathlib",
        "pytest"
      ],
      "internal": []
    },
    "classes": [],
    "functions": [
      {
        "name": "_recipe_params",
        "signature": "()",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_recipe_lines_are_valid_json",
        "signature": "(line)",
        "is_async": false,
        "doc": null
      }
    ],
    "constants": [
      {
        "targets": [
          "RECIPES"
        ],
        "value": "Path('docs/MCP_RECIPES.md').read_text().splitlines()"
      }
    ]
  },
  "tests/test_neo4j_writer.py": {
    "doc": "Unit tests for the lightweight Neo4j writer integration layer.",
    "imports": {
      "external": [
        "__future__",
        "neo4j",
        "pathlib",
        "types",
        "typing"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [
      {
        "name": "RecordingSession",
        "bases": [],
        "methods": [
          {
            "name": "__init__",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "run",
            "signature": "(self, query, **params)",
            "is_async": false
          },
          {
            "name": "__enter__",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "__exit__",
            "signature": "(self, exc_type, exc, tb)",
            "is_async": false
          }
        ],
        "doc": "Stubbed session that records Cypher queries for assertions."
      },
      {
        "name": "RecordingDriver",
        "bases": [],
        "methods": [
          {
            "name": "__init__",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "session",
            "signature": "(self, database=None)",
            "is_async": false
          }
        ],
        "doc": "Stubbed driver that yields recording sessions."
      }
    ],
    "functions": [
      {
        "name": "_make_writer",
        "signature": "()",
        "is_async": false,
        "doc": "Create a writer bound to a recording driver for inspection."
      },
      {
        "name": "test_sync_artifact_creates_domain_relationships",
        "signature": "()",
        "is_async": false,
        "doc": "Artifacts trigger the expected Cypher commands and relationships."
      },
      {
        "name": "test_sync_artifact_merges_subsystem_edge_once",
        "signature": "()",
        "is_async": false,
        "doc": "Syncing an artifact does not duplicate the subsystem relationship."
      },
      {
        "name": "test_sync_chunks_links_chunk_to_artifact",
        "signature": "()",
        "is_async": false,
        "doc": "Chunk synchronization creates chunk nodes and linking edges."
      }
    ],
    "constants": []
  },
  "tests/test_qdrant_writer.py": {
    "doc": null,
    "imports": {
      "external": [
        "__future__",
        "httpx",
        "pytest",
        "qdrant_client",
        "unittest"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [],
    "functions": [
      {
        "name": "stub_qdrant_models",
        "signature": "(monkeypatch)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "build_client",
        "signature": "(**kwargs)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_ensure_collection_creates_when_missing",
        "signature": "(monkeypatch)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_ensure_collection_noop_when_collection_exists",
        "signature": "()",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_ensure_collection_retries_on_transient_failure",
        "signature": "(monkeypatch)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_ensure_collection_handles_conflict",
        "signature": "()",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_reset_collection_invokes_recreate",
        "signature": "()",
        "is_async": false,
        "doc": null
      }
    ],
    "constants": []
  },
  "tests/test_recipes_executor.py": {
    "doc": null,
    "imports": {
      "external": [
        "__future__",
        "pathlib",
        "pytest",
        "types",
        "typing"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [
      {
        "name": "FakeToolExecutor",
        "bases": [],
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, responses)",
            "is_async": false
          },
          {
            "name": "__aenter__",
            "signature": "(self)",
            "is_async": true
          },
          {
            "name": "__aexit__",
            "signature": "(self, exc_type, exc, tb)",
            "is_async": true
          },
          {
            "name": "call",
            "signature": "(self, tool, params)",
            "is_async": true
          }
        ],
        "doc": null
      }
    ],
    "functions": [
      {
        "name": "test_recipe_runner_success",
        "signature": "(tmp_path)",
        "is_async": true,
        "doc": null
      },
      {
        "name": "test_recipe_runner_wait",
        "signature": "(tmp_path)",
        "is_async": true,
        "doc": null
      },
      {
        "name": "test_recipe_runner_expect_failure",
        "signature": "(tmp_path)",
        "is_async": true,
        "doc": null
      },
      {
        "name": "test_recipe_runner_dry_run",
        "signature": "(tmp_path)",
        "is_async": true,
        "doc": null
      }
    ],
    "constants": []
  },
  "tests/test_release_scripts.py": {
    "doc": null,
    "imports": {
      "external": [
        "__future__",
        "os",
        "pathlib",
        "subprocess"
      ],
      "internal": []
    },
    "classes": [],
    "functions": [
      {
        "name": "_env_with_venv",
        "signature": "()",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_build_wheel_script",
        "signature": "(tmp_path)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_checksums_script",
        "signature": "(tmp_path)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_generate_changelog",
        "signature": "(tmp_path)",
        "is_async": false,
        "doc": null
      }
    ],
    "constants": [
      {
        "targets": [
          "REPO_ROOT"
        ],
        "value": "Path(__file__).resolve().parents[1]"
      },
      {
        "targets": [
          "SCRIPTS_DIR"
        ],
        "value": "REPO_ROOT / 'scripts'"
      }
    ]
  },
  "tests/test_scheduler.py": {
    "doc": "Unit tests exercising the ingestion scheduler behaviour and metrics.",
    "imports": {
      "external": [
        "__future__",
        "apscheduler",
        "collections",
        "filelock",
        "os",
        "pathlib",
        "prometheus_client",
        "pytest",
        "unittest"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [],
    "functions": [
      {
        "name": "reset_cache",
        "signature": "()",
        "is_async": false,
        "doc": "Clear cached settings before and after each test."
      },
      {
        "name": "scheduler_settings",
        "signature": "(tmp_path)",
        "is_async": false,
        "doc": "Provide scheduler settings pointing at a temporary repo."
      },
      {
        "name": "make_scheduler",
        "signature": "(settings)",
        "is_async": false,
        "doc": "Instantiate a scheduler with its APScheduler stubbed out."
      },
      {
        "name": "_metric_value",
        "signature": "(name, labels=None)",
        "is_async": false,
        "doc": "Fetch a Prometheus sample value with defaults for missing metrics."
      },
      {
        "name": "make_result",
        "signature": "(head)",
        "is_async": false,
        "doc": "Construct a minimal ingestion result for scheduler tests."
      },
      {
        "name": "test_scheduler_skips_when_repo_head_unchanged",
        "signature": "(scheduler_settings)",
        "is_async": false,
        "doc": "Scheduler skips when repository head hash matches the cached value."
      },
      {
        "name": "test_scheduler_runs_when_repo_head_changes",
        "signature": "(scheduler_settings)",
        "is_async": false,
        "doc": "Scheduler triggers ingestion when the repository head changes."
      },
      {
        "name": "test_scheduler_start_uses_interval_trigger",
        "signature": "(scheduler_settings)",
        "is_async": false,
        "doc": "Schedulers without cron use the configured interval trigger."
      },
      {
        "name": "test_scheduler_start_uses_cron_trigger",
        "signature": "(tmp_path)",
        "is_async": false,
        "doc": "Cron expressions configure a cron trigger instead of interval."
      },
      {
        "name": "test_scheduler_schedules_backup_job",
        "signature": "(tmp_path)",
        "is_async": false,
        "doc": "Standalone backup schedules a job even when ingestion is disabled."
      },
      {
        "name": "test_scheduler_backup_run_records_metrics",
        "signature": "(tmp_path, monkeypatch)",
        "is_async": false,
        "doc": "Backup job updates metrics and retention tracking."
      },
      {
        "name": "test_scheduler_backup_failure_records_metrics",
        "signature": "(tmp_path, monkeypatch)",
        "is_async": false,
        "doc": "Failures set the status gauge and increment failure counters."
      },
      {
        "name": "test_scheduler_skips_when_lock_contended",
        "signature": "(scheduler_settings)",
        "is_async": false,
        "doc": "Lock contention causes the scheduler to skip runs and record metrics."
      },
      {
        "name": "test_scheduler_requires_maintainer_token",
        "signature": "(tmp_path)",
        "is_async": false,
        "doc": "Schedulers skip setup when auth is enabled without a maintainer token."
      }
    ],
    "constants": []
  },
  "tests/test_search_api.py": {
    "doc": null,
    "imports": {
      "external": [
        "__future__",
        "datetime",
        "fastapi",
        "json",
        "pathlib",
        "pytest"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [
      {
        "name": "DummySearchService",
        "bases": [],
        "methods": [
          {
            "name": "__init__",
            "signature": "(self)",
            "is_async": false
          },
          {
            "name": "search",
            "signature": "(self, query, limit, include_graph, graph_service, sort_by_vector=False, request_id=None, filters=None)",
            "is_async": false
          }
        ],
        "doc": null
      }
    ],
    "functions": [
      {
        "name": "test_search_endpoint_returns_results",
        "signature": "(monkeypatch, tmp_path)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_search_reuses_incoming_request_id",
        "signature": "(monkeypatch, tmp_path)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_search_requires_reader_token",
        "signature": "(monkeypatch, tmp_path)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_search_allows_maintainer_token",
        "signature": "(monkeypatch, tmp_path)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_search_feedback_logged",
        "signature": "(monkeypatch, tmp_path)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_search_filters_passed_to_service",
        "signature": "(monkeypatch, tmp_path)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_search_filters_invalid_type",
        "signature": "(monkeypatch, tmp_path)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_search_filters_invalid_namespaces",
        "signature": "(monkeypatch, tmp_path)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_search_filters_invalid_updated_after",
        "signature": "(monkeypatch, tmp_path)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_search_filters_invalid_max_age",
        "signature": "(monkeypatch, tmp_path)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_search_weights_endpoint",
        "signature": "(monkeypatch, tmp_path)",
        "is_async": false,
        "doc": null
      }
    ],
    "constants": []
  },
  "tests/test_search_cli_show_weights.py": {
    "doc": null,
    "imports": {
      "external": [
        "__future__",
        "pathlib",
        "pytest"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [],
    "functions": [
      {
        "name": "clear_settings_cache",
        "signature": "(monkeypatch, tmp_path)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_show_weights_command",
        "signature": "(capsys)",
        "is_async": false,
        "doc": null
      }
    ],
    "constants": []
  },
  "tests/test_search_evaluation.py": {
    "doc": null,
    "imports": {
      "external": [
        "__future__",
        "json",
        "math",
        "pathlib",
        "pytest"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [],
    "functions": [
      {
        "name": "test_evaluate_model",
        "signature": "(tmp_path)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_evaluate_cli",
        "signature": "(tmp_path, monkeypatch, capsys)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_evaluate_model_with_empty_dataset",
        "signature": "(tmp_path)",
        "is_async": false,
        "doc": null
      }
    ],
    "constants": []
  },
  "tests/test_search_exporter.py": {
    "doc": null,
    "imports": {
      "external": [
        "__future__",
        "csv",
        "json",
        "pathlib",
        "pytest"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [],
    "functions": [
      {
        "name": "_write_events",
        "signature": "(path, events)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "_sample_event",
        "signature": "(request_id, vote)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_export_training_dataset_csv",
        "signature": "(tmp_path)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_export_training_data_cli",
        "signature": "(tmp_path, monkeypatch)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_train_model_from_dataset",
        "signature": "(tmp_path)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_train_model_cli",
        "signature": "(tmp_path, monkeypatch)",
        "is_async": false,
        "doc": null
      }
    ],
    "constants": []
  },
  "tests/test_search_feedback.py": {
    "doc": null,
    "imports": {
      "external": [
        "__future__",
        "pathlib",
        "pytest"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [],
    "functions": [
      {
        "name": "_make_response",
        "signature": "(query, note)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_feedback_store_writes_entries",
        "signature": "(tmp_path)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_feedback_store_rotates_when_threshold_exceeded",
        "signature": "(tmp_path)",
        "is_async": false,
        "doc": null
      }
    ],
    "constants": []
  },
  "tests/test_search_maintenance.py": {
    "doc": "Tests for the search maintenance helpers.",
    "imports": {
      "external": [
        "__future__",
        "datetime",
        "json",
        "os",
        "pathlib",
        "pytest",
        "stat"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [],
    "functions": [
      {
        "name": "_write_events",
        "signature": "(path, requests)",
        "is_async": false,
        "doc": "Write JSON lines representing feedback events for the supplied requests."
      },
      {
        "name": "test_prune_feedback_log_parses_various_timestamp_formats",
        "signature": "(tmp_path)",
        "is_async": false,
        "doc": "Ensure prune handles numeric, Z-suffixed, and missing timestamps."
      },
      {
        "name": "test_prune_feedback_log_by_age",
        "signature": "(tmp_path)",
        "is_async": false,
        "doc": "Retains only entries newer than the configured age threshold."
      },
      {
        "name": "test_prune_feedback_log_missing_file",
        "signature": "(tmp_path)",
        "is_async": false,
        "doc": "Raises if the feedback log file is absent."
      },
      {
        "name": "test_prune_feedback_log_requires_limit",
        "signature": "(tmp_path)",
        "is_async": false,
        "doc": "Rejects calls without an age or request limit configured."
      },
      {
        "name": "test_prune_feedback_log_empty_file",
        "signature": "(tmp_path)",
        "is_async": false,
        "doc": "Returns zeroed stats when the log contains no events."
      },
      {
        "name": "test_prune_feedback_log_guard_when_pruning_everything",
        "signature": "(tmp_path, caplog)",
        "is_async": false,
        "doc": "Leaves the log intact when filters would drop every request."
      },
      {
        "name": "test_prune_feedback_log_max_requests_prefers_newest",
        "signature": "(tmp_path)",
        "is_async": false,
        "doc": "Keeps only the newest requests when enforcing a max count."
      },
      {
        "name": "test_redact_dataset_csv",
        "signature": "(tmp_path)",
        "is_async": false,
        "doc": "Redacts populated CSV fields for queries, contexts, and notes."
      },
      {
        "name": "test_redact_dataset_csv_handles_missing_and_blank_fields",
        "signature": "(tmp_path)",
        "is_async": false,
        "doc": "Leaves missing or blank CSV fields untouched while redacting non-empty ones."
      },
      {
        "name": "test_redact_dataset_jsonl",
        "signature": "(tmp_path)",
        "is_async": false,
        "doc": "Redacts JSONL query and context fields when toggled."
      },
      {
        "name": "test_redact_dataset_jsonl_handles_missing_and_blank_fields",
        "signature": "(tmp_path)",
        "is_async": false,
        "doc": "Leaves absent or empty JSONL fields untouched while redacting populated ones."
      },
      {
        "name": "test_redact_dataset_missing_file",
        "signature": "(tmp_path)",
        "is_async": false,
        "doc": "Raises if the target dataset file is absent."
      },
      {
        "name": "test_redact_dataset_unsupported_suffix",
        "signature": "(tmp_path)",
        "is_async": false,
        "doc": "Rejects unsupported dataset extensions."
      },
      {
        "name": "test_redact_dataset_output_path_copies_metadata",
        "signature": "(tmp_path)",
        "is_async": false,
        "doc": "Preserves metadata when writing to an alternate output path."
      },
      {
        "name": "test_redact_dataset_jsonl_handles_blank_lines",
        "signature": "(tmp_path)",
        "is_async": false,
        "doc": "Preserves blank lines in JSONL datasets while redacting content."
      }
    ],
    "constants": []
  },
  "tests/test_search_profiles.py": {
    "doc": null,
    "imports": {
      "external": [
        "__future__",
        "pytest"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [],
    "functions": [
      {
        "name": "clear_weight_env",
        "signature": "(monkeypatch)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_resolved_search_weights_default",
        "signature": "()",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_resolved_search_weights_profile_selection",
        "signature": "(monkeypatch)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_resolved_search_weights_overrides",
        "signature": "(monkeypatch)",
        "is_async": false,
        "doc": null
      }
    ],
    "constants": []
  },
  "tests/test_search_service.py": {
    "doc": null,
    "imports": {
      "external": [
        "__future__",
        "collections",
        "datetime",
        "prometheus_client",
        "pytest",
        "time",
        "typing"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [
      {
        "name": "FakeEmbedder",
        "bases": [],
        "methods": [
          {
            "name": "encode",
            "signature": "(self, texts)",
            "is_async": false
          }
        ],
        "doc": null
      },
      {
        "name": "FakePoint",
        "bases": [],
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, payload, score)",
            "is_async": false
          }
        ],
        "doc": null
      },
      {
        "name": "FakeQdrantClient",
        "bases": [],
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, points)",
            "is_async": false
          },
          {
            "name": "search",
            "signature": "(self, **kwargs)",
            "is_async": false
          }
        ],
        "doc": null
      },
      {
        "name": "DummyGraphService",
        "bases": [
          "GraphService"
        ],
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, response)",
            "is_async": false
          },
          {
            "name": "get_node",
            "signature": "(self, node_id, relationships, limit)",
            "is_async": false
          },
          {
            "name": "get_subsystem",
            "signature": "(self, *args, **kwargs)",
            "is_async": false
          },
          {
            "name": "search",
            "signature": "(self, term, limit)",
            "is_async": false
          },
          {
            "name": "run_cypher",
            "signature": "(self, query, parameters)",
            "is_async": false
          },
          {
            "name": "shortest_path_depth",
            "signature": "(self, node_id, max_depth=4)",
            "is_async": false
          }
        ],
        "doc": null
      },
      {
        "name": "SlowGraphService",
        "bases": [
          "DummyGraphService"
        ],
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, response, delay)",
            "is_async": false
          },
          {
            "name": "get_node",
            "signature": "(self, node_id, relationships, limit)",
            "is_async": false
          }
        ],
        "doc": null
      },
      {
        "name": "MapGraphService",
        "bases": [
          "GraphService"
        ],
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, data)",
            "is_async": false
          },
          {
            "name": "get_node",
            "signature": "(self, node_id, relationships, limit)",
            "is_async": false
          },
          {
            "name": "get_subsystem",
            "signature": "(self, *args, **kwargs)",
            "is_async": false
          },
          {
            "name": "search",
            "signature": "(self, term, limit)",
            "is_async": false
          },
          {
            "name": "run_cypher",
            "signature": "(self, query, parameters)",
            "is_async": false
          },
          {
            "name": "shortest_path_depth",
            "signature": "(self, node_id, max_depth=4)",
            "is_async": false
          }
        ],
        "doc": null
      },
      {
        "name": "CountingGraphService",
        "bases": [
          "GraphService"
        ],
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, response, depth=2)",
            "is_async": false
          },
          {
            "name": "get_node",
            "signature": "(self, node_id, relationships, limit)",
            "is_async": false
          },
          {
            "name": "shortest_path_depth",
            "signature": "(self, node_id, max_depth=4)",
            "is_async": false
          },
          {
            "name": "get_subsystem",
            "signature": "(self, *args, **kwargs)",
            "is_async": false
          },
          {
            "name": "search",
            "signature": "(self, term, limit)",
            "is_async": false
          },
          {
            "name": "run_cypher",
            "signature": "(self, query, parameters)",
            "is_async": false
          }
        ],
        "doc": null
      }
    ],
    "functions": [
      {
        "name": "_metric_value",
        "signature": "(name, labels=None)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "sample_points",
        "signature": "()",
        "is_async": false,
        "doc": null
      },
      {
        "name": "graph_response",
        "signature": "()",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_search_service_enriches_with_graph",
        "signature": "(sample_points, graph_response)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_search_service_handles_missing_graph",
        "signature": "(sample_points)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_search_hnsw_search_params",
        "signature": "(sample_points)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_lexical_score_affects_ranking",
        "signature": "()",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_search_service_orders_by_adjusted_score",
        "signature": "()",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_search_service_caches_graph_lookups",
        "signature": "(sample_points, graph_response)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_search_service_filters_artifact_types",
        "signature": "()",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_search_service_filters_namespaces",
        "signature": "()",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_search_service_filters_tags",
        "signature": "()",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_search_service_filters_recency_updated_after",
        "signature": "()",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_search_service_filters_recency_max_age_days",
        "signature": "()",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_search_service_filters_subsystem_via_graph",
        "signature": "(graph_response)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_search_service_ml_model_reorders_results",
        "signature": "()",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_search_service_limits_graph_results",
        "signature": "(graph_response)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_search_service_respects_graph_time_budget",
        "signature": "(graph_response)",
        "is_async": false,
        "doc": null
      }
    ],
    "constants": []
  },
  "tests/test_settings_defaults.py": {
    "doc": null,
    "imports": {
      "external": [
        "__future__",
        "pytest"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [],
    "functions": [
      {
        "name": "test_neo4j_database_defaults_to_neo4j",
        "signature": "(monkeypatch)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_neo4j_auth_enabled_defaults_true",
        "signature": "(monkeypatch)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_auth_enabled_defaults_true",
        "signature": "(monkeypatch)",
        "is_async": false,
        "doc": null
      }
    ],
    "constants": []
  },
  "tests/test_tracing.py": {
    "doc": null,
    "imports": {
      "external": [
        "__future__",
        "opentelemetry",
        "pytest"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [],
    "functions": [
      {
        "name": "test_tracing_disabled_by_default",
        "signature": "(monkeypatch)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_tracing_enabled_instruments_app",
        "signature": "(monkeypatch)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_tracing_uses_otlp_exporter",
        "signature": "(monkeypatch)",
        "is_async": false,
        "doc": null
      },
      {
        "name": "test_tracing_console_fallback",
        "signature": "(monkeypatch)",
        "is_async": false,
        "doc": null
      }
    ],
    "constants": []
  },
  "tests/test_ui_routes.py": {
    "doc": "Smoke tests covering the HTML console routes exposed by the gateway API.",
    "imports": {
      "external": [
        "__future__",
        "fastapi",
        "pathlib",
        "prometheus_client",
        "pytest"
      ],
      "internal": [
        "gateway"
      ]
    },
    "classes": [],
    "functions": [
      {
        "name": "_reset_settings",
        "signature": "(tmp_path=None)",
        "is_async": false,
        "doc": "Clear cached settings and ensure the state directory exists for tests."
      },
      {
        "name": "test_ui_landing_served",
        "signature": "(tmp_path, monkeypatch)",
        "is_async": false,
        "doc": "The landing page renders successfully and increments the landing metric."
      },
      {
        "name": "test_ui_search_view",
        "signature": "(tmp_path, monkeypatch)",
        "is_async": false,
        "doc": "The search view renders and increments the search metric."
      },
      {
        "name": "test_ui_subsystems_view",
        "signature": "(tmp_path, monkeypatch)",
        "is_async": false,
        "doc": "The subsystems view renders and increments the subsystem metric."
      },
      {
        "name": "test_ui_lifecycle_download",
        "signature": "(tmp_path, monkeypatch)",
        "is_async": false,
        "doc": "Lifecycle report downloads are returned and recorded in metrics."
      },
      {
        "name": "test_ui_events_endpoint",
        "signature": "(tmp_path, monkeypatch)",
        "is_async": false,
        "doc": "Custom UI events are accepted and reflected in Prometheus metrics."
      }
    ],
    "constants": []
  }
}